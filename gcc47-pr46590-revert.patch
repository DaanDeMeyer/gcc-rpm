Revert:
2012-01-19  Michael Matz  <matz@suse.de>

	PR tree-optimization/46590
	* cfgexpand.c (add_scope_conflicts_1): New old_conflicts argument,
	use it in remembering which conflicts we already created.
	(add_scope_conflicts): Adjust call to above, (de)allocate helper
	bitmap.

--- gcc/cfgexpand.c	(revision 183305)
+++ gcc/cfgexpand.c	(revision 183304)
@@ -441,12 +441,11 @@ visit_conflict (gimple stmt ATTRIBUTE_UN
 
 /* Helper routine for add_scope_conflicts, calculating the active partitions
    at the end of BB, leaving the result in WORK.  We're called to generate
-   conflicts when OLD_CONFLICTS is non-null, otherwise we're just tracking
-   liveness.  If we generate conflicts then OLD_CONFLICTS stores the bits
-   for which we generated conflicts already.  */
+   conflicts when FOR_CONFLICT is true, otherwise we're just tracking
+   liveness.  */
 
 static void
-add_scope_conflicts_1 (basic_block bb, bitmap work, bitmap old_conflicts)
+add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)
 {
   edge e;
   edge_iterator ei;
@@ -483,7 +482,7 @@ add_scope_conflicts_1 (basic_block bb, b
 	}
       else if (!is_gimple_debug (stmt))
 	{
-	  if (old_conflicts
+	  if (for_conflict
 	      && visit == visit_op)
 	    {
 	      /* If this is the first real instruction in this BB we need
@@ -491,27 +490,16 @@ add_scope_conflicts_1 (basic_block bb, b
 		 Unlike classical liveness for named objects we can't
 		 rely on seeing a def/use of the names we're interested in.
 		 There might merely be indirect loads/stores.  We'd not add any
-		 conflicts for such partitions.  We know that we generated
-		 conflicts between all partitions in old_conflicts already,
-		 so we need to generate only the new ones, avoiding to
-		 repeatedly pay the O(N^2) cost for each basic block.  */
+		 conflicts for such partitions.  */
 	      bitmap_iterator bi;
 	      unsigned i;
-
-	      EXECUTE_IF_AND_COMPL_IN_BITMAP (work, old_conflicts, 0, i, bi)
+	      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)
 		{
 		  unsigned j;
 		  bitmap_iterator bj;
-		  /* First the conflicts between new and old_conflicts.  */
-		  EXECUTE_IF_SET_IN_BITMAP (old_conflicts, 0, j, bj)
-		    add_stack_var_conflict (i, j);
-		  /* Then the conflicts between only the new members.  */
-		  EXECUTE_IF_AND_COMPL_IN_BITMAP (work, old_conflicts, i + 1,
-						  j, bj)
+		  EXECUTE_IF_SET_IN_BITMAP (work, i + 1, j, bj)
 		    add_stack_var_conflict (i, j);
 		}
-	      /* And remember for the next basic block.  */
-	      bitmap_ior_into (old_conflicts, work);
 	      visit = visit_conflict;
 	    }
 	  walk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);
@@ -528,7 +516,6 @@ add_scope_conflicts (void)
   basic_block bb;
   bool changed;
   bitmap work = BITMAP_ALLOC (NULL);
-  bitmap old_conflicts;
 
   /* We approximate the live range of a stack variable by taking the first
      mention of its name as starting point(s), and by the end-of-scope
@@ -550,18 +537,15 @@ add_scope_conflicts (void)
       FOR_EACH_BB (bb)
 	{
 	  bitmap active = (bitmap)bb->aux;
-	  add_scope_conflicts_1 (bb, work, NULL);
+	  add_scope_conflicts_1 (bb, work, false);
 	  if (bitmap_ior_into (active, work))
 	    changed = true;
 	}
     }
 
-  old_conflicts = BITMAP_ALLOC (NULL);
-
   FOR_EACH_BB (bb)
-    add_scope_conflicts_1 (bb, work, old_conflicts);
+    add_scope_conflicts_1 (bb, work, true);
 
-  BITMAP_FREE (old_conflicts);
   BITMAP_FREE (work);
   FOR_ALL_BB (bb)
     BITMAP_FREE (bb->aux);
