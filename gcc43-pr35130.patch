2008-02-11  Jakub Jelinek  <jakub@redhat.com>

	PR middle-end/35130
	* tree-nested.c (convert_call_expr): Put FRAME.* vars into
	OMP_CLAUSE_SHARED rather than OMP_CLAUSE_FIRSTPRIVATE clause.

	* testsuite/libgomp.fortran/pr35130.f90: New test.
	* testsuite/libgomp.c/pr35130.c: New test.

--- gcc/tree-nested.c.jj	2008-02-11 14:48:12.000000000 +0100
+++ gcc/tree-nested.c	2008-02-11 17:09:23.000000000 +0100
@@ -1739,7 +1739,8 @@ convert_call_expr (tree *tp, int *walk_s
 	      break;
 	  if (c == NULL)
 	    {
-	      c = build_omp_clause (OMP_CLAUSE_FIRSTPRIVATE);
+	      c = build_omp_clause (i ? OMP_CLAUSE_FIRSTPRIVATE
+				      : OMP_CLAUSE_SHARED);
 	      OMP_CLAUSE_DECL (c) = decl;
 	      OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);
 	      OMP_PARALLEL_CLAUSES (t) = c;
--- libgomp/testsuite/libgomp.fortran/pr35130.f90.jj	2008-02-11 17:15:58.000000000 +0100
+++ libgomp/testsuite/libgomp.fortran/pr35130.f90	2008-02-11 17:16:07.000000000 +0100
@@ -0,0 +1,20 @@
+! PR middle-end/35130
+
+program pr35130
+  implicit none
+  real, dimension(20) :: a
+  integer :: k
+  a(:) = 0.0
+!$omp parallel do private(k)
+  do k=1,size(a)
+    call inner(k)
+  end do
+!$omp end parallel do
+  if (any (a.ne.42)) call abort
+contains
+ subroutine inner(i)
+   implicit none
+   integer :: i
+   a(i) = 42
+ end subroutine inner
+end program pr35130
--- libgomp/testsuite/libgomp.c/pr35130.c.jj	2008-02-11 17:12:18.000000000 +0100
+++ libgomp/testsuite/libgomp.c/pr35130.c	2008-02-11 17:12:03.000000000 +0100
@@ -0,0 +1,131 @@
+/* PR middle-end/35130 */
+
+extern void abort (void);
+
+void
+f1 (void)
+{
+  int a[4], k;
+  void nested (int x)
+  {
+    a[x] = 42;
+  }
+
+  for (k = 0; k < 4; k++)
+    a[k] = 0;
+#pragma omp parallel for
+  for (k = 0; k < 4; k++)
+    nested (k);
+
+  if (a[0] != 42 || a[1] != 42 || a[2] != 42 || a[3] != 42)
+    abort ();
+}
+
+void
+f2 (void)
+{
+  int a[4], k;
+  void nested (void)
+  {
+    int l;
+    void nested2 (int x)
+    {
+      a[x] = 42;
+    }
+#pragma omp parallel for
+    for (l = 0; l < 4; l++)
+      nested2 (l);
+  }
+
+  for (k = 0; k < 4; k++)
+    a[k] = 0;
+
+  nested ();
+
+  if (a[0] != 42 || a[1] != 42 || a[2] != 42 || a[3] != 42)
+    abort ();
+}
+
+void
+f3 (void)
+{
+  int a[4], b[4], c[4], k;
+  void nested (int x)
+  {
+    a[x] = b[x] = c[x] = 42;
+  }
+
+  for (k = 0; k < 4; k++)
+    a[k] = b[k] = c[k] = 0;
+  nested (0);
+
+#pragma omp parallel
+  {
+  #pragma omp single
+    {
+      a[1] = 43;
+      b[1] = 43;
+    }
+  #pragma omp parallel
+    {
+    #pragma omp single
+      {
+	b[2] = 44;
+	c[2] = 44;
+      }
+    }
+  }
+
+  if (a[0] != 42 || a[1] != 43 || a[2] != 0 || a[3] != 0)
+    abort ();
+  if (b[0] != 42 || b[1] != 43 || b[2] != 44 || b[3] != 0)
+    abort ();
+  if (c[0] != 42 || c[1] != 0 || c[2] != 44 || c[3] != 0)
+    abort ();
+}
+
+void
+f4 (void)
+{
+  int a[4], b[4], c[4], k;
+  void nested ()
+  {
+  #pragma omp parallel
+    {
+    #pragma omp single
+      {
+	a[1] = 43;
+	b[1] = 43;
+      }
+    #pragma omp parallel
+      {
+      #pragma omp single
+	{
+	  b[2] = 44;
+	  c[2] = 44;
+	}
+      }
+    }
+  }
+
+  for (k = 0; k < 4; k++)
+    a[k] = b[k] = c[k] = k == 0 ? 42 : 0;
+  nested ();
+
+  if (a[0] != 42 || a[1] != 43 || a[2] != 0 || a[3] != 0)
+    abort ();
+  if (b[0] != 42 || b[1] != 43 || b[2] != 44 || b[3] != 0)
+    abort ();
+  if (c[0] != 42 || c[1] != 0 || c[2] != 44 || c[3] != 0)
+    abort ();
+}
+
+int
+main (void)
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  return 0;
+}
