2008-02-18  Jakub Jelinek  <jakub@redhat.com>

	PR c++/35078
	* parser.c (cp_parser_omp_for_loop): If DECL has REFERENCE_TYPE, don't
	call cp_finish_decl.
	* semantics.c (finish_omp_for): Fail if DECL doesn't have integral type
	early.

	* g++.dg/gomp/pr35078.C: New test.

--- gcc/cp/parser.c.jj	2008-02-13 21:20:19.000000000 +0100
+++ gcc/cp/parser.c	2008-02-18 11:05:25.000000000 +0100
@@ -20074,8 +20074,11 @@ cp_parser_omp_for_loop (cp_parser *parse
 
 	      init = cp_parser_assignment_expression (parser, false);
 
-	      cp_finish_decl (decl, NULL_TREE, /*init_const_expr_p=*/false,
-			      asm_specification, LOOKUP_ONLYCONVERTING);
+	      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)
+		init = error_mark_node;
+	      else
+		cp_finish_decl (decl, NULL_TREE, /*init_const_expr_p=*/false,
+				asm_specification, LOOKUP_ONLYCONVERTING);
 
 	      if (pushed_scope)
 		pop_scope (pushed_scope);
--- gcc/cp/semantics.c.jj	2008-02-13 20:58:57.000000000 +0100
+++ gcc/cp/semantics.c	2008-02-18 10:51:04.000000000 +0100
@@ -3903,6 +3903,16 @@ finish_omp_for (location_t locus, tree d
       return NULL;
     }
 
+  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))
+    {
+      location_t elocus = locus;
+
+      if (EXPR_HAS_LOCATION (init))
+	elocus = EXPR_LOCATION (init);
+      error ("%Hinvalid type for iteration variable %qE", &elocus, decl);
+      return NULL;
+    }
+
   if (pre_body == NULL || IS_EMPTY_STMT (pre_body))
     pre_body = NULL;
   else if (! processing_template_decl)
--- gcc/testsuite/g++.dg/gomp/pr35078.C.jj	2008-02-18 11:07:21.000000000 +0100
+++ gcc/testsuite/g++.dg/gomp/pr35078.C	2008-02-18 11:07:04.000000000 +0100
@@ -0,0 +1,20 @@
+// PR c++/35078
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+template<int> void
+foo ()
+{
+#pragma omp parallel for
+  for (int& i = 0; i < 10; ++i)	// { dg-error "invalid type for iteration variable" }
+    ;
+}
+
+void
+bar ()
+{
+  int j = 0;
+#pragma omp parallel for
+  for (int& i = j; i < 10; ++i)	// { dg-error "invalid type for iteration variable" }
+    ;
+}
