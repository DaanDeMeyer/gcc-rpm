Revert:

2018-02-09  Alexandre Oliva <aoliva@redhat.com>

	* cfgexpand.c (expand_gimple_basic_block): Handle inline entry
	markers.
	* dwarf2out.c (dwarf2_debug_hooks): Enable inline_entry hook.
	(BLOCK_INLINE_ENTRY_LABEL): New.
	(dwarf2out_var_location): Disregard inline entry markers.
	(inline_entry_data): New struct.
	(inline_entry_data_hasher): New hashtable type.
	(inline_entry_data_hasher::hash): New.
	(inline_entry_data_hasher::equal): New.
	(inline_entry_data_table): New variable.
	(add_high_low_attributes): Add DW_AT_entry_pc and
	DW_AT_GNU_entry_view attributes if a pending entry is found
	in inline_entry_data_table.  Add old entry_pc attribute only
	if debug nonbinding markers are disabled.
	(gen_inlined_subroutine_die): Set BLOCK_DIE if nonbinding
	markers are enabled.
	(block_within_block_p, dwarf2out_inline_entry): New.
	(dwarf2out_finish): Check that no entries remained in
	inline_entry_data_table.
	* final.c (reemit_insn_block_notes): Handle inline entry notes.
	(final_scan_insn, notice_source_line): Likewise.
	(rest_of_clean_state): Skip inline entry markers.
	* gimple-pretty-print.c (dump_gimple_debug): Handle inline entry
	markers.
	* gimple.c (gimple_build_debug_inline_entry): New.
	* gimple.h (enum gimple_debug_subcode): Add
	GIMPLE_DEBUG_INLINE_ENTRY.
	(gimple_build_debug_inline_entry): Declare.
	(gimple_debug_inline_entry_p): New.
	(gimple_debug_nonbind_marker_p): Adjust.
	* insn-notes.def (INLINE_ENTRY): New.
	* print-rtl.c (rtx_writer::print_rtx_operand_code_0): Handle
	inline entry marker notes.
	(print_insn): Likewise.
	* rtl.h	(NOTE_MARKER_P): Add INLINE_ENTRY support.
	(INSN_DEBUG_MARKER_KIND): Likewise.
	(GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT): New.
	* tree-inline.c	(expand_call_inline): Build and insert
	debug_inline_entry stmt.
	* tree-ssa-live.c (remove_unused_scope_block_p): Preserve
	inline entry blocks early, if nonbind markers are enabled.
	(dump_scope_block): Dump fragment info.
	* var-tracking.c (reemit_marker_as_note): Handle inline entry note.
	* doc/gimple.texi (gimple_debug_inline_entry_p): New.
	(gimple_build_debug_inline_entry): New.
	* doc/invoke.texi (gstatement-frontiers, gno-statement-frontiers):
	Enable/disable inline entry points too.
	* doc/rtl.texi (NOTE_INSN_INLINE_ENTRY): New.
	(DEBUG_INSN): Describe inline entry markers.

	* common.opt (gvariable-location-views): New.
	(gvariable-location-views=incompat5): New.
	* config.in: Rebuilt.
	* configure: Rebuilt.
	* configure.ac: Test assembler for view support.
	* dwarf2asm.c (dw2_asm_output_symname_uleb128): New.
	* dwarf2asm.h (dw2_asm_output_symname_uleb128): Declare.
	* dwarf2out.c (var_loc_view): New typedef.
	(struct dw_loc_list_struct): Add vl_symbol, vbegin, vend.
	(dwarf2out_locviews_in_attribute): New.
	(dwarf2out_locviews_in_loclist): New.
	(dw_val_equal_p): Compare val_view_list of dw_val_class_view_lists.
	(enum dw_line_info_opcode): Add LI_adv_address.
	(struct dw_line_info_table): Add view.
	(RESET_NEXT_VIEW, RESETTING_VIEW_P): New macros.
	(DWARF2_ASM_VIEW_DEBUG_INFO): Define default.
	(zero_view_p): New variable.
	(ZERO_VIEW_P): New macro.
	(output_asm_line_debug_info): New.
	(struct var_loc_node): Add view.
	(add_AT_view_list, AT_loc_list): New.
	(add_var_loc_to_decl): Add view param.  Test it against last.
	(new_loc_list): Add view params.  Record them.
	(AT_loc_list_ptr): Handle loc and view lists.
	(view_list_to_loc_list_val_node): New.
	(print_dw_val): Handle dw_val_class_view_list.
	(size_of_die): Likewise.
	(value_format): Likewise.
	(loc_list_has_views): New.
	(gen_llsym): Set vl_symbol too.
	(maybe_gen_llsym, skip_loc_list_entry): New.
	(dwarf2out_maybe_output_loclist_view_pair): New.
	(output_loc_list): Output view list or entries too.
	(output_view_list_offset): New.
	(output_die): Handle dw_val_class_view_list.
	(output_dwarf_version): New.
	(output_compilation_unit_header): Use it.
	(output_skeleton_debug_sections): Likewise.
	(output_rnglists, output_line_info): Likewise.
	(output_pubnames, output_aranges): Update version comments.
	(output_one_line_info_table): Output view numbers in asm comments.
	(dw_loc_list): Determine current endview, pass it to new_loc_list.
	Call maybe_gen_llsym.
	(loc_list_from_tree_1): Adjust.
	(add_AT_location_description): Create view list attribute if
	needed, check it's absent otherwise.
	(convert_cfa_to_fb_loc_list): Adjust.
	(maybe_emit_file): Call output_asm_line_debug_info for test.
	(dwarf2out_var_location): Reset views as needed.  Precompute
	add_var_loc_to_decl args.  Call get_attr_min_length only if we have the
	attribute.  Set view.
	(new_line_info_table): Reset next view.
	(set_cur_line_info_table): Call output_asm_line_debug_info for test.
	(dwarf2out_source_line): Likewise.  Output view resets and labels to
	the assembler, or select appropriate line info opcodes.
	(prune_unused_types_walk_attribs): Handle dw_val_class_view_list.
	(optimize_string_length): Catch it.  Adjust.
	(resolve_addr): Copy vl_symbol along with ll_symbol.  Handle
	dw_val_class_view_list, and remove it if no longer needed.
	(hash_loc_list): Hash view numbers.
	(loc_list_hasher::equal): Compare them.
	(optimize_location_lists): Check whether a view list symbol is
	needed, and whether the locview attribute is present, and
	whether they match.  Remove the locview attribute if no longer
	needed.
	(index_location_lists): Call skip_loc_list_entry for test.
	(dwarf2out_finish): Call output_asm_line_debug_info for test.
	Use output_dwarf_version.
	* dwarf2out.h (enum dw_val_class): Add dw_val_class_view_list.
	(struct dw_val_node): Add val_view_list.
	* final.c (SEEN_NEXT_VIEW): New.
	(set_next_view_needed): New.
	(clear_next_view_needed): New.
	(maybe_output_next_view): New.
	(final_start_function): Rename to...
	(final_start_function_1): ... this.  Take pointer to FIRST,
	add SEEN parameter.  Emit param bindings in the initial view.
	(final_start_function): Reintroduce SEEN-less interface.
	(final): Rename to...
	(final_1): ... this.  Take SEEN parameter.  Output final pending
	next view at the end.
	(final): Reintroduce seen-less interface.
	(final_scan_insn): Output pending next view before switching
	sections or ending a block.  Mark the next view as needed when
	outputting variable locations.  Notify debug backend of section
	changes, and of location view changes.
	(rest_of_handle_final): Adjust.
	* toplev.c (process_options): Autodetect value for debug variable
	location views option.  Warn on incompat5 without -gdwarf-5.
	* doc/invoke.texi (gvariable-location-views): New.
	(gvariable-location-views=incompat5): New.
	(gno-variable-location-views): New.
include/
	* dwarf2.def (DW_AT_GNU_entry_view): New.

	* dwarf2.def (DW_AT_GNU_locviews): New.
	* dwarf2.h (enum dwarf_location_list_entry_type): Add
	DW_LLE_GNU_view_pair.
	(DW_LLE_view_pair): Define.

--- include/dwarf2.def	(revision 257511)
+++ include/dwarf2.def	(revision 257509)
@@ -443,8 +443,6 @@ DW_AT (DW_AT_GNU_pubtypes, 0x2135)
 /* Attribute for discriminator.
    See http://gcc.gnu.org/wiki/Discriminator  */
 DW_AT (DW_AT_GNU_discriminator, 0x2136)
-DW_AT (DW_AT_GNU_locviews, 0x2137)
-DW_AT (DW_AT_GNU_entry_view, 0x2138)
 /* VMS extensions.  */
 DW_AT (DW_AT_VMS_rtnbeg_pd_address, 0x2201)
 /* GNAT extensions.  */
--- include/dwarf2.h	(revision 257511)
+++ include/dwarf2.h	(revision 257509)
@@ -298,14 +298,6 @@ enum dwarf_location_list_entry_type
     DW_LLE_start_end = 0x07,
     DW_LLE_start_length = 0x08,
 
-    /* <http://lists.dwarfstd.org/private.cgi/dwarf-discuss-dwarfstd.org/2017-April/004347.html>
-       has the proposal for now; only available to list members.
-
-       A (possibly updated) copy of the proposal is available at
-       <http://people.redhat.com/aoliva/papers/sfn/dwarf6-sfn-lvu.txt>.  */
-    DW_LLE_GNU_view_pair = 0x09,
-#define DW_LLE_view_pair DW_LLE_GNU_view_pair
-
     /* Former extension for Fission.
        See http://gcc.gnu.org/wiki/DebugFission.  */
     DW_LLE_GNU_end_of_list_entry = 0x00,
--- gcc/doc/gimple.texi	(revision 257511)
+++ gcc/doc/gimple.texi	(revision 257509)
@@ -836,11 +836,6 @@ Return true if g is a @code{GIMPLE_DEBUG
 a source statement.
 @end deftypefn
 
-@deftypefn {GIMPLE function} gimple_debug_inline_entry_p (gimple g)
-Return true if g is a @code{GIMPLE_DEBUG} that marks the entry
-point of an inlined function.
-@end deftypefn
-
 @deftypefn {GIMPLE function} gimple_debug_nonbind_marker_p (gimple g)
 Return true if g is a @code{GIMPLE_DEBUG} that marks a program location,
 without any variable binding.
@@ -1546,7 +1541,6 @@ Set the conditional @code{COND_STMT} to
 @cindex @code{GIMPLE_DEBUG}
 @cindex @code{GIMPLE_DEBUG_BIND}
 @cindex @code{GIMPLE_DEBUG_BEGIN_STMT}
-@cindex @code{GIMPLE_DEBUG_INLINE_ENTRY}
 
 @deftypefn {GIMPLE function} gdebug *gimple_build_debug_bind (tree var, @
 tree value, gimple stmt)
@@ -1632,18 +1626,6 @@ observable, and that none of the side ef
 statements are.
 @end deftypefn
 
-@deftypefn {GIMPLE function} gimple gimple_build_debug_inline_entry (tree block, location_t location)
-Build a @code{GIMPLE_DEBUG} statement with
-@code{GIMPLE_DEBUG_INLINE_ENTRY} @code{subcode}.  The effect of this
-statement is to tell debug information generation machinery that a
-function call at @code{location} underwent inline substitution, that
-@code{block} is the enclosing lexical block created for the
-substitution, and that at the point of the program in which the stmt is
-inserted, all parameters for the inlined function are bound to the
-respective arguments, and none of the side effects of its stmts are
-observable.
-@end deftypefn
-
 @node @code{GIMPLE_EH_FILTER}
 @subsection @code{GIMPLE_EH_FILTER}
 @cindex @code{GIMPLE_EH_FILTER}
--- gcc/doc/invoke.texi	(revision 257511)
+++ gcc/doc/invoke.texi	(revision 257509)
@@ -348,7 +348,6 @@ Objective-C and Objective-C++ Dialects}.
 -gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol
 -gcolumn-info  -gno-column-info @gol
 -gstatement-frontiers  -gno-statement-frontiers @gol
--gvariable-location-views  -gno-variable-location-views @gol
 -gvms  -gxcoff  -gxcoff+  -gz@r{[}=@var{type}@r{]} @gol
 -fdebug-prefix-map=@var{old}=@var{new}  -fdebug-types-section @gol
 -fno-eliminate-unused-debug-types @gol
@@ -7256,34 +7255,6 @@ markers in the line number table.  This
 compiling with optimization (@option{-Os}, @option{-O}, @option{-O2},
 @dots{}), and outputting DWARF 2 debug information at the normal level.
 
-@item -gvariable-location-views
-@item -gvariable-location-views=incompat5
-@item -gno-variable-location-views
-@opindex gvariable-location-views
-@opindex gvariable-location-views=incompat5
-@opindex gno-variable-location-views
-Augment variable location lists with progressive view numbers implied
-from the line number table.  This enables debug information consumers to
-inspect state at certain points of the program, even if no instructions
-associated with the corresponding source locations are present at that
-point.  If the assembler lacks support for view numbers in line number
-tables, this will cause the compiler to emit the line number table,
-which generally makes them somewhat less compact.  The augmented line
-number tables and location lists are fully backward-compatible, so they
-can be consumed by debug information consumers that are not aware of
-these augmentations, but they won't derive any benefit from them either.
-This is enabled by default when outputting DWARF 2 debug information at
-the normal level, as long as @option{-fvar-tracking-assignments} is
-enabled and @option{-gstrict-dwarf} is not.
-
-There is a proposed representation for view numbers that is not backward
-compatible with the location list format introduced in DWARF 5, that can
-be enabled with @option{-gvariable-location-views=incompat5}.  This
-option may be removed in the future, is only provided as a reference
-implementation of the proposed representation.  Debug information
-consumers are not expected to support this extended format, and they
-would be rendered unable to decode location lists using it.
-
 @item -gz@r{[}=@var{type}@r{]}
 @opindex gz
 Produce compressed debug sections in DWARF format, if that is supported.
--- gcc/doc/rtl.texi	(revision 257511)
+++ gcc/doc/rtl.texi	(revision 257509)
@@ -3670,10 +3670,7 @@ Refers to a parameter that was completel
 @item (debug_marker:@var{mode})
 Marks a program location.  With @code{VOIDmode}, it stands for the
 beginning of a statement, a recommended inspection point logically after
-all prior side effects, and before any subsequent side effects.  With
-@code{BLKmode}, it indicates an inline entry point: the lexical block
-encoded in the @code{INSN_LOCATION} is the enclosing block that encloses
-the inlined function.
+all prior side effects, and before any subsequent side effects.
 
 @end table
 
@@ -3957,13 +3954,6 @@ This note is used to generate @code{is_s
 debuggign information.  It indicates the beginning of a user
 statement.
 
-@findex NOTE_INSN_INLINE_ENTRY
-@item NOTE_INSN_INLINE_ENTRY
-This note is used to generate @code{entry_pc} for inlined subroutines in
-debugging information.  It indicates an inspection point at which all
-arguments for the inlined function have been bound, and before its first
-statement.
-
 @end table
 
 These codes are printed symbolically when they appear in debugging dumps.
@@ -3981,12 +3971,8 @@ binds a user variable tree to an RTL rep
 it stands for the value bound to the corresponding
 @code{DEBUG_EXPR_DECL}.
 
-@code{GIMPLE_DEBUG_BEGIN_STMT} and @code{GIMPLE_DEBUG_INLINE_ENTRY} are
-expanded to RTL as a @code{DEBUG_INSN} with a @code{DEBUG_MARKER}
-@code{PATTERN}; the difference is the RTL mode: the former's
-@code{DEBUG_MARKER} is @code{VOIDmode}, whereas the latter is
-@code{BLKmode}; information about the inlined function can be taken from
-the lexical block encoded in the @code{INSN_LOCATION}.  These
+@code{GIMPLE_DEBUG_BEGIN_STMT} is expanded to RTL as a @code{DEBUG_INSN}
+with a @code{VOIDmode} @code{DEBUG_MARKER} @code{PATTERN}.  These
 @code{DEBUG_INSN}s, that do not carry @code{VAR_LOCATION} information,
 just @code{DEBUG_MARKER}s, can be detected by testing
 @code{DEBUG_MARKER_INSN_P}, whereas those that do can be recognized as
@@ -3997,8 +3983,8 @@ with respect to each other, particularly
 information is kept in pseudo-instruction form, so that, unlike notes,
 it gets the same treatment and adjustments that regular instructions
 would.  It is the variable tracking pass that turns these
-pseudo-instructions into @code{NOTE_INSN_VAR_LOCATION},
-@code{NOTE_INSN_BEGIN_STMT} and @code{NOTE_INSN_INLINE_ENTRY} notes,
+pseudo-instructions into @code{NOTE_INSN_VAR_LOCATION} and
+@code{NOTE_INSN_BEGIN_STMT} notes,
 analyzing control flow, value equivalences and changes to registers and
 memory referenced in value expressions, propagating the values of debug
 temporaries and determining expressions that can be used to compute the
--- gcc/dwarf2asm.c	(revision 257511)
+++ gcc/dwarf2asm.c	(revision 257509)
@@ -767,35 +767,6 @@ dw2_asm_output_data_sleb128 (HOST_WIDE_I
   va_end (ap);
 }
 
-/* Output symbol LAB1 as an unsigned LEB128 quantity.  LAB1 should be
-   an assembler-computed constant, e.g. a view number, because we
-   can't have relocations in LEB128 quantities.  */
-
-void
-dw2_asm_output_symname_uleb128 (const char *lab1 ATTRIBUTE_UNUSED,
-				const char *comment, ...)
-{
-  va_list ap;
-
-  va_start (ap, comment);
-
-#ifdef HAVE_AS_LEB128
-  fputs ("\t.uleb128 ", asm_out_file);
-  assemble_name (asm_out_file, lab1);
-#else
-  gcc_unreachable ();
-#endif
-
-  if (flag_debug_asm && comment)
-    {
-      fprintf (asm_out_file, "\t%s ", ASM_COMMENT_START);
-      vfprintf (asm_out_file, comment, ap);
-    }
-  fputc ('\n', asm_out_file);
-
-  va_end (ap);
-}
-
 void
 dw2_asm_output_delta_uleb128 (const char *lab1 ATTRIBUTE_UNUSED,
 			      const char *lab2 ATTRIBUTE_UNUSED,
--- gcc/dwarf2asm.h	(revision 257511)
+++ gcc/dwarf2asm.h	(revision 257509)
@@ -70,10 +70,6 @@ extern void dw2_asm_output_data_sleb128
 					 const char *, ...)
      ATTRIBUTE_NULL_PRINTF_2;
 
-extern void dw2_asm_output_symname_uleb128 (const char *,
-					    const char *, ...)
-     ATTRIBUTE_NULL_PRINTF_2;
-
 extern void dw2_asm_output_delta_uleb128 (const char *, const char *,
 					  const char *, ...)
      ATTRIBUTE_NULL_PRINTF_3;
--- gcc/configure	(revision 257511)
+++ gcc/configure	(revision 257509)
@@ -27825,52 +27825,6 @@ $as_echo "$gcc_cv_as_dwarf2_file_buggy"
 
 $as_echo "#define HAVE_AS_DWARF2_DEBUG_LINE 1" >>confdefs.h
 
-
-    if test $gcc_cv_as_leb128 = yes; then
-	conftest_s="\
-	.file 1 \"conftest.s\"
-	.loc 1 3 0 view .LVU1
-	$insn
-	.data
-	.uleb128 .LVU1
-	.uleb128 .LVU1
-"
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for dwarf2 debug_view support" >&5
-$as_echo_n "checking assembler for dwarf2 debug_view support... " >&6; }
-if test "${gcc_cv_as_dwarf2_debug_view+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  gcc_cv_as_dwarf2_debug_view=no
-    if test $in_tree_gas = yes; then
-    if test $in_tree_gas_is_elf = yes \
-  && test $gcc_cv_gas_vers -ge `expr \( \( 2 \* 1000 \) + 27 \) \* 1000 + 0`
-  then gcc_cv_as_dwarf2_debug_view=yes
-fi
-  elif test x$gcc_cv_as != x; then
-    $as_echo "$conftest_s" > conftest.s
-    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
-  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }
-    then
-	gcc_cv_as_dwarf2_debug_view=yes
-    else
-      echo "configure: failed program was" >&5
-      cat conftest.s >&5
-    fi
-    rm -f conftest.o conftest.s
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_dwarf2_debug_view" >&5
-$as_echo "$gcc_cv_as_dwarf2_debug_view" >&6; }
-if test $gcc_cv_as_dwarf2_debug_view = yes; then
-
-$as_echo "#define HAVE_AS_DWARF2_DEBUG_VIEW 1" >>confdefs.h
-
-fi
-    fi
  fi
 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for --gdwarf2 option" >&5
--- gcc/final.c	(revision 257511)
+++ gcc/final.c	(revision 257509)
@@ -110,7 +110,6 @@ along with GCC; see the file COPYING3.
 /* Bitflags used by final_scan_insn.  */
 #define SEEN_NOTE	1
 #define SEEN_EMITTED	2
-#define SEEN_NEXT_VIEW	4
 
 /* Last insn processed by final_scan_insn.  */
 static rtx_insn *debug_insn;
@@ -1611,7 +1610,6 @@ reemit_insn_block_notes (void)
 	    break;
 
 	  case NOTE_INSN_BEGIN_STMT:
-	  case NOTE_INSN_INLINE_ENTRY:
 	    this_block = LOCATION_BLOCK (NOTE_MARKER_LOCATION (insn));
 	    goto set_cur_block_to_this_block;
 
@@ -1694,67 +1692,6 @@ get_some_local_dynamic_name ()
   return 0;
 }
 
-/* Arrange for us to emit a source location note before any further
-   real insns or section changes, by setting the SEEN_NEXT_VIEW bit in
-   *SEEN, as long as we are keeping track of location views.  The bit
-   indicates we have referenced the next view at the current PC, so we
-   have to emit it.  This should be called next to the var_location
-   debug hook.  */
-
-static inline void
-set_next_view_needed (int *seen)
-{
-  if (debug_variable_location_views)
-    *seen |= SEEN_NEXT_VIEW;
-}
-
-/* Clear the flag in *SEEN indicating we need to emit the next view.
-   This should be called next to the source_line debug hook.  */
-
-static inline void
-clear_next_view_needed (int *seen)
-{
-  *seen &= ~SEEN_NEXT_VIEW;
-}
-
-/* Test whether we have a pending request to emit the next view in
-   *SEEN, and emit it if needed, clearing the request bit.  */
-
-static inline void
-maybe_output_next_view (int *seen)
-{
-  if ((*seen & SEEN_NEXT_VIEW) != 0)
-    {
-      clear_next_view_needed (seen);
-      (*debug_hooks->source_line) (last_linenum, last_columnnum,
-				   last_filename, last_discriminator,
-				   false);
-    }
-}
-
-/* We want to emit param bindings (before the first begin_stmt) in the
-   initial view, if we are emitting views.  To that end, we may
-   consume initial notes in the function, processing them in
-   final_start_function, before signaling the beginning of the
-   prologue, rather than in final.
-
-   We don't test whether the DECLs are PARM_DECLs: the assumption is
-   that there will be a NOTE_INSN_BEGIN_STMT marker before any
-   non-parameter NOTE_INSN_VAR_LOCATION.  It's ok if the marker is not
-   there, we'll just have more variable locations bound in the initial
-   view, which is consistent with their being bound without any code
-   that would give them a value.  */
-
-static inline bool
-in_initial_view_p (rtx_insn *insn)
-{
-  return (!DECL_IGNORED_P (current_function_decl)
-	  && debug_variable_location_views
-	  && insn && GET_CODE (insn) == NOTE
-	  && (NOTE_KIND (insn) == NOTE_INSN_VAR_LOCATION
-	      || NOTE_KIND (insn) == NOTE_INSN_DELETED));
-}
-
 /* Output assembler code for the start of a function,
    and initialize some of the variables in this file
    for the new function.  The label for the function and associated
@@ -1762,15 +1699,12 @@ in_initial_view_p (rtx_insn *insn)
 
    FIRST is the first insn of the rtl for the function being compiled.
    FILE is the file to write assembler code to.
-   SEEN should be initially set to zero, and it may be updated to
-   indicate we have references to the next location view, that would
-   require us to emit it at the current PC.
    OPTIMIZE_P is nonzero if we should eliminate redundant
      test and compare insns.  */
 
-static void
-final_start_function_1 (rtx_insn **firstp, FILE *file, int *seen,
-			int optimize_p ATTRIBUTE_UNUSED)
+void
+final_start_function (rtx_insn *first, FILE *file,
+		      int optimize_p ATTRIBUTE_UNUSED)
 {
   block_depth = 0;
 
@@ -1788,21 +1722,8 @@ final_start_function_1 (rtx_insn **first
   if (flag_sanitize & SANITIZE_ADDRESS)
     asan_function_start ();
 
-  rtx_insn *first = *firstp;
-  if (in_initial_view_p (first))
-    {
-      do
-	{
-	  final_scan_insn (first, file, 0, 0, seen);
-	  first = NEXT_INSN (first);
-	}
-      while (in_initial_view_p (first));
-      *firstp = first;
-    }
-
   if (!DECL_IGNORED_P (current_function_decl))
-    debug_hooks->begin_prologue (last_linenum, last_columnnum,
-				 last_filename);
+    debug_hooks->begin_prologue (last_linenum, last_columnnum, last_filename);
 
   if (!dwarf2_debug_info_emitted_p (current_function_decl))
     dwarf2out_begin_prologue (0, 0, NULL);
@@ -1878,17 +1799,6 @@ final_start_function_1 (rtx_insn **first
     profile_after_prologue (file);
 }
 
-/* This is an exported final_start_function_1, callable without SEEN.  */
-
-void
-final_start_function (rtx_insn *first, FILE *file,
-		      int optimize_p ATTRIBUTE_UNUSED)
-{
-  int seen = 0;
-  final_start_function_1 (&first, file, &seen, optimize_p);
-  gcc_assert (seen == 0);
-}
-
 static void
 profile_after_prologue (FILE *file ATTRIBUTE_UNUSED)
 {
@@ -2018,10 +1928,11 @@ dump_basic_block_info (FILE *file, rtx_i
 /* Output assembler code for some insns: all or part of a function.
    For description of args, see `final_start_function', above.  */
 
-static void
-final_1 (rtx_insn *first, FILE *file, int seen, int optimize_p)
+void
+final (rtx_insn *first, FILE *file, int optimize_p)
 {
   rtx_insn *insn, *next;
+  int seen = 0;
 
   /* Used for -dA dump.  */
   basic_block *start_to_bb = NULL;
@@ -2088,8 +1999,6 @@ final_1 (rtx_insn *first, FILE *file, in
       insn = final_scan_insn (insn, file, optimize_p, 0, &seen);
     }
 
-  maybe_output_next_view (&seen);
-
   if (flag_debug_asm)
     {
       free (start_to_bb);
@@ -2106,23 +2015,6 @@ final_1 (rtx_insn *first, FILE *file, in
 	delete_insn (insn);
     }
 }
-
-/* This is an exported final_1, callable without SEEN.  */
-
-void
-final (rtx_insn *first, FILE *file, int optimize_p)
-{
-  /* Those that use the internal final_start_function_1/final_1 API
-     skip initial debug bind notes in final_start_function_1, and pass
-     the modified FIRST to final_1.  But those that use the public
-     final_start_function/final APIs, final_start_function can't move
-     FIRST because it's not passed by reference, so if they were
-     skipped there, skip them again here.  */
-  while (in_initial_view_p (first))
-    first = NEXT_INSN (first);
-
-  final_1 (first, file, 0, optimize_p);
-}
 
 const char *
 get_insn_template (int code, rtx insn)
@@ -2263,8 +2155,6 @@ final_scan_insn (rtx_insn *insn, FILE *f
 	  break;
 
 	case NOTE_INSN_SWITCH_TEXT_SECTIONS:
-	  maybe_output_next_view (seen);
-
 	  in_cold_section_p = !in_cold_section_p;
 
 	  if (in_cold_section_p)
@@ -2411,8 +2301,6 @@ final_scan_insn (rtx_insn *insn, FILE *f
 	  break;
 
 	case NOTE_INSN_BLOCK_END:
-	  maybe_output_next_view (seen);
-
 	  if (debug_info_level == DINFO_LEVEL_NORMAL
 	      || debug_info_level == DINFO_LEVEL_VERBOSE
 	      || write_symbols == DWARF2_DEBUG
@@ -2469,10 +2357,7 @@ final_scan_insn (rtx_insn *insn, FILE *f
 	case NOTE_INSN_VAR_LOCATION:
 	case NOTE_INSN_CALL_ARG_LOCATION:
 	  if (!DECL_IGNORED_P (current_function_decl))
-	    {
-	      debug_hooks->var_location (insn);
-	      set_next_view_needed (seen);
-	    }
+	    debug_hooks->var_location (insn);
 	  break;
 
 	case NOTE_INSN_BEGIN_STMT:
@@ -2480,23 +2365,9 @@ final_scan_insn (rtx_insn *insn, FILE *f
 	  if (!DECL_IGNORED_P (current_function_decl)
 	      && notice_source_line (insn, NULL))
 	    {
-	    output_source_line:
 	      (*debug_hooks->source_line) (last_linenum, last_columnnum,
 					   last_filename, last_discriminator,
 					   true);
-	      clear_next_view_needed (seen);
-	    }
-	  break;
-
-	case NOTE_INSN_INLINE_ENTRY:
-	  gcc_checking_assert (cfun->debug_nonbind_markers);
-	  if (!DECL_IGNORED_P (current_function_decl))
-	    {
-	      if (!notice_source_line (insn, NULL))
-		break;
-	      (*debug_hooks->inline_entry) (LOCATION_BLOCK
-					    (NOTE_MARKER_LOCATION (insn)));
-	      goto output_source_line;
 	    }
 	  break;
 
@@ -2692,10 +2563,6 @@ final_scan_insn (rtx_insn *insn, FILE *f
 
 	    switch_to_section (current_function_section ());
 
-	    if (debug_variable_location_views
-		&& !DECL_IGNORED_P (current_function_decl))
-	      debug_hooks->var_location (insn);
-
 	    break;
 	  }
 	/* Output this line note if it is the first or the last line
@@ -2708,12 +2575,7 @@ final_scan_insn (rtx_insn *insn, FILE *f
 	    (*debug_hooks->source_line) (last_linenum, last_columnnum,
 					 last_filename, last_discriminator,
 					 is_stmt);
-	    clear_next_view_needed (seen);
 	  }
-	else
-	  maybe_output_next_view (seen);
-
-	gcc_checking_assert (!DEBUG_INSN_P (insn));
 
 	if (GET_CODE (body) == PARALLEL
 	    && GET_CODE (XVECEXP (body, 0, 0)) == ASM_INPUT)
@@ -3180,8 +3042,7 @@ final_scan_insn (rtx_insn *insn, FILE *f
 	/* Let the debug info back-end know about this call.  We do this only
 	   after the instruction has been emitted because labels that may be
 	   created to reference the call instruction must appear after it.  */
-	if ((debug_variable_location_views || call_insn != NULL)
-	    && !DECL_IGNORED_P (current_function_decl))
+	if (call_insn != NULL && !DECL_IGNORED_P (current_function_decl))
 	  debug_hooks->var_location (insn);
 
 	current_output_insn = debug_insn = 0;
@@ -3203,17 +3064,6 @@ notice_source_line (rtx_insn *insn, bool
   if (NOTE_MARKER_P (insn))
     {
       location_t loc = NOTE_MARKER_LOCATION (insn);
-      /* The inline entry markers (gimple, insn, note) carry the
-	 location of the call, because that's what we want to carry
-	 during compilation, but the location we want to output in
-	 debug information for the inline entry point is the location
-	 of the function itself.  */
-      if (NOTE_KIND (insn) == NOTE_INSN_INLINE_ENTRY)
-	{
-	  tree block = LOCATION_BLOCK (loc);
-	  tree fn = block_ultimate_origin (block);
-	  loc = DECL_SOURCE_LOCATION (fn);
-	}
       expanded_location xloc = expand_location (loc);
       if (xloc.line == 0)
 	{
@@ -4631,10 +4481,8 @@ rest_of_handle_final (void)
     delete_vta_debug_insns (false);
 
   assemble_start_function (current_function_decl, fnname);
-  rtx_insn *first = get_insns ();
-  int seen = 0;
-  final_start_function_1 (&first, asm_out_file, &seen, optimize);
-  final_1 (first, asm_out_file, seen, optimize);
+  final_start_function (get_insns (), asm_out_file, optimize);
+  final (get_insns (), asm_out_file, optimize);
   if (flag_ipa_ra
       && !lookup_attribute ("noipa", DECL_ATTRIBUTES (current_function_decl)))
     collect_fn_hard_reg_usage ();
@@ -4820,7 +4668,6 @@ rest_of_clean_state (void)
 	  && (!NOTE_P (insn) ||
 	      (NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION
 	       && NOTE_KIND (insn) != NOTE_INSN_BEGIN_STMT
-	       && NOTE_KIND (insn) != NOTE_INSN_INLINE_ENTRY
 	       && NOTE_KIND (insn) != NOTE_INSN_CALL_ARG_LOCATION
 	       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_BEG
 	       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END
--- gcc/insn-notes.def	(revision 257511)
+++ gcc/insn-notes.def	(revision 257509)
@@ -71,10 +71,6 @@ INSN_NOTE (CALL_ARG_LOCATION)
 /* The beginning of a statement.  */
 INSN_NOTE (BEGIN_STMT)
 
-/* The entry point for an inlined function.  Its NOTE_BLOCK references
-   the lexical block whose abstract origin is the inlined function.  */
-INSN_NOTE (INLINE_ENTRY)
-
 /* Record the struct for the following basic block.  Uses
    NOTE_BASIC_BLOCK.  FIXME: Redundant with the basic block pointer
    now included in every insn.  NOTE: If there's no CFG anymore, in other words,
--- gcc/toplev.c	(revision 257511)
+++ gcc/toplev.c	(revision 257509)
@@ -1558,22 +1558,6 @@ process_options (void)
 	     || write_symbols == VMS_AND_DWARF2_DEBUG)
 	 && !(flag_selective_scheduling || flag_selective_scheduling2));
 
-  if (debug_variable_location_views == AUTODETECT_VALUE)
-    {
-      debug_variable_location_views = flag_var_tracking
-	&& debug_info_level >= DINFO_LEVEL_NORMAL
-	&& (write_symbols == DWARF2_DEBUG
-	    || write_symbols == VMS_AND_DWARF2_DEBUG)
-	&& !dwarf_strict;
-    }
-  else if (debug_variable_location_views == -1 && dwarf_version != 5)
-    {
-      warning_at (UNKNOWN_LOCATION, 0,
-		  "without -gdwarf-5, -gvariable-location-views=incompat5 "
-		  "is equivalent to -gvariable-location-views");
-      debug_variable_location_views = 1;
-    }
-
   if (flag_tree_cselim == AUTODETECT_VALUE)
     {
       if (HAVE_conditional_move)
--- gcc/config.in	(revision 257511)
+++ gcc/config.in	(revision 257509)
@@ -358,12 +358,6 @@
 #endif
 
 
-/* Define if your assembler supports views in dwarf2 .loc directives. */
-#ifndef USED_FOR_TARGET
-#undef HAVE_AS_DWARF2_DEBUG_VIEW
-#endif
-
-
 /* Define if your assembler supports the R_PPC64_ENTRY relocation. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_ENTRY_MARKERS
--- gcc/dwarf2out.c	(revision 257511)
+++ gcc/dwarf2out.c	(revision 257509)
@@ -1291,8 +1291,6 @@ struct GTY((for_user)) addr_table_entry
   GTY ((desc ("%1.kind"))) addr;
 };
 
-typedef unsigned int var_loc_view;
-
 /* Location lists are ranges + location descriptions for that range,
    so you can track variables that are in different places over
    their entire life.  */
@@ -1302,11 +1300,9 @@ typedef struct GTY(()) dw_loc_list_struc
   addr_table_entry *begin_entry;
   const char *end;  /* Label for end of range */
   char *ll_symbol; /* Label for beginning of location list.
-		      Only on head of list.  */
-  char *vl_symbol; /* Label for beginning of view list.  Ditto.  */
+		      Only on head of list */
   const char *section; /* Section this loclist is relative to */
   dw_loc_descr_ref expr;
-  var_loc_view vbegin, vend;
   hashval_t hash;
   /* True if all addresses in this and subsequent lists are known to be
      resolved.  */
@@ -1343,29 +1339,6 @@ dwarf_stack_op_name (unsigned int op)
   return "OP_<unknown>";
 }
 
-/* Return TRUE iff we're to output location view lists as a separate
-   attribute next to the location lists, as an extension compatible
-   with DWARF 2 and above.  */
-
-static inline bool
-dwarf2out_locviews_in_attribute ()
-{
-  return debug_variable_location_views == 1;
-}
-
-/* Return TRUE iff we're to output location view lists as part of the
-   location lists, as proposed for standardization after DWARF 5.  */
-
-static inline bool
-dwarf2out_locviews_in_loclist ()
-{
-#ifndef DW_LLE_view_pair
-  return false;
-#else
-  return debug_variable_location_views == -1;
-#endif
-}
-
 /* Return a pointer to a newly allocated location description.  Location
    descriptions are simple expression terms that can be strung
    together to form more complicated location (address) descriptions.  */
@@ -1428,8 +1401,6 @@ dw_val_equal_p (dw_val_node *a, dw_val_n
       return a->v.val_loc == b->v.val_loc;
     case dw_val_class_loc_list:
       return a->v.val_loc_list == b->v.val_loc_list;
-    case dw_val_class_view_list:
-      return a->v.val_view_list == b->v.val_view_list;
     case dw_val_class_die_ref:
       return a->v.val_die_ref.die == b->v.val_die_ref.die;
     case dw_val_class_fde_ref:
@@ -2747,7 +2718,6 @@ static void dwarf2out_imported_module_or
 						 dw_die_ref);
 static void dwarf2out_abstract_function (tree);
 static void dwarf2out_var_location (rtx_insn *);
-static void dwarf2out_inline_entry (tree);
 static void dwarf2out_size_function (tree);
 static void dwarf2out_begin_function (tree);
 static void dwarf2out_end_function (unsigned int);
@@ -2801,7 +2771,7 @@ const struct gcc_debug_hooks dwarf2_debu
   debug_nothing_rtx_code_label,	/* label */
   debug_nothing_int,		/* handle_pch */
   dwarf2out_var_location,
-  dwarf2out_inline_entry,	/* inline_entry */
+  debug_nothing_tree,		/* inline_entry */
   dwarf2out_size_function,	/* size_function */
   dwarf2out_switch_text_section,
   dwarf2out_set_name,
@@ -2905,15 +2875,7 @@ enum dw_line_info_opcode {
   LI_set_epilogue_begin,
 
   /* Emit a DW_LNE_set_discriminator.  */
-  LI_set_discriminator,
-
-  /* Output a Fixed Advance PC; the target PC is the label index; the
-     base PC is the previous LI_adv_address or LI_set_address entry.
-     We only use this when emitting debug views without assembler
-     support, at explicit user request.  Ideally, we should only use
-     it when the offset might be zero but we can't tell: it's the only
-     way to maybe change the PC without resetting the view number.  */
-  LI_adv_address
+  LI_set_discriminator
 };
 
 typedef struct GTY(()) dw_line_info_struct {
@@ -2935,25 +2897,6 @@ struct GTY(()) dw_line_info_table {
   bool is_stmt;
   bool in_use;
 
-  /* This denotes the NEXT view number.
-
-     If it is 0, it is known that the NEXT view will be the first view
-     at the given PC.
-
-     If it is -1, we've advanced PC but we haven't emitted a line location yet,
-     so we shouldn't use this view number.
-
-     The meaning of other nonzero values depends on whether we're
-     computing views internally or leaving it for the assembler to do
-     so.  If we're emitting them internally, view denotes the view
-     number since the last known advance of PC.  If we're leaving it
-     for the assembler, it denotes the LVU label number that we're
-     going to ask the assembler to assign.  */
-  var_loc_view view;
-
-#define RESET_NEXT_VIEW(x) ((x) = (var_loc_view)0)
-#define RESETTING_VIEW_P(x) ((x) == (var_loc_view)0)
-
   vec<dw_line_info_entry, va_gc> *entries;
 };
 
@@ -3155,71 +3098,6 @@ skeleton_chain_node;
 #endif
 #endif
 
-/* Use assembler views in line directives if available.  */
-#ifndef DWARF2_ASM_VIEW_DEBUG_INFO
-#ifdef HAVE_AS_DWARF2_DEBUG_VIEW
-#define DWARF2_ASM_VIEW_DEBUG_INFO 1
-#else
-#define DWARF2_ASM_VIEW_DEBUG_INFO 0
-#endif
-#endif
-
-/* A bit is set in ZERO_VIEW_P if we are using the assembler-supported
-   view computation, and it refers to a view identifier for which we
-   will not emit a label because it is known to map to a view number
-   zero.  We won't allocate the bitmap if we're not using assembler
-   support for location views, but we have to make the variable
-   visible for GGC and for code that will be optimized out for lack of
-   support but that's still parsed and compiled.  We could abstract it
-   out with macros, but it's not worth it.  */
-static GTY(()) bitmap zero_view_p;
-
-/* Evaluate to TRUE iff N is known to identify the first location view
-   at its PC.  When not using assembler location view computation,
-   that must be view number zero.  Otherwise, ZERO_VIEW_P is allocated
-   and views label numbers recorded in it are the ones known to be
-   zero.  */
-#define ZERO_VIEW_P(N) (zero_view_p				\
-			? bitmap_bit_p (zero_view_p, (N))	\
-			: (N) == 0)
-
-/* Return true iff we're to emit .loc directives for the assembler to
-   generate line number sections.
-
-   When we're not emitting views, all we need from the assembler is
-   support for .loc directives.
-
-   If we are emitting views, we can only use the assembler's .loc
-   support if it also supports views.
-
-   When the compiler is emitting the line number programs and
-   computing view numbers itself, it resets view numbers at known PC
-   changes and counts from that, and then it emits view numbers as
-   literal constants in locviewlists.  There are cases in which the
-   compiler is not sure about PC changes, e.g. when extra alignment is
-   requested for a label.  In these cases, the compiler may not reset
-   the view counter, and the potential PC advance in the line number
-   program will use an opcode that does not reset the view counter
-   even if the PC actually changes, so that compiler and debug info
-   consumer can keep view numbers in sync.
-
-   When the compiler defers view computation to the assembler, it
-   emits symbolic view numbers in locviewlists, with the exception of
-   views known to be zero (forced resets, or reset after
-   compiler-visible PC changes): instead of emitting symbols for
-   these, we emit literal zero and assert the assembler agrees with
-   the compiler's assessment.  We could use symbolic views everywhere,
-   instead of special-casing zero views, but then we'd be unable to
-   optimize out locviewlists that contain only zeros.  */
-
-static bool
-output_asm_line_debug_info (void)
-{
-  return (DWARF2_ASM_VIEW_DEBUG_INFO
-	  || (DWARF2_ASM_LINE_DEBUG_INFO
-	      && !debug_variable_location_views));
-}
-
 /* Minimum line offset in a special line info. opcode.
    This value was chosen to give a reasonable range of values.  */
 #define DWARF_LINE_BASE  -10
@@ -3329,7 +3207,6 @@ struct GTY ((chain_next ("%h.next"))) va
   rtx GTY (()) loc;
   const char * GTY (()) label;
   struct var_loc_node * GTY (()) next;
-  var_loc_view view;
 };
 
 /* Variable location list.  */
@@ -3538,8 +3415,6 @@ static inline dw_loc_descr_ref AT_loc (d
 static void add_AT_loc_list (dw_die_ref, enum dwarf_attribute,
 			     dw_loc_list_ref);
 static inline dw_loc_list_ref AT_loc_list (dw_attr_node *);
-static void add_AT_view_list (dw_die_ref, enum dwarf_attribute);
-static inline dw_loc_list_ref AT_loc_list (dw_attr_node *);
 static addr_table_entry *add_addr_table_entry (void *, enum ate_kind);
 static void remove_addr_table_entry (addr_table_entry *);
 static void add_AT_addr (dw_die_ref, enum dwarf_attribute, rtx, bool);
@@ -3576,7 +3451,7 @@ static void equate_type_number_to_die (t
 static dw_die_ref lookup_decl_die (tree);
 static var_loc_list *lookup_decl_loc (const_tree);
 static void equate_decl_number_to_die (tree, dw_die_ref);
-static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *, var_loc_view);
+static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *);
 static void print_spaces (FILE *);
 static void print_die (dw_die_ref, FILE *);
 static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);
@@ -3776,8 +3651,8 @@ static void gen_tagged_type_die (tree, d
 static void gen_type_die_with_usage (tree, dw_die_ref, enum debug_info_usage);
 static void splice_child_die (dw_die_ref, dw_die_ref);
 static int file_info_cmp (const void *, const void *);
-static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *, var_loc_view,
-				     const char *, var_loc_view, const char *);
+static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *,
+				     const char *, const char *);
 static void output_loc_list (dw_loc_list_ref);
 static char *gen_internal_sym (const char *);
 static bool want_pubnames (void);
@@ -4069,9 +3944,6 @@ static char ranges_base_label[2 * MAX_AR
 #ifndef BLOCK_BEGIN_LABEL
 #define BLOCK_BEGIN_LABEL	"LBB"
 #endif
-#ifndef BLOCK_INLINE_ENTRY_LABEL
-#define BLOCK_INLINE_ENTRY_LABEL "LBI"
-#endif
 #ifndef BLOCK_END_LABEL
 #define BLOCK_END_LABEL		"LBE"
 #endif
@@ -4776,65 +4648,11 @@ AT_loc_list (dw_attr_node *a)
   return a->dw_attr_val.v.val_loc_list;
 }
 
-/* Add a view list attribute to DIE.  It must have a DW_AT_location
-   attribute, because the view list complements the location list.  */
-
-static inline void
-add_AT_view_list (dw_die_ref die, enum dwarf_attribute attr_kind)
-{
-  dw_attr_node attr;
-
-  if (XCOFF_DEBUGGING_INFO && !HAVE_XCOFF_DWARF_EXTRAS)
-    return;
-
-  attr.dw_attr = attr_kind;
-  attr.dw_attr_val.val_class = dw_val_class_view_list;
-  attr.dw_attr_val.val_entry = NULL;
-  attr.dw_attr_val.v.val_view_list = die;
-  add_dwarf_attr (die, &attr);
-  gcc_checking_assert (get_AT (die, DW_AT_location));
-  gcc_assert (have_location_lists);
-}
-
-/* Return a pointer to the location list referenced by the attribute.
-   If the named attribute is a view list, look up the corresponding
-   DW_AT_location attribute and return its location list.  */
-
 static inline dw_loc_list_ref *
 AT_loc_list_ptr (dw_attr_node *a)
 {
-  gcc_assert (a);
-  switch (AT_class (a))
-    {
-    case dw_val_class_loc_list:
-      return &a->dw_attr_val.v.val_loc_list;
-    case dw_val_class_view_list:
-      {
-	dw_attr_node *l;
-	l = get_AT (a->dw_attr_val.v.val_view_list, DW_AT_location);
-	if (!l)
-	  return NULL;
-	gcc_checking_assert (l + 1 == a);
-	return AT_loc_list_ptr (l);
-      }
-    default:
-      gcc_unreachable ();
-    }
-}
-
-/* Return the location attribute value associated with a view list
-   attribute value.  */
-
-static inline dw_val_node *
-view_list_to_loc_list_val_node (dw_val_node *val)
-{
-  gcc_assert (val->val_class == dw_val_class_view_list);
-  dw_attr_node *loc = get_AT (val->v.val_view_list, DW_AT_location);
-  if (!loc)
-    return NULL;
-  gcc_checking_assert (&(loc + 1)->dw_attr_val == val);
-  gcc_assert (AT_class (loc) == dw_val_class_loc_list);
-  return &loc->dw_attr_val;
+  gcc_assert (a && AT_class (a) == dw_val_class_loc_list);
+  return &a->dw_attr_val.v.val_loc_list;
 }
 
 struct addr_hasher : ggc_ptr_hash<addr_table_entry>
@@ -6089,7 +5907,7 @@ adjust_piece_list (rtx *dest, rtx *src,
 /* Add a variable location node to the linked list for DECL.  */
 
 static struct var_loc_node *
-add_var_loc_to_decl (tree decl, rtx loc_note, const char *label, var_loc_view view)
+add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)
 {
   unsigned int decl_id;
   var_loc_list *temp;
@@ -6178,7 +5996,7 @@ add_var_loc_to_decl (tree decl, rtx loc_
       /* TEMP->LAST here is either pointer to the last but one or
 	 last element in the chained list, LAST is pointer to the
 	 last element.  */
-      if (label && strcmp (last->label, label) == 0 && last->view == view)
+      if (label && strcmp (last->label, label) == 0)
 	{
 	  /* For SRA optimized variables if there weren't any real
 	     insns since last note, just modify the last node.  */
@@ -6194,7 +6012,7 @@ add_var_loc_to_decl (tree decl, rtx loc_
 	      temp->last->next = NULL;
 	      unused = last;
 	      last = temp->last;
-	      gcc_assert (strcmp (last->label, label) != 0 || last->view != view);
+	      gcc_assert (strcmp (last->label, label) != 0);
 	    }
 	  else
 	    {
@@ -6329,12 +6147,6 @@ print_dw_val (dw_val_node *val, bool rec
       fprintf (outfile, "location list -> label:%s",
 	       val->v.val_loc_list->ll_symbol);
       break;
-    case dw_val_class_view_list:
-      val = view_list_to_loc_list_val_node (val);
-      fprintf (outfile, "location list with views -> labels:%s and %s",
-	       val->v.val_loc_list->ll_symbol,
-	       val->v.val_loc_list->vl_symbol);
-      break;
     case dw_val_class_range_list:
       fprintf (outfile, "range list");
       break;
@@ -9195,7 +9007,6 @@ size_of_die (dw_die_ref die)
 	  }
 	  break;
 	case dw_val_class_loc_list:
-	case dw_val_class_view_list:
 	  if (dwarf_split_debug_info && dwarf_version >= 5)
 	    {
 	      gcc_assert (AT_loc_list (a)->num_assigned);
@@ -9567,7 +9378,6 @@ value_format (dw_attr_node *a)
 	  gcc_unreachable ();
 	}
     case dw_val_class_loc_list:
-    case dw_val_class_view_list:
       if (dwarf_split_debug_info
 	  && dwarf_version >= 5
 	  && AT_loc_list (a)->num_assigned)
@@ -9842,8 +9652,7 @@ output_abbrev_section (void)
    expression.  */
 
 static inline dw_loc_list_ref
-new_loc_list (dw_loc_descr_ref expr, const char *begin, var_loc_view vbegin,
-	      const char *end, var_loc_view vend,
+new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,
 	      const char *section)
 {
   dw_loc_list_ref retlist = ggc_cleared_alloc<dw_loc_list_node> ();
@@ -9853,28 +9662,10 @@ new_loc_list (dw_loc_descr_ref expr, con
   retlist->end = end;
   retlist->expr = expr;
   retlist->section = section;
-  retlist->vbegin = vbegin;
-  retlist->vend = vend;
 
   return retlist;
 }
 
-/* Return true iff there's any nonzero view number in the loc list.  */
-
-static bool
-loc_list_has_views (dw_loc_list_ref list)
-{
-  if (!debug_variable_location_views)
-    return false;
-
-  for (dw_loc_list_ref loc = list;
-       loc != NULL; loc = loc->dw_loc_next)
-    if (!ZERO_VIEW_P (loc->vbegin) || !ZERO_VIEW_P (loc->vend))
-      return true;
-
-  return false;
-}
-
 /* Generate a new internal symbol for this location list node, if it
    hasn't got one yet.  */
 
@@ -9883,98 +9674,6 @@ gen_llsym (dw_loc_list_ref list)
 {
   gcc_assert (!list->ll_symbol);
   list->ll_symbol = gen_internal_sym ("LLST");
-
-  if (!loc_list_has_views (list))
-    return;
-
-  if (dwarf2out_locviews_in_attribute ())
-    {
-      /* Use the same label_num for the view list.  */
-      label_num--;
-      list->vl_symbol = gen_internal_sym ("LVUS");
-    }
-  else
-    list->vl_symbol = list->ll_symbol;
-}
-
-/* Generate a symbol for the list, but only if we really want to emit
-   it as a list.  */
-
-static inline void
-maybe_gen_llsym (dw_loc_list_ref list)
-{
-  if (!list || (!list->dw_loc_next && !loc_list_has_views (list)))
-    return;
-
-  gen_llsym (list);
-}
-
-/* Determine whether or not to skip loc_list entry CURR.  If we're not
-   to skip it, and SIZEP is non-null, store the size of CURR->expr's
-   representation in *SIZEP.  */
-
-static bool
-skip_loc_list_entry (dw_loc_list_ref curr, unsigned long *sizep = 0)
-{
-  /* Don't output an entry that starts and ends at the same address.  */
-  if (strcmp (curr->begin, curr->end) == 0
-      && curr->vbegin == curr->vend && !curr->force)
-    return true;
-
-  unsigned long size = size_of_locs (curr->expr);
-
-  /* If the expression is too large, drop it on the floor.  We could
-     perhaps put it into DW_TAG_dwarf_procedure and refer to that
-     in the expression, but >= 64KB expressions for a single value
-     in a single range are unlikely very useful.  */
-  if (dwarf_version < 5 && size > 0xffff)
-    return true;
-
-  if (sizep)
-    *sizep = size;
-
-  return false;
-}
-
-/* Output a view pair loclist entry for CURR, if it requires one.  */
-
-static void
-dwarf2out_maybe_output_loclist_view_pair (dw_loc_list_ref curr)
-{
-  if (!dwarf2out_locviews_in_loclist ())
-    return;
-
-  if (ZERO_VIEW_P (curr->vbegin) && ZERO_VIEW_P (curr->vend))
-    return;
-
-#ifdef DW_LLE_view_pair
-  dw2_asm_output_data (1, DW_LLE_view_pair, "DW_LLE_view_pair");
-
-# if DWARF2_ASM_VIEW_DEBUG_INFO
-  if (ZERO_VIEW_P (curr->vbegin))
-    dw2_asm_output_data_uleb128 (0, "Location view begin");
-  else
-    {
-      char label[MAX_ARTIFICIAL_LABEL_BYTES];
-      ASM_GENERATE_INTERNAL_LABEL (label, "LVU", curr->vbegin);
-      dw2_asm_output_symname_uleb128 (label, "Location view begin");
-    }
-
-  if (ZERO_VIEW_P (curr->vend))
-    dw2_asm_output_data_uleb128 (0, "Location view end");
-  else
-    {
-      char label[MAX_ARTIFICIAL_LABEL_BYTES];
-      ASM_GENERATE_INTERNAL_LABEL (label, "LVU", curr->vend);
-      dw2_asm_output_symname_uleb128 (label, "Location view end");
-    }
-# else /* !DWARF2_ASM_VIEW_DEBUG_INFO */
-  dw2_asm_output_data_uleb128 (curr->vbegin, "Location view begin");
-  dw2_asm_output_data_uleb128 (curr->vend, "Location view end");
-# endif /* DWARF2_ASM_VIEW_DEBUG_INFO */
-#endif /* DW_LLE_view_pair */
-
-  return;
 }
 
 /* Output the location list given to us.  */
@@ -9982,85 +9681,34 @@ dwarf2out_maybe_output_loclist_view_pair
 static void
 output_loc_list (dw_loc_list_ref list_head)
 {
-  int vcount = 0, lcount = 0;
-
   if (list_head->emitted)
     return;
   list_head->emitted = true;
 
-  if (list_head->vl_symbol && dwarf2out_locviews_in_attribute ())
-    {
-      ASM_OUTPUT_LABEL (asm_out_file, list_head->vl_symbol);
-
-      for (dw_loc_list_ref curr = list_head; curr != NULL;
-	   curr = curr->dw_loc_next)
-	{
-	  if (skip_loc_list_entry (curr))
-	    continue;
-
-	  vcount++;
-
-	  /* ?? dwarf_split_debug_info?  */
-#if DWARF2_ASM_VIEW_DEBUG_INFO
-	  char label[MAX_ARTIFICIAL_LABEL_BYTES];
-
-	  if (!ZERO_VIEW_P (curr->vbegin))
-	    {
-	      ASM_GENERATE_INTERNAL_LABEL (label, "LVU", curr->vbegin);
-	      dw2_asm_output_symname_uleb128 (label,
-					      "View list begin (%s)",
-					      list_head->vl_symbol);
-	    }
-	  else
-	    dw2_asm_output_data_uleb128 (0,
-					 "View list begin (%s)",
-					 list_head->vl_symbol);
-
-	  if (!ZERO_VIEW_P (curr->vend))
-	    {
-	      ASM_GENERATE_INTERNAL_LABEL (label, "LVU", curr->vend);
-	      dw2_asm_output_symname_uleb128 (label,
-					      "View list end (%s)",
-					      list_head->vl_symbol);
-	    }
-	  else
-	    dw2_asm_output_data_uleb128 (0,
-					 "View list end (%s)",
-					 list_head->vl_symbol);
-#else /* !DWARF2_ASM_VIEW_DEBUG_INFO */
-	  dw2_asm_output_data_uleb128 (curr->vbegin,
-				       "View list begin (%s)",
-				       list_head->vl_symbol);
-	  dw2_asm_output_data_uleb128 (curr->vend,
-				       "View list end (%s)",
-				       list_head->vl_symbol);
-#endif
-	}
-    }
-
   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);
 
+  dw_loc_list_ref curr = list_head;
   const char *last_section = NULL;
   const char *base_label = NULL;
 
   /* Walk the location list, and output each range + expression.  */
-  for (dw_loc_list_ref curr = list_head; curr != NULL;
-       curr = curr->dw_loc_next)
+  for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)
     {
       unsigned long size;
-
-      /* Skip this entry?  If we skip it here, we must skip it in the
-	 view list above as well. */
-      if (skip_loc_list_entry (curr, &size))
+      /* Don't output an entry that starts and ends at the same address.  */
+      if (strcmp (curr->begin, curr->end) == 0 && !curr->force)
+	continue;
+      size = size_of_locs (curr->expr);
+      /* If the expression is too large, drop it on the floor.  We could
+	 perhaps put it into DW_TAG_dwarf_procedure and refer to that
+	 in the expression, but >= 64KB expressions for a single value
+	 in a single range are unlikely very useful.  */
+      if (dwarf_version < 5 && size > 0xffff)
 	continue;
-
-      lcount++;
-
       if (dwarf_version >= 5)
 	{
 	  if (dwarf_split_debug_info)
 	    {
-	      dwarf2out_maybe_output_loclist_view_pair (curr);
 	      /* For -gsplit-dwarf, emit DW_LLE_starx_length, which has
 		 uleb128 index into .debug_addr and uleb128 length.  */
 	      dw2_asm_output_data (1, DW_LLE_startx_length,
@@ -10078,7 +9726,6 @@ output_loc_list (dw_loc_list_ref list_he
 	    }
 	  else if (!have_multiple_function_sections && HAVE_AS_LEB128)
 	    {
-	      dwarf2out_maybe_output_loclist_view_pair (curr);
 	      /* If all code is in .text section, the base address is
 		 already provided by the CU attributes.  Use
 		 DW_LLE_offset_pair where both addresses are uleb128 encoded
@@ -10129,7 +9776,6 @@ output_loc_list (dw_loc_list_ref list_he
 		 length.  */
 	      if (last_section == NULL)
 		{
-		  dwarf2out_maybe_output_loclist_view_pair (curr);
 		  dw2_asm_output_data (1, DW_LLE_start_length,
 				       "DW_LLE_start_length (%s)",
 				       list_head->ll_symbol);
@@ -10144,7 +9790,6 @@ output_loc_list (dw_loc_list_ref list_he
 		 DW_LLE_base_address.  */
 	      else
 		{
-		  dwarf2out_maybe_output_loclist_view_pair (curr);
 		  dw2_asm_output_data (1, DW_LLE_offset_pair,
 				       "DW_LLE_offset_pair (%s)",
 				       list_head->ll_symbol);
@@ -10160,7 +9805,6 @@ output_loc_list (dw_loc_list_ref list_he
 	     DW_LLE_start_end with a pair of absolute addresses.  */
 	  else
 	    {
-	      dwarf2out_maybe_output_loclist_view_pair (curr);
 	      dw2_asm_output_data (1, DW_LLE_start_end,
 				   "DW_LLE_start_end (%s)",
 				   list_head->ll_symbol);
@@ -10239,9 +9883,6 @@ output_loc_list (dw_loc_list_ref list_he
 			   "Location list terminator end (%s)",
 			   list_head->ll_symbol);
     }
-
-  gcc_assert (!list_head->vl_symbol
-	      || vcount == lcount * (dwarf2out_locviews_in_attribute () ? 1 : 0));
 }
 
 /* Output a range_list offset into the .debug_ranges or .debug_rnglists
@@ -10306,22 +9947,6 @@ output_loc_list_offset (dw_attr_node *a)
 			  "%s", dwarf_attr_name (a->dw_attr));
 }
 
-/* Output the offset into the debug_loc section.  */
-
-static void
-output_view_list_offset (dw_attr_node *a)
-{
-  char *sym = (*AT_loc_list_ptr (a))->vl_symbol;
-
-  gcc_assert (sym);
-  if (dwarf_split_debug_info)
-    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,
-                          "%s", dwarf_attr_name (a->dw_attr));
-  else
-    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,
-                           "%s", dwarf_attr_name (a->dw_attr));
-}
-
 /* Output an attribute's index or value appropriately.  */
 
 static void
@@ -10547,10 +10172,6 @@ output_die (dw_die_ref die)
 	  output_loc_list_offset (a);
 	  break;
 
-	case dw_val_class_view_list:
-	  output_view_list_offset (a);
-	  break;
-
 	case dw_val_class_die_ref:
 	  if (AT_ref_external (a))
 	    {
@@ -10735,28 +10356,6 @@ output_die (dw_die_ref die)
 			 (unsigned long) die->die_offset);
 }
 
-/* Output the dwarf version number.  */
-
-static void
-output_dwarf_version ()
-{
-  /* ??? For now, if -gdwarf-6 is specified, we output version 5 with
-     views in loclist.  That will change eventually.  */
-  if (dwarf_version == 6)
-    {
-      static bool once;
-      if (!once)
-	{
-	  warning (0,
-		   "-gdwarf-6 is output as version 5 with incompatibilities");
-	  once = true;
-	}
-      dw2_asm_output_data (2, 5, "DWARF version number");
-    }
-  else
-    dw2_asm_output_data (2, dwarf_version, "DWARF version number");
-}
-
 /* Output the compilation unit that appears at the beginning of the
    .debug_info section, and precedes the DIE descriptions.  */
 
@@ -10773,7 +10372,7 @@ output_compilation_unit_header (enum dwa
 			   "Length of Compilation Unit Info");
     }
 
-  output_dwarf_version ();
+  dw2_asm_output_data (2, dwarf_version, "DWARF version number");
   if (dwarf_version >= 5)
     {
       const char *name;
@@ -10985,7 +10584,7 @@ output_skeleton_debug_sections (dw_die_r
                        - DWARF_INITIAL_LENGTH_SIZE
                        + size_of_die (comp_unit),
                       "Length of Compilation Unit Info");
-  output_dwarf_version ();
+  dw2_asm_output_data (2, dwarf_version, "DWARF version number");
   if (dwarf_version >= 5)
     {
       dw2_asm_output_data (1, DW_UT_skeleton, "DW_UT_skeleton");
@@ -11284,7 +10883,7 @@ output_pubnames (vec<pubname_entry, va_g
     }
 
   /* Version number for pubnames/pubtypes is independent of dwarf version.  */
-  dw2_asm_output_data (2, 2, "DWARF pubnames/pubtypes version");
+  dw2_asm_output_data (2, 2, "DWARF Version");
 
   if (dwarf_split_debug_info)
     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,
@@ -11366,7 +10965,7 @@ output_aranges (void)
     }
 
   /* Version number for aranges is still 2, even up to DWARF5.  */
-  dw2_asm_output_data (2, 2, "DWARF aranges version");
+  dw2_asm_output_data (2, 2, "DWARF Version");
   if (dwarf_split_debug_info)
     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,
                            debug_skeleton_info_section,
@@ -11631,7 +11230,7 @@ output_rnglists (unsigned generation)
   dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,
 			"Length of Range Lists");
   ASM_OUTPUT_LABEL (asm_out_file, l1);
-  output_dwarf_version ();
+  dw2_asm_output_data (2, dwarf_version, "DWARF Version");
   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, "Address Size");
   dw2_asm_output_data (1, 0, "Segment Size");
   /* Emit the offset table only for -gsplit-dwarf.  If we don't care
@@ -12265,11 +11864,8 @@ output_one_line_info_table (dw_line_info
   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];
   unsigned int current_line = 1;
   bool current_is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;
-  dw_line_info_entry *ent, *prev_addr;
+  dw_line_info_entry *ent;
   size_t i;
-  unsigned int view;
-
-  view = 0;
 
   FOR_EACH_VEC_SAFE_ELT (table->entries, i, ent)
     {
@@ -12284,36 +11880,14 @@ output_one_line_info_table (dw_line_info
 	     to determine when it is safe to use DW_LNS_fixed_advance_pc.  */
 	  ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent->val);
 
-	  view = 0;
-
 	  /* This can handle any delta.  This takes
 	     4+DWARF2_ADDR_SIZE bytes.  */
-	  dw2_asm_output_data (1, 0, "set address %s%s", line_label,
-			       debug_variable_location_views
-			       ? ", reset view to 0" : "");
+	  dw2_asm_output_data (1, 0, "set address %s", line_label);
 	  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);
 	  dw2_asm_output_data (1, DW_LNE_set_address, NULL);
 	  dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);
-
-	  prev_addr = ent;
 	  break;
 
-	case LI_adv_address:
-	  {
-	    ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent->val);
-	    char prev_label[MAX_ARTIFICIAL_LABEL_BYTES];
-	    ASM_GENERATE_INTERNAL_LABEL (prev_label, LINE_CODE_LABEL, prev_addr->val);
-
-	    view++;
-
-	    dw2_asm_output_data (1, DW_LNS_fixed_advance_pc, "fixed advance PC, increment view to %i", view);
-	    dw2_asm_output_delta (2, line_label, prev_label,
-				  "from %s to %s", prev_label, line_label);
-
-	    prev_addr = ent;
-	    break;
-	  }
-
 	case LI_set_line:
 	  if (ent->val == current_line)
 	    {
@@ -12421,7 +11995,7 @@ output_line_info (bool prologue_only)
 
   ASM_OUTPUT_LABEL (asm_out_file, l1);
 
-  output_dwarf_version ();
+  dw2_asm_output_data (2, dwarf_version, "DWARF Version");
   if (dwarf_version >= 5)
     {
       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, "Address Size");
@@ -16879,7 +16453,6 @@ static dw_loc_list_ref
 dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)
 {
   const char *endname, *secname;
-  var_loc_view endview;
   rtx varloc;
   enum var_init_status initialized;
   struct var_loc_node *node;
@@ -16944,27 +16517,24 @@ dw_loc_list (var_loc_list *loc_list, tre
 		  && current_function_decl)
 		{
 		  endname = cfun->fde->dw_fde_end;
-		  endview = 0;
 		  range_across_switch = true;
 		}
 	      /* The variable has a location between NODE->LABEL and
 		 NODE->NEXT->LABEL.  */
 	      else if (node->next)
-		endname = node->next->label, endview = node->next->view;
+		endname = node->next->label;
 	      /* If the variable has a location at the last label
 		 it keeps its location until the end of function.  */
 	      else if (!current_function_decl)
-		endname = text_end_label, endview = 0;
+		endname = text_end_label;
 	      else
 		{
 		  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,
 					       current_function_funcdef_no);
 		  endname = ggc_strdup (label_id);
-		  endview = 0;
 		}
 
-	      *listp = new_loc_list (descr, node->label, node->view,
-				     endname, endview, secname);
+	      *listp = new_loc_list (descr, node->label, endname, secname);
 	      if (TREE_CODE (decl) == PARM_DECL
 		  && node == loc_list->first
 		  && NOTE_P (node->loc)
@@ -16999,11 +16569,11 @@ dw_loc_list (var_loc_list *loc_list, tre
 	  /* The variable has a location between NODE->LABEL and
 	     NODE->NEXT->LABEL.  */
 	  if (node->next)
-	    endname = node->next->label, endview = node->next->view;
+	    endname = node->next->label;
 	  else
-	    endname = cfun->fde->dw_fde_second_end, endview = 0;
-	  *listp = new_loc_list (descr, cfun->fde->dw_fde_second_begin, 0,
-				 endname, endview, secname);
+	    endname = cfun->fde->dw_fde_second_end;
+	  *listp = new_loc_list (descr, cfun->fde->dw_fde_second_begin,
+				 endname, secname);
 	  listp = &(*listp)->dw_loc_next;
 	}
     }
@@ -17014,7 +16584,8 @@ dw_loc_list (var_loc_list *loc_list, tre
      representable, we don't want to pretend a single entry that was
      applies to the entire scope in which the variable is
      available.  */
-  maybe_gen_llsym (list);
+  if (list && loc_list->first->next)
+    gen_llsym (list);
 
   return list;
 }
@@ -17833,7 +17404,7 @@ loc_list_from_tree_1 (tree loc, int want
     {
       if (dwarf_version >= 3 || !dwarf_strict)
 	return new_loc_list (new_loc_descr (DW_OP_push_object_address, 0, 0),
-			     NULL, 0, NULL, 0, NULL);
+			     NULL, NULL, NULL);
       else
 	return NULL;
     }
@@ -18649,7 +18220,7 @@ loc_list_from_tree_1 (tree loc, int want
 	add_loc_descr_to_each (list_ret, new_loc_descr (op, size, 0));
     }
   if (ret)
-    list_ret = new_loc_list (ret, NULL, 0, NULL, 0, NULL);
+    list_ret = new_loc_list (ret, NULL, NULL, NULL);
 
   return list_ret;
 }
@@ -18973,25 +18544,12 @@ static inline void
 add_AT_location_description (dw_die_ref die, enum dwarf_attribute attr_kind,
 			     dw_loc_list_ref descr)
 {
-  bool check_no_locviews = true;
   if (descr == 0)
     return;
   if (single_element_loc_list_p (descr))
     add_AT_loc (die, attr_kind, descr->expr);
   else
-    {
-      add_AT_loc_list (die, attr_kind, descr);
-      gcc_assert (descr->ll_symbol);
-      if (attr_kind == DW_AT_location && descr->vl_symbol
-	  && dwarf2out_locviews_in_attribute ())
-	{
-	  add_AT_view_list (die, DW_AT_GNU_locviews);
-	  check_no_locviews = false;
-	}
-    }
-
-  if (check_no_locviews)
-    gcc_assert (!get_AT (die, DW_AT_GNU_locviews));
+    add_AT_loc_list (die, attr_kind, descr);
 }
 
 /* Add DW_AT_accessibility attribute to DIE if needed.  */
@@ -20180,7 +19738,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_IN
       /* If the first partition contained no CFI adjustments, the
 	 CIE opcodes apply to the whole first partition.  */
       *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),
-				 fde->dw_fde_begin, 0, fde->dw_fde_end, 0, section);
+				 fde->dw_fde_begin, fde->dw_fde_end, section);
       list_tail =&(*list_tail)->dw_loc_next;
       start_label = last_label = fde->dw_fde_second_begin;
     }
@@ -20196,7 +19754,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_IN
 	  if (!cfa_equal_p (&last_cfa, &next_cfa))
 	    {
 	      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),
-					 start_label, 0, last_label, 0, section);
+					 start_label, last_label, section);
 
 	      list_tail = &(*list_tail)->dw_loc_next;
 	      last_cfa = next_cfa;
@@ -20218,14 +19776,14 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_IN
 	  if (!cfa_equal_p (&last_cfa, &next_cfa))
 	    {
 	      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),
-					 start_label, 0, last_label, 0, section);
+					 start_label, last_label, section);
 
 	      list_tail = &(*list_tail)->dw_loc_next;
 	      last_cfa = next_cfa;
 	      start_label = last_label;
 	    }
 	  *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),
-				     start_label, 0, fde->dw_fde_end, 0, section);
+				     start_label, fde->dw_fde_end, section);
 	  list_tail = &(*list_tail)->dw_loc_next;
 	  start_label = last_label = fde->dw_fde_second_begin;
 	}
@@ -20234,18 +19792,19 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_IN
   if (!cfa_equal_p (&last_cfa, &next_cfa))
     {
       *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),
-				 start_label, 0, last_label, 0, section);
+				 start_label, last_label, section);
       list_tail = &(*list_tail)->dw_loc_next;
       start_label = last_label;
     }
 
   *list_tail = new_loc_list (build_cfa_loc (&next_cfa, offset),
-			     start_label, 0,
+			     start_label,
 			     fde->dw_fde_second_begin
-			     ? fde->dw_fde_second_end : fde->dw_fde_end, 0,
+			     ? fde->dw_fde_second_end : fde->dw_fde_end,
 			     section);
 
-  maybe_gen_llsym (list);
+  if (list && list->dw_loc_next)
+    gen_llsym (list);
 
   return list;
 }
@@ -23219,48 +22778,6 @@ block_die_hasher::equal (die_struct *x,
   return x->decl_id == y->decl_id && x->die_parent == y->die_parent;
 }
 
-/* Hold information about markers for inlined entry points.  */
-struct GTY ((for_user)) inline_entry_data
-{
-  /* The block that's the inlined_function_outer_scope for an inlined
-     function.  */
-  tree block;
-
-  /* The label at the inlined entry point.  */
-  const char *label_pfx;
-  unsigned int label_num;
-
-  /* The view number to be used as the inlined entry point.  */
-  var_loc_view view;
-};
-
-struct inline_entry_data_hasher : ggc_ptr_hash <inline_entry_data>
-{
-  typedef tree compare_type;
-  static inline hashval_t hash (const inline_entry_data *);
-  static inline bool equal (const inline_entry_data *, const_tree);
-};
-
-/* Hash table routines for inline_entry_data.  */
-
-inline hashval_t
-inline_entry_data_hasher::hash (const inline_entry_data *data)
-{
-  return htab_hash_pointer (data->block);
-}
-
-inline bool
-inline_entry_data_hasher::equal (const inline_entry_data *data,
-				 const_tree block)
-{
-  return data->block == block;
-}
-
-/* Inlined entry points pending DIE creation in this compilation unit.  */
-
-static GTY(()) hash_table<inline_entry_data_hasher> *inline_entry_data_table;
-
-
 /* Return TRUE if DECL, which may have been previously generated as
    OLD_DIE, is a candidate for a DW_AT_specification.  DECLARATION is
    true if decl (or its origin) is either an extern declaration or a
@@ -23713,42 +23230,6 @@ add_high_low_attributes (tree stmt, dw_d
 {
   char label[MAX_ARTIFICIAL_LABEL_BYTES];
 
-  if (inline_entry_data **iedp
-      = !inline_entry_data_table ? NULL
-      : inline_entry_data_table->find_slot_with_hash (stmt,
-						      htab_hash_pointer (stmt),
-						      NO_INSERT))
-    {
-      inline_entry_data *ied = *iedp;
-      gcc_assert (MAY_HAVE_DEBUG_MARKER_INSNS);
-      gcc_assert (inlined_function_outer_scope_p (stmt));
-      ASM_GENERATE_INTERNAL_LABEL (label, ied->label_pfx, ied->label_num);
-      add_AT_lbl_id (die, DW_AT_entry_pc, label);
-
-      if (debug_variable_location_views && !ZERO_VIEW_P (ied->view))
-	{
-	  if (!output_asm_line_debug_info ())
-	    add_AT_unsigned (die, DW_AT_GNU_entry_view, ied->view);
-	  else
-	    {
-	      ASM_GENERATE_INTERNAL_LABEL (label, "LVU", ied->view);
-	      /* FIXME: this will resolve to a small number.  Could we
-		 possibly emit smaller data?  Ideally we'd emit a
-		 uleb128, but that would make the size of DIEs
-		 impossible for the compiler to compute, since it's
-		 the assembler that computes the value of the view
-		 label in this case.  Ideally, we'd have a single form
-		 encompassing both the address and the view, and
-		 indirecting them through a table might make things
-		 easier, but even that would be more wasteful,
-		 space-wise, than what we have now.  */
-	      add_AT_lbl_id (die, DW_AT_GNU_entry_view, label);
-	    }
-	}
-
-      inline_entry_data_table->clear_slot (iedp);
-    }
-
   if (BLOCK_FRAGMENT_CHAIN (stmt)
       && (dwarf_version >= 3 || !dwarf_strict))
     {
@@ -23756,7 +23237,7 @@ add_high_low_attributes (tree stmt, dw_d
       dw_die_ref pdie;
       dw_attr_node *attr = NULL;
 
-      if (!MAY_HAVE_DEBUG_MARKER_INSNS && inlined_function_outer_scope_p (stmt))
+      if (inlined_function_outer_scope_p (stmt))
 	{
 	  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,
 				       BLOCK_NUMBER (stmt));
@@ -23921,7 +23402,7 @@ gen_inlined_subroutine_die (tree stmt, d
       dw_die_ref subr_die
 	= new_die (DW_TAG_inlined_subroutine, context_die, stmt);
 
-      if (call_arg_locations || MAY_HAVE_DEBUG_MARKER_INSNS)
+      if (call_arg_locations)
 	BLOCK_DIE (stmt) = subr_die;
       add_abstract_origin_attribute (subr_die, decl);
       if (TREE_ASM_WRITTEN (stmt))
@@ -26683,7 +26164,7 @@ maybe_emit_file (struct dwarf_file_data
 	fd->emitted_number = 1;
       last_emitted_file = fd;
 
-      if (output_asm_line_debug_info ())
+      if (DWARF2_ASM_LINE_DEBUG_INFO)
 	{
 	  fprintf (asm_out_file, "\t.file %u ", fd->emitted_number);
 	  output_quoted_string (asm_out_file,
@@ -26877,13 +26358,11 @@ dwarf2out_var_location (rtx_insn *loc_no
   static rtx_insn *expected_next_loc_note;
   tree decl;
   bool var_loc_p;
-  var_loc_view view = 0;
 
   if (!NOTE_P (loc_note))
     {
       if (CALL_P (loc_note))
 	{
-	  RESET_NEXT_VIEW (cur_line_info_table->view);
 	  call_site_count++;
 	  if (SIBLING_CALL_P (loc_note))
 	    tail_call_site_count++;
@@ -26917,18 +26396,6 @@ dwarf2out_var_location (rtx_insn *loc_no
 		}
 	    }
 	}
-      else if (!debug_variable_location_views)
-	gcc_unreachable ();
-      else if (JUMP_TABLE_DATA_P (loc_note))
-	RESET_NEXT_VIEW (cur_line_info_table->view);
-      else if (GET_CODE (loc_note) == USE
-	       || GET_CODE (loc_note) == CLOBBER
-	       || GET_CODE (loc_note) == ASM_INPUT
-	       || asm_noperands (loc_note) >= 0)
-	;
-      else if (get_attr_min_length (loc_note) > 0)
-	RESET_NEXT_VIEW (cur_line_info_table->view);
-
       return;
     }
 
@@ -26953,7 +26420,6 @@ dwarf2out_var_location (rtx_insn *loc_no
       || ! NOTE_P (next_note)
       || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION
 	  && NOTE_KIND (next_note) != NOTE_INSN_BEGIN_STMT
-	  && NOTE_KIND (next_note) != NOTE_INSN_INLINE_ENTRY
 	  && NOTE_KIND (next_note) != NOTE_INSN_CALL_ARG_LOCATION))
     next_note = NULL;
 
@@ -26993,11 +26459,10 @@ create_label:
 
   if (var_loc_p)
     {
-      const char *label
-	= NOTE_DURING_CALL_P (loc_note) ? last_postcall_label : last_label;
-      view = cur_line_info_table->view;
       decl = NOTE_VAR_LOCATION_DECL (loc_note);
-      newloc = add_var_loc_to_decl (decl, loc_note, label, view);
+      newloc = add_var_loc_to_decl (decl, loc_note,
+				    NOTE_DURING_CALL_P (loc_note)
+				    ? last_postcall_label : last_label);
       if (newloc == NULL)
 	return;
     }
@@ -27038,8 +26503,8 @@ create_label:
 		else if (GET_CODE (body) == ASM_INPUT
 			 || asm_noperands (body) >= 0)
 		  continue;
-#ifdef HAVE_ATTR_length /* ??? We don't include insn-attr.h.  */
-		else if (HAVE_ATTR_length && get_attr_min_length (insn) == 0)
+#ifdef HAVE_attr_length
+		else if (get_attr_min_length (insn) == 0)
 		  continue;
 #endif
 		else
@@ -27107,10 +26572,7 @@ create_label:
       call_arg_loc_last = ca_loc;
     }
   else if (loc_note != NULL_RTX && !NOTE_DURING_CALL_P (loc_note))
-    {
-      newloc->label = last_label;
-      newloc->view = view;
-    }
+    newloc->label = last_label;
   else
     {
       if (!last_postcall_label)
@@ -27119,7 +26581,6 @@ create_label:
 	  last_postcall_label = ggc_strdup (loclabel);
 	}
       newloc->label = last_postcall_label;
-      newloc->view = view;
     }
 
   if (var_loc_p && flag_debug_asm)
@@ -27147,113 +26608,6 @@ create_label:
   last_in_cold_section_p = in_cold_section_p;
 }
 
-/* Check whether BLOCK, a lexical block, is nested within OUTER, or is
-   OUTER itself.  If BOTHWAYS, check not only that BLOCK can reach
-   OUTER through BLOCK_SUPERCONTEXT links, but also that there is a
-   path from OUTER to BLOCK through BLOCK_SUBBLOCKs and
-   BLOCK_FRAGMENT_ORIGIN links.  */
-static bool
-block_within_block_p (tree block, tree outer, bool bothways)
-{
-  if (block == outer)
-    return true;
-
-  /* Quickly check that OUTER is up BLOCK's supercontext chain.  */
-  for (tree context = BLOCK_SUPERCONTEXT (block);
-       context != outer;
-       context = BLOCK_SUPERCONTEXT (context))
-    if (!context || TREE_CODE (context) != BLOCK)
-      return false;
-
-  if (!bothways)
-    return true;
-
-  /* Now check that each block is actually referenced by its
-     parent.  */
-  for (tree context = BLOCK_SUPERCONTEXT (block); ;
-       context = BLOCK_SUPERCONTEXT (context))
-    {
-      if (BLOCK_FRAGMENT_ORIGIN (context))
-	{
-	  gcc_assert (!BLOCK_SUBBLOCKS (context));
-	  context = BLOCK_FRAGMENT_ORIGIN (context);
-	}
-      for (tree sub = BLOCK_SUBBLOCKS (context);
-	   sub != block;
-	   sub = BLOCK_CHAIN (sub))
-	if (!sub)
-	  return false;
-      if (context == outer)
-	return true;
-      else
-	block = context;
-    }
-}
-
-/* Called during final while assembling the marker of the entry point
-   for an inlined function.  */
-
-static void
-dwarf2out_inline_entry (tree block)
-{
-  /* If we can't represent it, don't bother.  */
-  if (!(dwarf_version >= 3 || !dwarf_strict))
-    return;
-
-  gcc_assert (DECL_P (block_ultimate_origin (block)));
-
-  /* Sanity check the block tree.  This would catch a case in which
-     BLOCK got removed from the tree reachable from the outermost
-     lexical block, but got retained in markers.  It would still link
-     back to its parents, but some ancestor would be missing a link
-     down the path to the sub BLOCK.  If the block got removed, its
-     BLOCK_NUMBER will not be a usable value.  */
-  if (flag_checking)
-    gcc_assert (block_within_block_p (block,
-				      DECL_INITIAL (current_function_decl),
-				      true));
-
-  gcc_assert (inlined_function_outer_scope_p (block));
-  gcc_assert (!BLOCK_DIE (block));
-
-  if (BLOCK_FRAGMENT_ORIGIN (block))
-    block = BLOCK_FRAGMENT_ORIGIN (block);
-  /* Can the entry point ever not be at the beginning of an
-     unfragmented lexical block?  */
-  else if (!(BLOCK_FRAGMENT_CHAIN (block)
-	     || (cur_line_info_table
-		 && !ZERO_VIEW_P (cur_line_info_table->view))))
-    return;
-
-  if (!inline_entry_data_table)
-    inline_entry_data_table
-      = hash_table<inline_entry_data_hasher>::create_ggc (10);
-
-
-  inline_entry_data **iedp
-    = inline_entry_data_table->find_slot_with_hash (block,
-						    htab_hash_pointer (block),
-						    INSERT);
-  if (*iedp)
-    /* ??? Ideally, we'd record all entry points for the same inlined
-       function (some may have been duplicated by e.g. unrolling), but
-       we have no way to represent that ATM.  */
-    return;
-
-  inline_entry_data *ied = *iedp = ggc_cleared_alloc<inline_entry_data> ();
-  ied->block = block;
-  ied->label_pfx = BLOCK_INLINE_ENTRY_LABEL;
-  ied->label_num = BLOCK_NUMBER (block);
-  if (cur_line_info_table)
-    ied->view = cur_line_info_table->view;
-
-  char label[MAX_ARTIFICIAL_LABEL_BYTES];
-
-  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_INLINE_ENTRY_LABEL,
-			       BLOCK_NUMBER (block));
-  ASM_OUTPUT_LABEL (asm_out_file, label);
-}
-
 /* Called from finalize_size_functions for size functions so that their body
    can be encoded in the debug info to describe the layout of variable-length
    structures.  */
@@ -27298,7 +26652,6 @@ new_line_info_table (void)
   table->file_num = 1;
   table->line_num = 1;
   table->is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;
-  RESET_NEXT_VIEW (table->view);
 
   return table;
 }
@@ -27347,7 +26700,7 @@ set_cur_line_info_table (section *sec)
       vec_safe_push (separate_line_info, table);
     }
 
-  if (output_asm_line_debug_info ())
+  if (DWARF2_ASM_LINE_DEBUG_INFO)
     table->is_stmt = (cur_line_info_table
 		      ? cur_line_info_table->is_stmt
 		      : DWARF_LINE_DEFAULT_IS_STMT_START);
@@ -27528,7 +26881,7 @@ dwarf2out_source_line (unsigned int line
 		 filename, line);
     }
 
-  if (output_asm_line_debug_info ())
+  if (DWARF2_ASM_LINE_DEBUG_INFO)
     {
       /* Emit the .loc directive understood by GNU as.  */
       /* "\t.loc %u %u 0 is_stmt %u discriminator %u",
@@ -27551,50 +26904,6 @@ dwarf2out_source_line (unsigned int line
 	  fputs (" discriminator ", asm_out_file);
 	  fprint_ul (asm_out_file, (unsigned long) discriminator);
 	}
-      if (debug_variable_location_views)
-	{
-	  static var_loc_view lvugid;
-	  if (!lvugid)
-	    {
-	      gcc_assert (!zero_view_p);
-	      zero_view_p = BITMAP_GGC_ALLOC ();
-	      bitmap_set_bit (zero_view_p, 0);
-	    }
-	  if (!RESETTING_VIEW_P (table->view))
-	    {
-	      /* When we're using the assembler to compute view
-		 numbers, we output symbolic labels after "view" in
-		 .loc directives, and the assembler will set them for
-		 us, so that we can refer to the view numbers in
-		 location lists.  The only exceptions are when we know
-		 a view will be zero: "-0" is a forced reset, used
-		 e.g. in the beginning of functions, whereas "0" tells
-		 the assembler to check that there was a PC change
-		 since the previous view, in a way that implicitly
-		 resets the next view.  */
-	      fputs (" view ", asm_out_file);
-	      char label[MAX_ARTIFICIAL_LABEL_BYTES];
-	      ASM_GENERATE_INTERNAL_LABEL (label, "LVU", table->view);
-	      assemble_name (asm_out_file, label);
-	      table->view = ++lvugid;
-	    }
-	  else
-	    {
-	      if (!table->in_use)
-		fputs (" view -0", asm_out_file);
-	      else
-		fputs (" view 0", asm_out_file);
-	      /* Mark the present view as a zero view.  Earlier debug
-		 binds may have already added its id to loclists to be
-		 emitted later, so we can't reuse the id for something
-		 else.  However, it's good to know whether a view is
-		 known to be zero, because then we may be able to
-		 optimize out locviews that are all zeros, so take
-		 note of it in zero_view_p.  */
-	      bitmap_set_bit (zero_view_p, lvugid);
-	      table->view = ++lvugid;
-	    }
-	}
       putc ('\n', asm_out_file);
     }
   else
@@ -27603,19 +26912,7 @@ dwarf2out_source_line (unsigned int line
 
       targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL, label_num);
 
-      if (debug_variable_location_views && table->view)
-	push_dw_line_info_entry (table, LI_adv_address, label_num);
-      else
-	push_dw_line_info_entry (table, LI_set_address, label_num);
-      if (debug_variable_location_views)
-	{
-	  if (flag_debug_asm)
-	    fprintf (asm_out_file, "\t%s view %s%d\n",
-		     ASM_COMMENT_START,
-		     table->in_use ? "" : "-",
-		     table->view);
-	  table->view++;
-	}
+      push_dw_line_info_entry (table, LI_set_address, label_num);
       if (file_num != table->file_num)
 	push_dw_line_info_entry (table, LI_set_file, file_num);
       if (discriminator != table->discrim_num)
@@ -28291,10 +27588,9 @@ init_sections_and_labels (bool early_lto
 					    SECTION_DEBUG, NULL);
       debug_str_section = get_section (DEBUG_STR_SECTION,
 				       DEBUG_STR_SECTION_FLAGS, NULL);
-      if (!dwarf_split_debug_info && !output_asm_line_debug_info ())
+      if (!dwarf_split_debug_info && !DWARF2_ASM_LINE_DEBUG_INFO)
 	debug_line_str_section = get_section (DEBUG_LINE_STR_SECTION,
 					      DEBUG_STR_SECTION_FLAGS, NULL);
-
       debug_ranges_section = get_section (dwarf_version >= 5
 					  ? DEBUG_RNGLISTS_SECTION
 					  : DEBUG_RANGES_SECTION,
@@ -28680,11 +27976,6 @@ prune_unused_types_walk_attribs (dw_die_
 	    prune_unused_types_walk_loc_descr (list->expr);
 	  break;
 
-	case dw_val_class_view_list:
-	  /* This points to a loc_list in another attribute, so it's
-	     already covered.  */
-	  break;
-
 	case dw_val_class_die_ref:
 	  /* A reference to another DIE.
 	     Make sure that it will get emitted.
@@ -29784,8 +29075,6 @@ optimize_string_length (dw_attr_node *a)
 	if (d->expr && non_dwarf_expression (d->expr))
 	  non_dwarf_expr = true;
       break;
-    case dw_val_class_view_list:
-      gcc_unreachable ();
     case dw_val_class_loc:
       lv = AT_loc (av);
       if (lv == NULL)
@@ -29830,7 +29119,7 @@ optimize_string_length (dw_attr_node *a)
 	  lv = copy_deref_exprloc (d->expr);
 	  if (lv)
 	    {
-	      *p = new_loc_list (lv, d->begin, d->vbegin, d->end, d->vend, d->section);
+	      *p = new_loc_list (lv, d->begin, d->end, d->section);
 	      p = &(*p)->dw_loc_next;
 	    }
 	  else if (!dwarf_strict && d->expr)
@@ -29900,7 +29189,6 @@ resolve_addr (dw_die_ref die)
 		      {
 			gcc_assert (!next->ll_symbol);
 			next->ll_symbol = (*curr)->ll_symbol;
-			next->vl_symbol = (*curr)->vl_symbol;
 		      }
                     if (dwarf_split_debug_info)
                       remove_loc_list_addr_table_entries (l);
@@ -29926,21 +29214,6 @@ resolve_addr (dw_die_ref die)
 	    ix--;
 	  }
 	break;
-      case dw_val_class_view_list:
-	{
-	  gcc_checking_assert (a->dw_attr == DW_AT_GNU_locviews);
-	  gcc_checking_assert (dwarf2out_locviews_in_attribute ());
-	  dw_val_node *llnode
-	    = view_list_to_loc_list_val_node (&a->dw_attr_val);
-	  /* If we no longer have a loclist, or it no longer needs
-	     views, drop this attribute.  */
-	  if (!llnode || !llnode->v.val_loc_list->vl_symbol)
-	    {
-	      remove_AT (die, a->dw_attr);
-	      ix--;
-	    }
-	  break;
-	}
       case dw_val_class_loc:
 	{
 	  dw_loc_descr_ref l = AT_loc (a);
@@ -30337,8 +29610,6 @@ hash_loc_list (dw_loc_list_ref list_head
     {
       hstate.add (curr->begin, strlen (curr->begin) + 1);
       hstate.add (curr->end, strlen (curr->end) + 1);
-      hstate.add_object (curr->vbegin);
-      hstate.add_object (curr->vend);
       if (curr->section)
 	hstate.add (curr->section, strlen (curr->section) + 1);
       hash_locs (curr->expr, hstate);
@@ -30560,7 +29831,6 @@ loc_list_hasher::equal (const dw_loc_lis
 	|| strcmp (a->end, b->end) != 0
 	|| (a->section == NULL) != (b->section == NULL)
 	|| (a->section && strcmp (a->section, b->section) != 0)
-	|| a->vbegin != b->vbegin || a->vend != b->vend
 	|| !compare_locs (a->expr, b->expr))
       break;
   return a == NULL && b == NULL;
@@ -30579,8 +29849,6 @@ optimize_location_lists_1 (dw_die_ref di
   dw_attr_node *a;
   unsigned ix;
   dw_loc_list_struct **slot;
-  bool drop_locviews = false;
-  bool has_locviews = false;
 
   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)
     if (AT_class (a) == dw_val_class_loc_list)
@@ -30591,33 +29859,11 @@ optimize_location_lists_1 (dw_die_ref di
 	hash_loc_list (list);
 	slot = htab->find_slot_with_hash (list, list->hash, INSERT);
 	if (*slot == NULL)
-	  {
-	    *slot = list;
-	    if (loc_list_has_views (list))
-	      gcc_assert (list->vl_symbol);
-	    else if (list->vl_symbol)
-	      {
-		drop_locviews = true;
-		list->vl_symbol = NULL;
-	      }
-	  }
+	  *slot = list;
 	else
-	  {
-	    if (list->vl_symbol && !(*slot)->vl_symbol)
-	      drop_locviews = true;
-	    a->dw_attr_val.v.val_loc_list = *slot;
-	  }
-      }
-    else if (AT_class (a) == dw_val_class_view_list)
-      {
-	gcc_checking_assert (a->dw_attr == DW_AT_GNU_locviews);
-	has_locviews = true;
+          a->dw_attr_val.v.val_loc_list = *slot;
       }
 
-
-  if (drop_locviews && has_locviews)
-    remove_AT (die, DW_AT_GNU_locviews);
-
   FOR_EACH_CHILD (die, c, optimize_location_lists_1 (c, htab));
 }
 
@@ -30642,7 +29888,7 @@ index_location_lists (dw_die_ref die)
             /* Don't index an entry that has already been indexed
                or won't be output.  */
             if (curr->begin_entry != NULL
-                || skip_loc_list_entry (curr))
+                || (strcmp (curr->begin, curr->end) == 0 && !curr->force))
               continue;
 
             curr->begin_entry
@@ -30750,9 +29996,6 @@ dwarf2out_finish (const char *)
   /* Flush out any latecomers to the limbo party.  */
   flush_limbo_die_list ();
 
-  if (inline_entry_data_table)
-    gcc_assert (inline_entry_data_table->elements () == 0);
-
   if (flag_checking)
     {
       verify_die (comp_unit_die ());
@@ -31069,7 +30312,7 @@ dwarf2out_finish (const char *)
 	  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,
 			    "Length of Location Lists");
 	  ASM_OUTPUT_LABEL (asm_out_file, l1);
-	  output_dwarf_version ();
+	  dw2_asm_output_data (2, dwarf_version, "DWARF Version");
 	  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, "Address Size");
 	  dw2_asm_output_data (1, 0, "Segment Size");
 	  dw2_asm_output_data (4, dwarf_split_debug_info ? loc_list_idx : 0,
@@ -31128,7 +30371,7 @@ dwarf2out_finish (const char *)
      used by the debug_info section are marked as 'used'.  */
   switch_to_section (debug_line_section);
   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);
-  if (! output_asm_line_debug_info ())
+  if (! DWARF2_ASM_LINE_DEBUG_INFO)
     output_line_info (false);
 
   if (dwarf_split_debug_info && info_section_emitted)
--- gcc/dwarf2out.h	(revision 257511)
+++ gcc/dwarf2out.h	(revision 257509)
@@ -160,8 +160,7 @@ enum dw_val_class
   dw_val_class_discr_list,
   dw_val_class_const_implicit,
   dw_val_class_unsigned_const_implicit,
-  dw_val_class_file_implicit,
-  dw_val_class_view_list
+  dw_val_class_file_implicit
 };
 
 /* Describe a floating point constant value, or a vector constant value.  */
@@ -204,7 +203,6 @@ struct GTY(()) dw_val_node {
       rtx GTY ((tag ("dw_val_class_addr"))) val_addr;
       unsigned HOST_WIDE_INT GTY ((tag ("dw_val_class_offset"))) val_offset;
       dw_loc_list_ref GTY ((tag ("dw_val_class_loc_list"))) val_loc_list;
-      dw_die_ref GTY ((tag ("dw_val_class_view_list"))) val_view_list;
       dw_loc_descr_ref GTY ((tag ("dw_val_class_loc"))) val_loc;
       HOST_WIDE_INT GTY ((default)) val_int;
       unsigned HOST_WIDE_INT
--- gcc/gimple-pretty-print.c	(revision 257511)
+++ gcc/gimple-pretty-print.c	(revision 257509)
@@ -1371,19 +1371,6 @@ dump_gimple_debug (pretty_printer *buffe
 	dump_gimple_fmt (buffer, spc, flags, "# DEBUG BEGIN_STMT");
       break;
 
-    case GIMPLE_DEBUG_INLINE_ENTRY:
-      if (flags & TDF_RAW)
-	dump_gimple_fmt (buffer, spc, flags, "%G INLINE_ENTRY %T", gs,
-			 gimple_block (gs)
-			 ? block_ultimate_origin (gimple_block (gs))
-			 : NULL_TREE);
-      else
-	dump_gimple_fmt (buffer, spc, flags, "# DEBUG INLINE_ENTRY %T",
-			 gimple_block (gs)
-			 ? block_ultimate_origin (gimple_block (gs))
-			 : NULL_TREE);
-      break;
-
     default:
       gcc_unreachable ();
     }
--- gcc/configure.ac	(revision 257511)
+++ gcc/configure.ac	(revision 257509)
@@ -4902,25 +4902,9 @@ if test x"$insn" != x; then
 
  if test $gcc_cv_as_dwarf2_debug_line = yes \
  && test $gcc_cv_as_dwarf2_file_buggy = no; then
-    AC_DEFINE(HAVE_AS_DWARF2_DEBUG_LINE, 1,
+	AC_DEFINE(HAVE_AS_DWARF2_DEBUG_LINE, 1,
   [Define if your assembler supports dwarf2 .file/.loc directives,
    and preserves file table indices exactly as given.])
-
-    if test $gcc_cv_as_leb128 = yes; then
-	conftest_s="\
-	.file 1 \"conftest.s\"
-	.loc 1 3 0 view .LVU1
-	$insn
-	.data
-	.uleb128 .LVU1
-	.uleb128 .LVU1
-"
-	gcc_GAS_CHECK_FEATURE([dwarf2 debug_view support],
-	  gcc_cv_as_dwarf2_debug_view,
-	  [elf,2,27,0],,[$conftest_s],,
-	  [AC_DEFINE(HAVE_AS_DWARF2_DEBUG_VIEW, 1,
-  [Define if your assembler supports views in dwarf2 .loc directives.])])
-    fi
  fi
 
  gcc_GAS_CHECK_FEATURE([--gdwarf2 option],
--- gcc/print-rtl.c	(revision 257511)
+++ gcc/print-rtl.c	(revision 257509)
@@ -276,7 +276,6 @@ rtx_writer::print_rtx_operand_code_0 (co
 	  break;
 
 	case NOTE_INSN_BEGIN_STMT:
-	case NOTE_INSN_INLINE_ENTRY:
 #ifndef GENERATOR_FILE
 	  {
 	    expanded_location xloc
@@ -1880,10 +1879,6 @@ print_insn (pretty_printer *pp, const rt
 		pp_string (pp, "debug begin stmt marker");
 		break;
 
-	      case NOTE_INSN_INLINE_ENTRY:
-		pp_string (pp, "debug inline entry marker");
-		break;
-
 	      default:
 		gcc_unreachable ();
 	      }
--- gcc/cfgexpand.c	(revision 257511)
+++ gcc/cfgexpand.c	(revision 257509)
@@ -5731,15 +5731,6 @@ expand_gimple_basic_block (basic_block b
 		goto delink_debug_stmt;
 	      else if (gimple_debug_begin_stmt_p (stmt))
 		val = GEN_RTX_DEBUG_MARKER_BEGIN_STMT_PAT ();
-	      else if (gimple_debug_inline_entry_p (stmt))
-		{
-		  tree block = gimple_block (stmt);
-
-		  if (block)
-		    val = GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT ();
-		  else
-		    goto delink_debug_stmt;
-		}
 	      else
 		gcc_unreachable ();
 
--- gcc/tree-ssa-live.c	(revision 257511)
+++ gcc/tree-ssa-live.c	(revision 257509)
@@ -520,11 +520,6 @@ remove_unused_scope_block_p (tree scope,
    else if (!BLOCK_SUPERCONTEXT (scope)
             || TREE_CODE (BLOCK_SUPERCONTEXT (scope)) == FUNCTION_DECL)
      unused = false;
-   /* Preserve the block, it is referenced by at least the inline
-      entry point marker.  */
-   else if (debug_nonbind_markers_p
-	    && inlined_function_outer_scope_p (scope))
-     unused = false;
    /* Innermost blocks with no live variables nor statements can be always
       eliminated.  */
    else if (!nsubblocks)
@@ -553,13 +548,11 @@ remove_unused_scope_block_p (tree scope,
      }
    else if (BLOCK_VARS (scope) || BLOCK_NUM_NONLOCALIZED_VARS (scope))
      unused = false;
-   /* See if this block is important for representation of inlined
-      function.  Inlined functions are always represented by block
-      with block_ultimate_origin being set to FUNCTION_DECL and
-      DECL_SOURCE_LOCATION set, unless they expand to nothing...  But
-      see above for the case of statement frontiers.  */
-   else if (!debug_nonbind_markers_p
-	    && inlined_function_outer_scope_p (scope))
+   /* See if this block is important for representation of inlined function.
+      Inlined functions are always represented by block with
+      block_ultimate_origin being set to FUNCTION_DECL and DECL_SOURCE_LOCATION
+      set...  */
+   else if (inlined_function_outer_scope_p (scope))
      unused = false;
    else
    /* Verfify that only blocks with source location set
@@ -647,16 +640,6 @@ dump_scope_block (FILE *file, int indent
 	    fprintf (file, "#%i", BLOCK_NUMBER (origin));
 	}
     }
-  if (BLOCK_FRAGMENT_ORIGIN (scope))
-    fprintf (file, " Fragment of : #%i",
-	     BLOCK_NUMBER (BLOCK_FRAGMENT_ORIGIN (scope)));
-  else if (BLOCK_FRAGMENT_CHAIN (scope))
-    {
-      fprintf (file, " Fragment chain :");
-      for (t = BLOCK_FRAGMENT_CHAIN (scope); t ;
-	   t = BLOCK_FRAGMENT_CHAIN (t))
-	fprintf (file, " #%i", BLOCK_NUMBER (t));
-    }
   fprintf (file, " \n");
   for (var = BLOCK_VARS (scope); var; var = DECL_CHAIN (var))
     {
--- gcc/common.opt	(revision 257511)
+++ gcc/common.opt	(revision 257509)
@@ -2956,13 +2956,6 @@ gtoggle
 Common Driver Report Var(flag_gtoggle)
 Toggle debug information generation.
 
-gvariable-location-views
-Common Driver Var(debug_variable_location_views, 1) Init(2)
-Augment variable location lists with progressive views.
-
-gvariable-location-views=incompat5
-Common Driver RejectNegative Var(debug_variable_location_views, -1) Init(2)
-
 gvms
 Common Driver JoinedOrMissing Negative(gxcoff)
 Generate debug information in VMS format.
--- gcc/rtl.h	(revision 257511)
+++ gcc/rtl.h	(revision 257509)
@@ -1654,8 +1654,7 @@ extern const char * const reg_note_name[
    for which NOTE_MARKER_LOCATION can be used.  */
 #define NOTE_MARKER_P(INSN)				\
   (NOTE_P (INSN) &&					\
-   (NOTE_KIND (INSN) == NOTE_INSN_BEGIN_STMT		\
-    || NOTE_KIND (INSN) == NOTE_INSN_INLINE_ENTRY))
+   (NOTE_KIND (INSN) == NOTE_INSN_BEGIN_STMT))
 
 /* Variable declaration and the location of a variable.  */
 #define PAT_VAR_LOCATION_DECL(PAT) (XCTREE ((PAT), 0, VAR_LOCATION))
@@ -1693,8 +1692,6 @@ extern const char * const reg_note_name[
   (GET_CODE (PATTERN (INSN)) == DEBUG_MARKER	  \
    ? (GET_MODE (PATTERN (INSN)) == VOIDmode	  \
       ? NOTE_INSN_BEGIN_STMT			  \
-      : GET_MODE (PATTERN (INSN)) == BLKmode	  \
-      ? NOTE_INSN_INLINE_ENTRY			  \
       : (enum insn_note)-1) 			  \
    : (enum insn_note)-1)
 /* Create patterns for debug markers.  These and the above abstract
@@ -1704,8 +1701,6 @@ extern const char * const reg_note_name[
    wouldn't be a problem.  */
 #define GEN_RTX_DEBUG_MARKER_BEGIN_STMT_PAT() \
   gen_rtx_DEBUG_MARKER (VOIDmode)
-#define GEN_RTX_DEBUG_MARKER_INLINE_ENTRY_PAT() \
-  gen_rtx_DEBUG_MARKER (BLKmode)
 
 /* The VAR_LOCATION rtx in a DEBUG_INSN.  */
 #define INSN_VAR_LOCATION(INSN) \
--- gcc/tree-inline.c	(revision 257511)
+++ gcc/tree-inline.c	(revision 257509)
@@ -4605,13 +4605,6 @@ expand_call_inline (basic_block bb, gimp
 			GSI_NEW_STMT);
     }
   initialize_inlined_parameters (id, stmt, fn, bb);
-  if (debug_nonbind_markers_p && id->block
-      && inlined_function_outer_scope_p (id->block))
-    {
-      gimple_stmt_iterator si = gsi_last_bb (bb);
-      gsi_insert_after (&si, gimple_build_debug_inline_entry
-			(id->block, input_location), GSI_NEW_STMT);
-    }
 
   if (DECL_INITIAL (fn))
     {
--- gcc/var-tracking.c	(revision 257511)
+++ gcc/var-tracking.c	(revision 257509)
@@ -9959,7 +9959,6 @@ reemit_marker_as_note (rtx_insn *insn)
   switch (kind)
     {
     case NOTE_INSN_BEGIN_STMT:
-    case NOTE_INSN_INLINE_ENTRY:
       {
 	rtx_insn *note = NULL;
 	if (cfun->debug_nonbind_markers)
--- gcc/gimple.c	(revision 257511)
+++ gcc/gimple.c	(revision 257509)
@@ -874,27 +874,6 @@ gimple_build_debug_begin_stmt (tree bloc
 }
 
 
-/* Build a new GIMPLE_DEBUG_INLINE_ENTRY statement in BLOCK at
-   LOCATION.  The BLOCK links to the inlined function.  */
-
-gdebug *
-gimple_build_debug_inline_entry (tree block, location_t location
-				      MEM_STAT_DECL)
-{
-  gdebug *p
-    = as_a <gdebug *> (
-        gimple_build_with_ops_stat (GIMPLE_DEBUG,
-				    (unsigned)GIMPLE_DEBUG_INLINE_ENTRY, 0
-				    PASS_MEM_STAT));
-
-  gimple_set_location (p, location);
-  gimple_set_block (p, block);
-  cfun->debug_marker_count++;
-
-  return p;
-}
-
-
 /* Build a GIMPLE_OMP_CRITICAL statement.
 
    BODY is the sequence of statements for which only one thread can execute.
--- gcc/gimple.h	(revision 257511)
+++ gcc/gimple.h	(revision 257509)
@@ -202,8 +202,7 @@ enum gf_mask {
 enum gimple_debug_subcode {
   GIMPLE_DEBUG_BIND = 0,
   GIMPLE_DEBUG_SOURCE_BIND = 1,
-  GIMPLE_DEBUG_BEGIN_STMT = 2,
-  GIMPLE_DEBUG_INLINE_ENTRY = 3
+  GIMPLE_DEBUG_BEGIN_STMT = 2
 };
 
 /* Masks for selecting a pass local flag (PLF) to work on.  These
@@ -1455,7 +1454,6 @@ geh_dispatch *gimple_build_eh_dispatch (
 gdebug *gimple_build_debug_bind (tree, tree, gimple * CXX_MEM_STAT_INFO);
 gdebug *gimple_build_debug_source_bind (tree, tree, gimple * CXX_MEM_STAT_INFO);
 gdebug *gimple_build_debug_begin_stmt (tree, location_t CXX_MEM_STAT_INFO);
-gdebug *gimple_build_debug_inline_entry (tree, location_t CXX_MEM_STAT_INFO);
 gomp_critical *gimple_build_omp_critical (gimple_seq, tree, tree);
 gomp_for *gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);
 gomp_parallel *gimple_build_omp_parallel (gimple_seq, tree, tree, tree);
@@ -4786,25 +4784,13 @@ gimple_debug_begin_stmt_p (const gimple
   return false;
 }
 
-/* Return true if S is a GIMPLE_DEBUG INLINE_ENTRY statement.  */
-
-static inline bool
-gimple_debug_inline_entry_p (const gimple *s)
-{
-  if (is_gimple_debug (s))
-    return s->subcode == GIMPLE_DEBUG_INLINE_ENTRY;
-
-  return false;
-}
-
 /* Return true if S is a GIMPLE_DEBUG non-binding marker statement.  */
 
 static inline bool
 gimple_debug_nonbind_marker_p (const gimple *s)
 {
   if (is_gimple_debug (s))
-    return s->subcode == GIMPLE_DEBUG_BEGIN_STMT
-      || s->subcode == GIMPLE_DEBUG_INLINE_ENTRY;
+    return s->subcode == GIMPLE_DEBUG_BEGIN_STMT;
 
   return false;
 }
