2007-04-24  Jakub Jelinek  <jakub@redhat.com>

	PR tree-optimization/30558
	* tree-eh.c (lower_eh_filter): If EH_FILTER_MUST_NOT_THROW
	clear this_state.prev_try.

	* g++.dg/gomp/pr30558.C: New test.

--- gcc/tree-eh.c.jj	2007-03-12 17:18:17.000000000 +0100
+++ gcc/tree-eh.c	2007-04-24 17:32:16.000000000 +0200
@@ -1497,6 +1497,10 @@ lower_eh_filter (struct leh_state *state
 					 EH_FILTER_TYPES (inner));
   this_state = *state;
   this_state.cur_region = this_region;
+  /* For must not throw regions any cleanup regions inside it
+     can't reach outer catch regions.  */
+  if (EH_FILTER_MUST_NOT_THROW (inner))
+    this_state.prev_try = NULL;
 
   lower_eh_constructs_1 (&this_state, &TREE_OPERAND (*tp, 0));
 
--- gcc/testsuite/g++.dg/gomp/pr30558.C.jj	2007-04-24 17:41:47.000000000 +0200
+++ gcc/testsuite/g++.dg/gomp/pr30558.C	2007-04-24 17:42:24.000000000 +0200
@@ -0,0 +1,41 @@
+// PR tree-optimization/30558
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+template <typename T> struct F
+{
+  ~F ();
+  F (T);
+  const T &operator[] (unsigned i) const;
+};
+
+template <typename T> F<T> foo (const F<T> &x)
+{
+  return F<T> (x[1]);
+}
+
+struct G
+{
+  G () { bar (2); }
+  F<int> &operator () (F<int> x);
+  void bar (int);
+};
+
+int
+main ()
+{
+  try
+  {
+    G g;
+#pragma omp parallel for
+    for (int i = 0; i < 10; ++i)
+      {
+	F<int> j (i);
+	F<int> f = g (j);
+	F<int> h = foo (f);
+      }
+  }
+  catch (int &e)
+  {
+  }
+}
