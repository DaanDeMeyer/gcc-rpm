2017-03-09  Jakub Jelinek  <jakub@redhat.com>

	PR tree-optimization/79972
	* gimple-ssa-warn-alloca.c (alloca_call_type): Only call
	get_range_info on SSA_NAMEs.  Formatting fixes.

	* gcc.dg/pr79972.c: New test.

--- gcc/gimple-ssa-warn-alloca.c.jj	2017-03-07 20:04:52.000000000 +0100
+++ gcc/gimple-ssa-warn-alloca.c	2017-03-09 12:11:41.943934314 +0100
@@ -300,8 +300,9 @@ alloca_call_type (gimple *stmt, bool is_
       ret = alloca_type_and_limit (ALLOCA_OK);
     }
   // Check the range info if available.
-  else if (value_range_type range_type = get_range_info (len, &min, &max))
+  else if (TREE_CODE (len) == SSA_NAME)
     {
+      value_range_type range_type = get_range_info (len, &min, &max);
       if (range_type == VR_RANGE)
 	{
 	  if (wi::leu_p (max, max_size))
@@ -328,7 +329,6 @@ alloca_call_type (gimple *stmt, bool is_
 	      gimple *def = SSA_NAME_DEF_STMT (len);
 	      if (gimple_assign_cast_p (def)
 		  && TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def))))
-
 		{
 		  len_casted = gimple_assign_rhs1 (def);
 		  range_type = get_range_info (len_casted, &min, &max);
@@ -344,8 +344,7 @@ alloca_call_type (gimple *stmt, bool is_
 	      else if (range_type == VR_ANTI_RANGE)
 		return alloca_type_and_limit (ALLOCA_UNBOUNDED);
 	      else if (range_type != VR_VARYING)
-		return
-		  alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE, max);
+		return alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE, max);
 	    }
 	}
       else if (range_type == VR_ANTI_RANGE)
--- gcc/testsuite/gcc.dg/pr79972.c.jj	2017-03-09 12:14:24.188800592 +0100
+++ gcc/testsuite/gcc.dg/pr79972.c	2017-03-09 12:13:38.000000000 +0100
@@ -0,0 +1,16 @@
+/* PR tree-optimization/79972 */
+/* { dg-do compile } */
+/* { dg-require-effective-target alloca } */
+/* { dg-options "-Walloca -Wvla-larger-than=10000" } */
+
+int
+f (int dim, int *b, int *c)
+{
+  int newcentroid[3][dim];	/* { dg-warning "unbounded use of variable-length array" } */
+  int *a = newcentroid[2];
+  int i, dist = 0;
+  __builtin_memcpy (newcentroid, c, sizeof (newcentroid));
+  for (i = 0; i < dim; i++)
+    dist += (a[i] - b[i]) * (a[i] - b[i]);
+  return dist;
+}
