2010-07-30  Jakub Jelinek  <jakub@redhat.com>

	PR debug/45055
	PR rtl-optimization/45137
	* rtl.h (prev_nonnote_nondebug_insn, next_nonnote_nondebug_insn): New
	prototypes.
	* emit-rtl.c (prev_nonnote_nondebug_insn, next_nonnote_nondebug_insn):
	New functions.
	* combine.c (next_nonnote_nondebug_insn): Removed.
	* ifcvt.c (noce_process_if_block): Use prev_nonnote_nondebug_insn.
	* haifa-sched.c (queue_to_ready): Use next_nonnote_nondebug_insn.
	* sched-deps.c (sched_analyze_insn): Likewise.
	(fixup_sched_groups, deps_start_bb): Use prev_nonnote_nondebug_insn.
	* rtlanal.c (canonicalize_condition): Likewise.
	* postreload.c (reload_combine): Likewise.
	(reload_cse_move2add): Use next_nonnote_nondebug_insn.

	* gcc.dg/pr45055.c: New test.

--- gcc/rtl.h.jj	2010-06-11 11:06:01.167282688 +0200
+++ gcc/rtl.h	2010-07-30 16:33:28.722450824 +0200
@@ -1709,6 +1709,8 @@ extern rtx next_nonnote_insn (rtx);
 extern rtx next_nonnote_insn_bb (rtx);
 extern rtx prev_nondebug_insn (rtx);
 extern rtx next_nondebug_insn (rtx);
+extern rtx prev_nonnote_nondebug_insn (rtx);
+extern rtx next_nonnote_nondebug_insn (rtx);
 extern rtx prev_real_insn (rtx);
 extern rtx next_real_insn (rtx);
 extern rtx prev_active_insn (rtx);
--- gcc/emit-rtl.c.jj	2010-06-11 11:06:01.104409599 +0200
+++ gcc/emit-rtl.c	2010-07-30 16:33:28.733479816 +0200
@@ -3162,6 +3162,38 @@ prev_nondebug_insn (rtx insn)
   return insn;
 }
 
+/* Return the next insn after INSN that is not a NOTE nor DEBUG_INSN.
+   This routine does not look inside SEQUENCEs.  */
+
+rtx
+next_nonnote_nondebug_insn (rtx insn)
+{
+  while (insn)
+    {
+      insn = NEXT_INSN (insn);
+      if (insn == 0 || (!NOTE_P (insn) && !DEBUG_INSN_P (insn)))
+	break;
+    }
+
+  return insn;
+}
+
+/* Return the previous insn before INSN that is not a NOTE nor DEBUG_INSN.
+   This routine does not look inside SEQUENCEs.  */
+
+rtx
+prev_nonnote_nondebug_insn (rtx insn)
+{
+  while (insn)
+    {
+      insn = PREV_INSN (insn);
+      if (insn == 0 || (!NOTE_P (insn) && !DEBUG_INSN_P (insn)))
+	break;
+    }
+
+  return insn;
+}
+
 /* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;
    or 0, if there is none.  This routine does not look inside
    SEQUENCEs.  */
--- gcc/combine.c.jj	2010-06-11 11:06:01.175282562 +0200
+++ gcc/combine.c	2010-07-30 16:33:28.754479788 +0200
@@ -12680,29 +12680,6 @@ reg_bitfield_target_p (rtx x, rtx body)
 
   return 0;
 }
-
-/* Return the next insn after INSN that is neither a NOTE nor a
-   DEBUG_INSN.  This routine does not look inside SEQUENCEs.  */
-
-static rtx
-next_nonnote_nondebug_insn (rtx insn)
-{
-  while (insn)
-    {
-      insn = NEXT_INSN (insn);
-      if (insn == 0)
-	break;
-      if (NOTE_P (insn))
-	continue;
-      if (DEBUG_INSN_P (insn))
-	continue;
-      break;
-    }
-
-  return insn;
-}
-
-
 
 /* Given a chain of REG_NOTES originally from FROM_INSN, try to place them
    as appropriate.  I3 and I2 are the insns resulting from the combination
--- gcc/ifcvt.c.jj	2010-06-11 11:06:00.939658763 +0200
+++ gcc/ifcvt.c	2010-07-30 16:33:28.768458909 +0200
@@ -2285,9 +2285,7 @@ noce_process_if_block (struct noce_if_in
     }
   else
     {
-      insn_b = prev_nonnote_insn (if_info->cond_earliest);
-      while (insn_b && DEBUG_INSN_P (insn_b))
-	insn_b = prev_nonnote_insn (insn_b);
+      insn_b = prev_nonnote_nondebug_insn (if_info->cond_earliest);
       /* We're going to be moving the evaluation of B down from above
 	 COND_EARLIEST to JUMP.  Make sure the relevant data is still
 	 intact.  */
--- gcc/haifa-sched.c.jj	2010-06-30 16:53:00.807292319 +0200
+++ gcc/haifa-sched.c	2010-07-30 16:33:28.785485355 +0200
@@ -1997,13 +1997,9 @@ queue_to_ready (struct ready_list *ready
   q_ptr = NEXT_Q (q_ptr);
 
   if (dbg_cnt (sched_insn) == false)
-    {
-      /* If debug counter is activated do not requeue insn next after
-	 last_scheduled_insn.  */
-      skip_insn = next_nonnote_insn (last_scheduled_insn);
-      while (skip_insn && DEBUG_INSN_P (skip_insn))
-	skip_insn = next_nonnote_insn (skip_insn);
-    }
+    /* If debug counter is activated do not requeue insn next after
+       last_scheduled_insn.  */
+    skip_insn = next_nonnote_nondebug_insn (last_scheduled_insn);
   else
     skip_insn = NULL_RTX;
 
--- gcc/sched-deps.c.jj	2010-06-11 11:06:01.160283802 +0200
+++ gcc/sched-deps.c	2010-07-30 16:33:28.799486427 +0200
@@ -1517,9 +1517,7 @@ fixup_sched_groups (rtx insn)
 
   delete_all_dependences (insn);
 
-  prev_nonnote = prev_nonnote_insn (insn);
-  while (DEBUG_INSN_P (prev_nonnote))
-    prev_nonnote = prev_nonnote_insn (prev_nonnote);
+  prev_nonnote = prev_nonnote_nondebug_insn (insn);
   if (BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (prev_nonnote)
       && ! sched_insns_conditions_mutex_p (insn, prev_nonnote))
     add_dependence (insn, prev_nonnote, REG_DEP_ANTI);
@@ -2695,9 +2693,7 @@ sched_analyze_insn (struct deps_desc *de
   if (JUMP_P (insn))
     {
       rtx next;
-      next = next_nonnote_insn (insn);
-      while (next && DEBUG_INSN_P (next))
-	next = next_nonnote_insn (next);
+      next = next_nonnote_nondebug_insn (insn);
       if (next && BARRIER_P (next))
 	reg_pending_barrier = MOVE_BARRIER;
       else
@@ -3366,10 +3362,8 @@ deps_start_bb (struct deps_desc *deps, r
      hard registers correct.  */
   if (! reload_completed && !LABEL_P (head))
     {
-      rtx insn = prev_nonnote_insn (head);
+      rtx insn = prev_nonnote_nondebug_insn (head);
 
-      while (insn && DEBUG_INSN_P (insn))
-	insn = prev_nonnote_insn (insn);
       if (insn && CALL_P (insn))
 	deps->in_post_call_group_p = post_call_initial;
     }
--- gcc/postreload.c.jj	2010-06-11 11:06:00.856659196 +0200
+++ gcc/postreload.c	2010-07-30 16:34:14.703335670 +0200
@@ -810,7 +810,7 @@ reload_combine (void)
 	  rtx reg = SET_DEST (set);
 	  rtx plus = SET_SRC (set);
 	  rtx base = XEXP (plus, 1);
-	  rtx prev = prev_nonnote_insn (insn);
+	  rtx prev = prev_nonnote_nondebug_insn (insn);
 	  rtx prev_set = prev ? single_set (prev) : NULL_RTX;
 	  unsigned int regno = REGNO (reg);
 	  rtx index_reg = NULL_RTX;
@@ -1323,7 +1323,7 @@ reload_cse_move2add (rtx first)
 		       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),
 						 reg_mode[REGNO (src)]))
 		{
-		  rtx next = next_nonnote_insn (insn);
+		  rtx next = next_nonnote_nondebug_insn (insn);
 		  rtx set = NULL_RTX;
 		  if (next)
 		    set = single_set (next);
--- gcc/rtlanal.c.jj	2010-06-11 11:06:00.867421367 +0200
+++ gcc/rtlanal.c	2010-07-30 16:33:28.820478800 +0200
@@ -4755,9 +4755,7 @@ canonicalize_condition (rtx insn, rtx co
 	 stop if it isn't a single set or if it has a REG_INC note because
 	 we don't want to bother dealing with it.  */
 
-      do
-	prev = prev_nonnote_insn (prev);
-      while (prev && DEBUG_INSN_P (prev));
+      prev = prev_nonnote_nondebug_insn (prev);
 
       if (prev == 0
 	  || !NONJUMP_INSN_P (prev)
--- gcc/testsuite/gcc.dg/pr45055.c.jj	2010-07-30 16:33:28.821480043 +0200
+++ gcc/testsuite/gcc.dg/pr45055.c	2010-07-30 16:33:28.822479707 +0200
@@ -0,0 +1,41 @@
+/* PR debug/45055 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftracer -fsched-pressure -funroll-loops -fschedule-insns -fcompare-debug" } */
+
+int colormap[10];
+
+extern int bar ();
+
+void
+foo (int *img, int fp, int y, int *ptr, int depth, int c, int t, int xm)
+{
+  int x, color, count;
+  for (; y; y--)
+    {
+      if (depth)
+	{
+	  count = bar ();
+	  for (x = xm; x; x--)
+	    {
+	      if (c != 1)
+		count = color = -1;
+	      if (count == 0)
+		color = count = bar ();
+	      if (color)
+		t = bar (fp);
+	      *ptr++ = colormap[t];
+	    }
+	}
+      switch (*img)
+	{
+	case 1:
+	  bar ();
+	case 3:
+	case -1:
+	case -3:
+	  bar ();
+	case -4:
+	  bar ();
+	}
+    }
+}
