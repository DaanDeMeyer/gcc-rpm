Revert:
2021-03-18  Vladimir N. Makarov  <vmakarov@redhat.com>

	PR target/99422
	* lra-constraints.c (process_address_1): Use lookup_constraint
	only for a single constraint.

2021-03-10  Vladimir N. Makarov  <vmakarov@redhat.com>

	PR target/99422
	* lra-constraints.c (process_address_1): Don't check unknown
	constraint, use X for empty constraint.

2021-03-09  Vladimir N. Makarov  <vmakarov@redhat.com>

	PR target/99454
	* lra-constraints.c (process_address_1): Process constraint 'g'
	separately and digital constraints containing more one digit.

2021-03-09  Vladimir N. Makarov  <vmakarov@redhat.com>

	PR target/99454
	* lra-constraints.c (process_address_1): Process 0..9 constraints
	in process_address_1.

2021-03-08  Vladimir N. Makarov  <vmakarov@redhat.com>

	PR target/99422
	* lra-constraints.c (skip_contraint_modifiers): New function.
	(process_address_1): Use it before lookup_constraint call.

2021-03-05  Vladimir N. Makarov  <vmakarov@redhat.com>

	PR target/99378
	* lra-constraints.c (process_address_1): Skip decomposing address
	for asm insn operand with unknown constraint.
    
--- gcc/lra-constraints.c.jj	2021-03-19 13:53:38.094778251 +0100
+++ gcc/lra-constraints.c	2021-03-19 14:23:16.017389900 +0100
@@ -3392,21 +3392,6 @@ equiv_address_substitution (struct addre
   return change_p;
 }
 
-/* Skip all modifiers and whitespaces in constraint STR and return the
-   result.  */
-static const char *
-skip_contraint_modifiers (const char *str)
-{
-  for (;;str++)
-    switch (*str)
-      {
-      case '+' : case '&' : case '=': case '*': case ' ': case '\t':
-      case '$': case '^' : case '%': case '?': case '!':
-	break;
-      default: return str;
-      }
-}
-
 /* Major function to make reloads for an address in operand NOP or
    check its correctness (If CHECK_ONLY_P is true). The supported
    cases are:
@@ -3441,8 +3426,8 @@ process_address_1 (int nop, bool check_o
   HOST_WIDE_INT scale;
   rtx op = *curr_id->operand_loc[nop];
   rtx mem = extract_mem_from_operand (op);
-  const char *constraint;
-  enum constraint_num cn;
+  const char *constraint = curr_static_id->operand[nop].constraint;
+  enum constraint_num cn = lookup_constraint (constraint);
   bool change_p = false;
 
   if (MEM_P (mem)
@@ -3450,21 +3435,6 @@ process_address_1 (int nop, bool check_o
       && GET_CODE (XEXP (mem, 0)) == SCRATCH)
     return false;
 
-  constraint
-    = skip_contraint_modifiers (curr_static_id->operand[nop].constraint);
-  if (IN_RANGE (constraint[0], '0', '9'))
-    {
-      char *end;
-      unsigned long dup = strtoul (constraint, &end, 10);
-      constraint
-	= skip_contraint_modifiers (curr_static_id->operand[dup].constraint);
-    }
-  if (*skip_contraint_modifiers (constraint
-				 + CONSTRAINT_LEN (constraint[0],
-						   constraint)) != '\0')
-    cn = CONSTRAINT__UNKNOWN;
-  else
-    cn = lookup_constraint (*constraint == '\0' ? "X" : constraint);
   if (insn_extra_address_constraint (cn)
       /* When we find an asm operand with an address constraint that
 	 doesn't satisfy address_operand to begin with, we clear
