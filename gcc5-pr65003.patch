2015-02-10  Jakub Jelinek  <jakub@redhat.com>

	PR middle-end/65003
	* varasm.c (place_block_symbol): Assert that DECL_RTL of the
	ultimate alias is MEM with SYMBOL_REF satisfying
	SYMBOL_REF_HAS_BLOCK_INFO_P as its operand.  Don't pass the MEM
	to place_block_symbol, but instead pass the SYMBOL_REF operand of it.

	* g++.dg/opt/pr65003.C: New test.

--- gcc/varasm.c.jj	2015-02-04 15:24:20.000000000 +0100
+++ gcc/varasm.c	2015-02-10 15:37:55.872609142 +0100
@@ -7180,6 +7180,10 @@ place_block_symbol (rtx symbol)
 	{
 	  rtx target = DECL_RTL (snode->ultimate_alias_target ()->decl);
 
+	  gcc_assert (MEM_P (target)
+		      && GET_CODE (XEXP (target, 0)) == SYMBOL_REF
+		      && SYMBOL_REF_HAS_BLOCK_INFO_P (XEXP (target, 0)));
+	  target = XEXP (target, 0);
 	  place_block_symbol (target);
 	  SYMBOL_REF_BLOCK_OFFSET (symbol) = SYMBOL_REF_BLOCK_OFFSET (target);
 	  return;
--- gcc/testsuite/g++.dg/opt/pr65003.C.jj	2015-02-10 15:50:44.240734029 +0100
+++ gcc/testsuite/g++.dg/opt/pr65003.C	2015-02-10 15:50:39.468814055 +0100
@@ -0,0 +1,31 @@
+// PR middle-end/65003
+// { dg-do compile }
+// { dg-options "-O2" }
+// { dg-additional-options "-fpic" { target fpic } }
+
+struct A
+{
+  void operator= (A &);
+  A ();
+};
+struct B
+{
+  A b;
+};
+struct C
+{
+  virtual bool foo (int &, bool) const;
+};
+struct D : virtual C
+{
+  bool foo (int &, bool) const;
+  B e;
+};
+struct F : D
+{
+  F (int &, const int &, const A &);
+  bool foo (int &, bool) const;
+};
+bool D::foo (int &, bool) const {}
+F::F (int &, const int &, const A &) {}
+bool F::foo (int &, bool) const {}
