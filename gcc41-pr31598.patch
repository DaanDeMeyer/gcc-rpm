2007-04-24  Jakub Jelinek  <jakub@redhat.com>

	PR c++/31598
	* tree-inline.c (copy_body_r): Don't touch TREE_TYPE of OMP_CLAUSE.

	* semantics.c (finish_omp_clauses): Don't create CP_OMP_CLAUSE_INFO
	for type dependent OMP_CLAUSE_DECLs.

	* g++.dg/gomp/pr31598.C: New test.

--- gcc/tree-inline.c.jj	2007-04-14 14:55:25.000000000 +0200
+++ gcc/tree-inline.c	2007-04-24 11:33:19.000000000 +0200
@@ -650,7 +650,8 @@ copy_body_r (tree *tp, int *walk_subtree
 	    (NULL_TREE,
 	     id->eh_region_offset + TREE_INT_CST_LOW (TREE_OPERAND (*tp, 0)));
 
-      TREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);
+      if (TREE_CODE (*tp) != OMP_CLAUSE)
+	TREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);
 
       /* The copied TARGET_EXPR has never been expanded, even if the
 	 original node was expanded already.  */
--- gcc/cp/semantics.c.jj	2007-04-01 20:16:51.000000000 +0200
+++ gcc/cp/semantics.c	2007-04-24 10:45:35.000000000 +0200
@@ -3627,7 +3627,8 @@ finish_omp_clauses (tree clauses)
 	 Save the results, because later we won't be in the right context
 	 for making these queries.  */
       if (CLASS_TYPE_P (inner_type)
-	  && (need_default_ctor || need_copy_ctor || need_copy_assignment))
+	  && (need_default_ctor || need_copy_ctor || need_copy_assignment)
+	  && !type_dependent_expression_p (t))
 	{
 	  int save_errorcount = errorcount;
 	  tree info;
--- gcc/testsuite/g++.dg/gomp/pr31598.C.jj	2007-04-24 10:47:50.000000000 +0200
+++ gcc/testsuite/g++.dg/gomp/pr31598.C	2007-04-24 11:49:35.000000000 +0200
@@ -0,0 +1,59 @@
+// PR c++/31598
+// { dg-do compile }
+//
+// Copyright (C) 2007 Free Software Foundation, Inc.
+// Contributed by Theodore.Papadopoulo
+//   16 Apr 2007 <Theodore.Papadopoulo@sophia.inria.fr>
+
+int i;
+template <typename> struct A { A() {} };
+template <typename> struct C { C() { i++; } C(const C &) { i += 2; } };
+struct D { D() {} };
+
+struct M { typedef double E; };
+
+template <typename T>
+struct R
+{
+  R()
+  {
+    typedef A<typename T::E> B;
+    B b;
+    #pragma omp parallel for firstprivate(b) schedule(guided)
+      for (int t = 0; t < 10; ++t)
+	;
+  }
+};
+
+template <typename T>
+struct S
+{
+  S()
+  {
+    typedef C<typename T::E> B;
+    B b;
+    #pragma omp parallel for firstprivate(b)
+      for (int t = 0; t < 10; ++t)
+	;
+  }
+};
+
+struct U
+{
+  U()
+  {
+    D b;
+    #pragma omp parallel for firstprivate(b)
+      for (int t = 0; t < 10; ++t)
+	;
+  }
+};
+
+int
+main ()
+{
+  R<M> r;
+  S<M> s;
+  U u;
+  return 0;
+}
