2006-05-05  Jakub Jelinek  <jakub@redhat.com>

	* gcc.dg/tls/opt-12.c: New test.

2006-04-25  Jakub Jelinek  <jakub@redhat.com>

	* gcc.dg/20060425-2.c: New test.

	* g++.dg/opt/pr15054-2.C: New test.

2006-04-20  Jakub Jelinek  <jakub@redhat.com>

	* gcc.c-torture/execute/20060420-1.c: New test.

2006-04-12  Jakub Jelinek  <jakub@redhat.com>

	* gcc.c-torture/execute/20060412-1.c: New test.

2006-02-25  Alexandre Oliva  <aoliva@redhat.com>

	* gcc.target/powerpc/altivec-23.c: New test.

--- gcc/testsuite/gcc.target/powerpc/altivec-23.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc/testsuite/gcc.target/powerpc/altivec-23.c	2006-02-25 04:10:36.000000000 -0300
@@ -0,0 +1,25 @@
+/* Verify that it is possible to define variables of composite types
+   containing vector types.  We used to crash handling the
+   initializer of automatic ones.  */
+
+/* { dg-do compile } */
+/* { dg-xfail-if "" { "powerpc-ibm-aix*" } { "-maltivec" } { "" } } */
+/* { dg-options "-maltivec -mabi=altivec" } */
+
+#include <altivec.h>
+
+typedef int bt;
+typedef vector bt vt;
+typedef struct { vt x; bt y[sizeof(vt) / sizeof (bt)]; } st;
+#define INIT { 1, 2, 3, 4 }
+
+void f ()
+{
+  vt x = INIT;
+  vt y[1] = { INIT };
+  st s = { INIT, INIT };
+}
+
+vt x = INIT;
+vt y[1] = { INIT };
+st s = { INIT, INIT };
--- gcc/testsuite/gcc.c-torture/execute/20060420-1.c.jj	2006-04-20 18:47:19.000000000 +0200
+++ gcc/testsuite/gcc.c-torture/execute/20060420-1.c	2006-04-20 19:07:20.000000000 +0200
@@ -0,0 +1,71 @@
+extern void abort (void);
+
+typedef float v4flt __attribute__ ((vector_size (16)));
+
+void __attribute__ ((noinline)) foo (float *dst, float **src, int a, int n)
+{
+  int i, j;
+  int z = sizeof (v4flt) / sizeof (float);
+  unsigned m = sizeof (v4flt) - 1;
+
+  for (j = 0; j < n && (((unsigned long) dst + j) & m); ++j)
+    {
+      float t = src[0][j];
+      for (i = 1; i < a; ++i)
+	t += src[i][j];
+      dst[j] = t;
+    }
+
+  for (; j < (n - (4 * z - 1)); j += 4 * z)
+    {
+      v4flt t0 = *(v4flt *) (src[0] + j + 0 * z);
+      v4flt t1 = *(v4flt *) (src[0] + j + 1 * z);
+      v4flt t2 = *(v4flt *) (src[0] + j + 2 * z);
+      v4flt t3 = *(v4flt *) (src[0] + j + 3 * z);
+      for (i = 1; i < a; ++i)
+	{
+	  t0 += *(v4flt *) (src[i] + j + 0 * z);
+	  t1 += *(v4flt *) (src[i] + j + 1 * z);
+	  t2 += *(v4flt *) (src[i] + j + 2 * z);
+	  t3 += *(v4flt *) (src[i] + j + 3 * z);
+	}
+      *(v4flt *) (dst + j + 0 * z) = t0;
+      *(v4flt *) (dst + j + 1 * z) = t1;
+      *(v4flt *) (dst + j + 2 * z) = t2;
+      *(v4flt *) (dst + j + 3 * z) = t3;
+    }
+  for (; j < n; ++j)
+    {
+      float t = src[0][j];
+      for (i = 1; i < a; ++i)
+	t += src[i][j];
+      dst[j] = t;
+    }
+}
+
+float buffer[64];
+
+int
+main (void)
+{
+  int i;
+  float *dst, *src[2];
+
+  dst = buffer;
+  dst += (-(long int) buffer & (16 * sizeof (float) - 1)) / sizeof (float);
+  src[0] = dst + 16;
+  src[1] = dst + 32;
+  for (i = 0; i < 16; ++i)
+    {
+      src[0][i] = (float) i + 11 * (float) i;
+      src[1][i] = (float) i + 12 * (float) i;
+    }
+  foo (dst, src, 2, 16);
+  for (i = 0; i < 16; ++i)
+    {
+      float e = (float) i + 11 * (float) i + (float) i + 12 * (float) i;
+      if (dst[i] != e)
+	abort ();
+    }
+  return 0;
+}
--- gcc/testsuite/gcc.c-torture/execute/20060412-1.c.jj	2006-04-03 11:04:53.758553500 +0200
+++ gcc/testsuite/gcc.c-torture/execute/20060412-1.c	2006-04-12 10:54:20.000000000 +0200
@@ -0,0 +1,33 @@
+extern void abort (void);
+
+struct S
+{
+  long o;
+};
+
+struct T
+{
+  long o;
+  struct S m[82];
+};
+
+struct T t;
+
+int
+main ()
+{
+  struct S *p, *q;
+
+  p = (struct S *) &t;
+  p = &((struct T *) p)->m[0];
+  q = p + 82;
+  while (--q > p)
+    q->o = -1;
+  q->o = 0;
+
+  if (q > p)
+    abort ();
+  if (q - p > 0)
+    abort ();
+  return 0;
+}
--- gcc/testsuite/g++.dg/opt/pr15054-2.C	2006-04-19 19:21:31.748476000 +0200
+++ gcc/testsuite/g++.dg/opt/pr15054-2.C	2006-04-25 15:55:07.000000000 +0200
@@ -0,0 +1,39 @@
+// PR middle-end/15054
+
+// { dg-do run }
+// { dg-options "-O2" }
+
+extern "C" void abort (void);
+
+void
+__attribute__((noinline))
+check (long x, long y)
+{
+  if (x != y)
+    abort ();
+}
+
+struct A
+{
+  A() : a(2) { check (a, 2); }
+  ~A() { check (a, 2); }
+private:
+  long a;
+};
+
+class B {
+  long b;
+  B& operator =(const B& );
+public:
+  B (long p) : b(p) { check (b, 6); }
+  B (const B& p) : b(p.b) { check (b, 6); }
+  ~B () { check (b, 6); A obj; check (b, 6); }
+  B foo() { return B(*this); }
+};
+
+int main ()
+{
+  B o(6);
+  o.foo().foo();
+  return 0;
+}
--- gcc/testsuite/gcc.dg/20060425-2.c	2004-06-24 14:04:38.000000000 -0400
+++ gcc/testsuite/gcc.dg/20060425-2.c	2006-04-25 09:15:04.000000000 -0400
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+crashme (double v, double *p)
+{
+  if (v < 0. && *p == 1.)
+    v = 0.;
+  return v;
+}
--- gcc/testsuite/gcc.dg/tls/opt-12.c	2006-04-19 19:21:31.748476000 +0200
+++ gcc/testsuite/gcc.dg/tls/opt-12.c	2006-05-05 11:01:33.000000000 +0200
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-require-effective-target tls } */
+
+__thread struct
+{
+  int a;
+  char b[32];
+} thr;
+
+int
+main ()
+{
+  __builtin_strcpy (thr.b, "abcd");
+  return 0;
+}
