2006-12-08  Jakub Jelinek  <jakub@redhat.com>

	* g++.dg/debug/vartrack1.C: New test.

	* g++.dg/opt/ifcvt1.C: New test.

2006-12-08  Alexandre Oliva  <aoliva@redhat.com>

	* g++.dg/template/array17.C: New test.

2006-05-05  Jakub Jelinek  <jakub@redhat.com>

	* gcc.dg/tls/opt-13.c: New test.

2006-04-25  Jakub Jelinek  <jakub@redhat.com>

	* gcc.dg/20060425-2.c: New test.

	* g++.dg/opt/pr15054-2.C: New test.

2006-04-20  Jakub Jelinek  <jakub@redhat.com>

	* gcc.c-torture/execute/20060420-1.c: New test.

2006-04-12  Jakub Jelinek  <jakub@redhat.com>

	* gcc.c-torture/execute/20060412-1.c: New test.

2006-02-25  Alexandre Oliva  <aoliva@redhat.com>

	* gcc.target/powerpc/altivec-23.c: New test.

--- gcc/testsuite/gcc.target/powerpc/altivec-23.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc/testsuite/gcc.target/powerpc/altivec-23.c	2006-02-25 04:10:36.000000000 -0300
@@ -0,0 +1,25 @@
+/* Verify that it is possible to define variables of composite types
+   containing vector types.  We used to crash handling the
+   initializer of automatic ones.  */
+
+/* { dg-do compile } */
+/* { dg-xfail-if "" { "powerpc-ibm-aix*" } { "-maltivec" } { "" } } */
+/* { dg-options "-maltivec -mabi=altivec" } */
+
+#include <altivec.h>
+
+typedef int bt;
+typedef vector bt vt;
+typedef struct { vt x; bt y[sizeof(vt) / sizeof (bt)]; } st;
+#define INIT { 1, 2, 3, 4 }
+
+void f ()
+{
+  vt x = INIT;
+  vt y[1] = { INIT };
+  st s = { INIT, INIT };
+}
+
+vt x = INIT;
+vt y[1] = { INIT };
+st s = { INIT, INIT };
--- gcc/testsuite/gcc.c-torture/execute/20060420-1.c.jj	2006-04-20 18:47:19.000000000 +0200
+++ gcc/testsuite/gcc.c-torture/execute/20060420-1.c	2006-04-20 19:07:20.000000000 +0200
@@ -0,0 +1,71 @@
+extern void abort (void);
+
+typedef float v4flt __attribute__ ((vector_size (16)));
+
+void __attribute__ ((noinline)) foo (float *dst, float **src, int a, int n)
+{
+  int i, j;
+  int z = sizeof (v4flt) / sizeof (float);
+  unsigned m = sizeof (v4flt) - 1;
+
+  for (j = 0; j < n && (((unsigned long) dst + j) & m); ++j)
+    {
+      float t = src[0][j];
+      for (i = 1; i < a; ++i)
+	t += src[i][j];
+      dst[j] = t;
+    }
+
+  for (; j < (n - (4 * z - 1)); j += 4 * z)
+    {
+      v4flt t0 = *(v4flt *) (src[0] + j + 0 * z);
+      v4flt t1 = *(v4flt *) (src[0] + j + 1 * z);
+      v4flt t2 = *(v4flt *) (src[0] + j + 2 * z);
+      v4flt t3 = *(v4flt *) (src[0] + j + 3 * z);
+      for (i = 1; i < a; ++i)
+	{
+	  t0 += *(v4flt *) (src[i] + j + 0 * z);
+	  t1 += *(v4flt *) (src[i] + j + 1 * z);
+	  t2 += *(v4flt *) (src[i] + j + 2 * z);
+	  t3 += *(v4flt *) (src[i] + j + 3 * z);
+	}
+      *(v4flt *) (dst + j + 0 * z) = t0;
+      *(v4flt *) (dst + j + 1 * z) = t1;
+      *(v4flt *) (dst + j + 2 * z) = t2;
+      *(v4flt *) (dst + j + 3 * z) = t3;
+    }
+  for (; j < n; ++j)
+    {
+      float t = src[0][j];
+      for (i = 1; i < a; ++i)
+	t += src[i][j];
+      dst[j] = t;
+    }
+}
+
+float buffer[64];
+
+int
+main (void)
+{
+  int i;
+  float *dst, *src[2];
+
+  dst = buffer;
+  dst += (-(long int) buffer & (16 * sizeof (float) - 1)) / sizeof (float);
+  src[0] = dst + 16;
+  src[1] = dst + 32;
+  for (i = 0; i < 16; ++i)
+    {
+      src[0][i] = (float) i + 11 * (float) i;
+      src[1][i] = (float) i + 12 * (float) i;
+    }
+  foo (dst, src, 2, 16);
+  for (i = 0; i < 16; ++i)
+    {
+      float e = (float) i + 11 * (float) i + (float) i + 12 * (float) i;
+      if (dst[i] != e)
+	abort ();
+    }
+  return 0;
+}
--- gcc/testsuite/gcc.c-torture/execute/20060412-1.c.jj	2006-04-03 11:04:53.758553500 +0200
+++ gcc/testsuite/gcc.c-torture/execute/20060412-1.c	2006-04-12 10:54:20.000000000 +0200
@@ -0,0 +1,33 @@
+extern void abort (void);
+
+struct S
+{
+  long o;
+};
+
+struct T
+{
+  long o;
+  struct S m[82];
+};
+
+struct T t;
+
+int
+main ()
+{
+  struct S *p, *q;
+
+  p = (struct S *) &t;
+  p = &((struct T *) p)->m[0];
+  q = p + 82;
+  while (--q > p)
+    q->o = -1;
+  q->o = 0;
+
+  if (q > p)
+    abort ();
+  if (q - p > 0)
+    abort ();
+  return 0;
+}
--- gcc/testsuite/g++.dg/opt/pr15054-2.C	2006-04-19 19:21:31.748476000 +0200
+++ gcc/testsuite/g++.dg/opt/pr15054-2.C	2006-04-25 15:55:07.000000000 +0200
@@ -0,0 +1,39 @@
+// PR middle-end/15054
+
+// { dg-do run }
+// { dg-options "-O2" }
+
+extern "C" void abort (void);
+
+void
+__attribute__((noinline))
+check (long x, long y)
+{
+  if (x != y)
+    abort ();
+}
+
+struct A
+{
+  A() : a(2) { check (a, 2); }
+  ~A() { check (a, 2); }
+private:
+  long a;
+};
+
+class B {
+  long b;
+  B& operator =(const B& );
+public:
+  B (long p) : b(p) { check (b, 6); }
+  B (const B& p) : b(p.b) { check (b, 6); }
+  ~B () { check (b, 6); A obj; check (b, 6); }
+  B foo() { return B(*this); }
+};
+
+int main ()
+{
+  B o(6);
+  o.foo().foo();
+  return 0;
+}
--- gcc/testsuite/gcc.dg/20060425-2.c	2004-06-24 14:04:38.000000000 -0400
+++ gcc/testsuite/gcc.dg/20060425-2.c	2006-04-25 09:15:04.000000000 -0400
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+crashme (double v, double *p)
+{
+  if (v < 0. && *p == 1.)
+    v = 0.;
+  return v;
+}
--- gcc/testsuite/gcc.dg/tls/opt-13.c	2006-04-19 19:21:31.748476000 +0200
+++ gcc/testsuite/gcc.dg/tls/opt-13.c	2006-05-05 11:01:33.000000000 +0200
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-require-effective-target tls } */
+
+__thread struct
+{
+  int a;
+  char b[32];
+} thr;
+
+int
+main ()
+{
+  __builtin_strcpy (thr.b, "abcd");
+  return 0;
+}
--- gcc/testsuite/g++.dg/debug/vartrack1.C	2004-06-24 14:04:38.000000000 -0400
+++ gcc/testsuite/g++.dg/debug/vartrack1.C	2006-12-08 05:29:41.000000000 -0500
@@ -0,0 +1,99 @@
+// This testcase used to hang the compiler in vt_find_locations.
+// { dg-do compile }
+// { dg-options "-O2 -g" }
+
+struct S
+{
+  int a;
+  S *b, *c, *d;
+};
+
+struct T
+{
+  void f1 (S *x);
+  void f2 (S *x);
+  void f3 (S *x, S *y);
+  S *e;
+};
+
+void
+T::f3 (S *x, S *y)
+{
+  while (x != this->e && (!x || x->a == 1))
+    {
+      if (x == y->c)
+	{
+	  S *w = y->d;
+	  if (w && w->a == 0)
+	    {
+	      w->a = 1;
+	      y->a = 0;
+	      f2 (y);
+	      w = y->d;
+	    }
+	  if (w && (!w->c || w->c->a == 1) && (!w->d || w->d->a == 1))
+	    {
+	      w->a = 0;
+	      x = y;
+	      y = x->b;
+	    }
+	  else
+	    {
+	      if (w && (!w->d || w->d->a == 1))
+		{
+		  if (w->c)
+		    w->c->a = 1;
+		  w->a = 0;
+		  f1 (w);
+		  w = y->d;
+		}
+	      if (w)
+		{
+		  w->a = y->a;
+		  if (w->d)
+		    w->d->a = 1;
+		}
+	      y->a = 1;
+	      f2 (y);
+	      x = e;
+	    }
+	}
+      else
+	{
+	  S *w = y->c;
+	  if (w && w->a == 0)
+	    {
+	      w->a = 1;
+	      y->a = 0;
+	      f1 (y);
+	      w = y->c;
+	    }
+	  if (w && (!w->c || w->c->a == 1) && (!w->d || w->d->a == 1))
+	    {
+	      w->a = 0;
+	      x = y;
+	      y = x->b;
+	    }
+	  else
+	    {
+	      if (w && (!w->c || w->c->a == 1))
+		{
+		  w->a = 0;
+		  if (w->d)
+		    w->d->a = 1;
+		  f2 (w);
+		  w = y->c;
+		}
+	      if (w)
+		{
+		  w->a = y->a;
+		  if (w->c)
+		    w->c->a = 1;
+		}
+	      y->a = 1;
+	      f1 (y);
+	      x = e;
+	    }
+	}
+    }
+}
--- gcc/testsuite/g++.dg/opt/ifcvt1.C	2006-10-04 16:28:56.502613000 +0200
+++ gcc/testsuite/g++.dg/opt/ifcvt1.C	2006-12-08 12:23:23.000000000 +0100
@@ -0,0 +1,17 @@
+// { dg-do compile }
+// { dg-options "-O2 -fnon-call-exceptions" }
+
+struct S { ~S () throw () {} };
+double bar ();
+
+int
+foo ()
+{
+  S a;
+  int i = 0;
+  double c = bar ();
+  c = c < 0 ? -c : c;
+  if (c <= 1.e-8)
+    i += 24;
+  return i;
+}
--- gcc/testsuite/g++.dg/template/array17.C	2006-10-04 16:28:56.502613000 +0200
+++ gcc/testsuite/g++.dg/template/array17.C	2006-12-08 12:38:27.000000000 +0100
@@ -0,0 +1,23 @@
+// { dg-do compile }
+
+template <typename T>
+struct V {
+  T& operator[](int);
+};
+
+struct S {
+  S operator +(int);
+  template <typename T> T value();
+};
+
+template <typename T>
+void R (T v)
+{
+  v[(S() + 0).template value<int>()][0] = 0;
+}
+
+int
+main ()
+{
+  R(V<V<int> >());
+}
