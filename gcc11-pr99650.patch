2021-03-18  Jakub Jelinek  <jakub@redhat.com>

	PR c++/99650
	* decl.c (cp_finish_decomp): Diagnose void initializers when
	using tuple_element and get.

	* g++.dg/cpp1z/decomp55.C: New test.

--- gcc/cp/decl.c.jj	2021-03-16 21:17:41.014498713 +0100
+++ gcc/cp/decl.c	2021-03-18 19:31:22.430149523 +0100
@@ -8629,6 +8629,11 @@ cp_finish_decomp (tree decl, tree first,
 			 : get_tuple_element_type (type, i));
 	  input_location = sloc;
 
+	  if (VOID_TYPE_P (eltype))
+	    {
+	      error ("forming reference to void");
+	      eltype = error_mark_node;
+	    }
 	  if (init == error_mark_node || eltype == error_mark_node)
 	    {
 	      inform (dloc, "in initialization of structured binding "
--- gcc/testsuite/g++.dg/cpp1z/decomp55.C.jj	2021-03-18 19:43:07.958457494 +0100
+++ gcc/testsuite/g++.dg/cpp1z/decomp55.C	2021-03-18 19:42:35.099815746 +0100
@@ -0,0 +1,19 @@
+// PR c++/99650
+// { dg-do compile { target c++17 } }
+
+namespace std {
+  template<typename T> struct tuple_size;
+  template<int, typename> struct tuple_element;
+}
+
+struct A {
+  int i;
+  template <int I> void get() { }
+};
+
+template<> struct std::tuple_size<A> { static const int value = 2; };
+template<int I> struct std::tuple_element<I,A> { using type = void; };
+
+A a = { 42 };
+auto [ x, y ] = a;	// { dg-error "forming reference to void" }
+// { dg-message "in initialization of structured binding variable 'x'" "" { target *-*-* } .-1 }
