2009-05-29  Jakub Jelinek  <jakub@redhat.com>

	* config/i386/i386.c (ix86_decompose_address): Avoid useless
	0 displacement.  Add 0 displacement if base is %[er]bp or %r13.

	* config/i386/i386.md (prefix_data16, prefix_rep): Set to 0 for
	TYPE_SSE{MULADD,4ARG,IADD1,CVT1} by default.
	(prefix_rex): For UNIT_MMX don't imply the prefix by default
	if MODE_DI.
	(prefix_extra): Default to 2 for TYPE_SSE{MULADD,4ARG} and
	to 1 for TYPE_SSE{IADD1,CVT1}.
	(prefix_vex_imm8): Removed.
	(length_vex): Only pass 1 as second argument to
	ix86_attr_length_vex_default if prefix_extra is 0.
	(modrm): For TYPE_INCDEC only set to 0 if not TARGET_64BIT.
	(length): For prefix vex computation use length_immediate
	attribute instead of prefix_vex_imm8.
	(cmpqi_ext_3_insn, cmpqi_ext_3_insn_rex64,
	addqi_ext_1, addqi_ext_1_rex64, *testqi_ext_0, andqi_ext_0,
	*andqi_ext_0_cc, *iorqi_ext_0, *xorqi_ext_0, *xorqi_cc_ext_1,
	*xorqi_cc_ext_1_rex64): Override modrm attribute to 1.
	(extendsidi2_rex64, extendhidi2, extendqidi2, extendhisi2,
	*extendhisi2_zext, extendqihi2, extendqisi2, *extendqisi2_zext): Emit
	a space in between the operands.
	(*anddi_1_rex64, *andsi_1): Likewise.  Override prefix_rex to 1
	if one operand is 0xff and the other one si, di, bp or sp.
	(*andhi_1): Override prefix_rex to 1 if one operand is 0xff and the
	other one si, di, bp or sp.
	(*btsq, *btrq, *btcq, *btdi_rex64, *btsi): Add mode attribute.
	(*ffssi_1, *ffsdi_1, ctzsi2, ctzdi2): Add
	type and mode attributes.
	(*bsr, *bsr_rex64, *bsrhi): Add type attribute.
	(*cmpfp_i_mixed, *cmpfp_iu_mixed): For TYPE_SSECOMI, clear
	prefix_rep attribute and set prefix_data16 attribute iff MODE_DF.
	(*cmpfp_i_sse, *cmpfp_iu_sse): Clear prefix_rep attribute and set
	prefix_data16 attribute iff MODE_DF.
	(*movsi_1): For TYPE_SSEMOV MODE_SI set prefix_data16 attribute.
	(fix_trunc<mode>di_sse): Set prefix_rex attribute.
	(*adddi_4_rex64, *addsi_4): Use const128_operand instead of
	constm128_operand in length_immediate computation.
	(*addhi_4): Likewise.  Fix mode attribute to MODE_HI.
	(anddi_1_rex64): Use movzbl/movzwl instead of movzbq/movzwq.
	(*avx_ashlti3, sse2_ashlti3, *avx_lshrti3, sse2_lshrti3): Set
	length_immediate attribute to 1.
	(x86_fnstsw_1, x86_fnstcw_1, x86_fldcw_1): Fix length attribute.
	(*movdi_1_rex64): Override prefix_rex or prefix_data16 attributes
	for certain alternatives.
	(*movdf_nointeger, *movdf_integer_rex64, *movdf_integer): Override
	prefix_data16 attribute if MODE_V1DF.
	(*avx_setcc<mode>, *sse_setcc<mode>, *sse5_setcc<mode>): Set
	length_immediate to 1.
	(set_got_rex64, set_rip_rex64): Remove length attribute, set
	length_address to 4, set mode attribute to MODE_DI.
	(set_got_offset_rex64): Likewise.  Set length_immediate to 0.
	(fxam<mode>2_i387): Set length attribute to 4.
	(*prefetch_sse, *prefetch_sse_rex, *prefetch_3dnow,
	*prefetch_3dnow_rex): Override length_address attribute.
	(sse4_2_crc32<mode>): Override prefix_data16 and prefix_rex
	attributes.
	* config/i386/predicates.md (ext_QIreg_nomode_operand): New predicate.
	(constm128_operand): Removed.
	* config/i386/i386.c (memory_address_length): For
	disp && !index && !base in 64-bit mode account for SIB byte if
	print_operand_address can't optimize disp32 into disp32(%rip)
	and UNSPEC doesn't imply (%rip) addressing.  Add 1 to length
	for fs: or gs: segment.
	(ix86_attr_length_immediate_default): When checking if shortform
	is possible, truncate immediate to the length of the non-shortened
	immediate.
	(ix86_attr_length_address_default): Ignore MEM_P operands
	with X constraint.
	(ix86_attr_length_vex_default): Only check for DImode on
	GENERAL_REG_P operands.
	* config/i386/sse.md (<sse>_comi, <sse>_ucomi): Clear
	prefix_rep attribute, set prefix_data16 attribute iff MODE_DF.
	(sse_cvttps2pi): Clear prefix_rep attribute.
	(sse2_cvttps2dq, *sse2_cvtpd2dq, sse2_cvtps2pd): Clear prefix_data16
	attribute.
	(*sse2_cvttpd2dq): Don't clear prefix_rep attribute.
	(*avx_ashr<mode>3, ashr<mode>3, *avx_lshr<mode>3, lshr<mode>3,
	*avx_ashl<mode>3, ashl<mode>3): Set length_immediate attribute to 1
	iff operand 2 is const_int_operand.
	(*vec_dupv4si, avx_shufpd256_1, *avx_shufpd_<mode>,
	sse2_shufpd_<mode>): Set length_immediate attribute to 1.
	(sse2_pshufd_1): Likewise.  Set prefix attribute to maybe_vex
	instead of vex.
	(sse2_pshuflw_1, sse2_pshufhw_1): Set length_immediate to 1 and clear
	prefix_data16.
	(sse2_unpckhpd, sse2_unpcklpd, sse2_storehpd, *vec_concatv2df): Set
	prefix_data16 attribute for movlpd and movhpd instructions.
	(sse2_loadhpd, sse2_loadlpd, sse2_movsd): Likewise.  Override
	length_immediate for shufpd instruction.
	(sse2_movntsi, sse3_lddqu): Clear prefix_data16 attribute.
	(avx_cmpp<avxmodesuffixf2c><mode>3,
	avx_cmps<ssemodesuffixf2c><mode>3, *avx_maskcmp<mode>3,
	<sse>_maskcmp<mode>3, <sse>_vmmaskcmp<mode>3,
	avx_shufps256_1, *avx_shufps_<mode>, sse_shufps_<mode>,
	*vec_dupv4sf_avx, *vec_dupv4sf): Set
	length_immediate attribute to 1.
	(*avx_cvtsi2ssq, *avx_cvtsi2sdq): Set length_vex attribute to 4.
	(sse_cvtsi2ssq, sse2_cvtsi2sdq): Set prefix_rex attribute to 1.
	(sse2_cvtpi2pd, sse_loadlps, sse2_storelpd): Override
	prefix_data16 attribute for the first alternative to 1.
	(*avx_loadlps): Override length_immediate for the first alternative.
	(*vec_concatv2sf_avx): Override length_immediate and prefix_extra
	attributes for second alternative.
	(*vec_concatv2sf_sse4_1): Override length_immediate and
	prefix_data16 attributes for second alternative.
	(*vec_setv4sf_avx, *avx_insertps, vec_extract_lo_<mode>,
	vec_extract_hi_<mode>, vec_extract_lo_v16hi,
	vec_extract_hi_v16hi, vec_extract_lo_v32qi,
	vec_extract_hi_v32qi): Set prefix_extra and length_immediate to 1.
	(*vec_setv4sf_sse4_1, sse4_1_insertps, *sse4_1_extractps): Set
	prefix_data16 and length_immediate to 1.
	(*avx_mulv2siv2di3, *avx_mulv4si3, sse4_2_gtv2di3): Set prefix_extra
	to 1.
	(*avx_<code><mode>3, *avx_eq<mode>3, *avx_gt<mode>3): Set
	prefix_extra attribute for variants that don't have 0f prefix
	alone.
	(*avx_pinsr<ssevecsize>): Likewise.  Set length_immediate to 1.
	(*sse4_1_pinsrb, *sse2_pinsrw, *sse4_1_pinsrd, *sse4_1_pextrb,
	*sse4_1_pextrb_memory, *sse2_pextrw, *sse4_1_pextrw_memory,
	*sse4_1_pextrd): Set length_immediate to 1.
	(*sse4_1_pinsrd): Likewise.  Set prefix_extra to 1.
	(*sse4_1_pinsrq, *sse4_1_pextrq): Set prefix_rex and length_immediate
	to 1.
	(*vec_extractv2di_1_rex64_avx, *vec_extractv2di_1_rex64,
	*vec_extractv2di_1_avx, *vec_extractv2di_1_sse2): Override
	length_immediate to 1 for second alternative.
	(*vec_concatv2si_avx, *vec_concatv2di_rex64_avx): Override
	prefix_extra and length_immediate attributes for the first
	alternative.
	(vec_concatv2si_sse4_1): Override length_immediate to 1 for the
	first alternative.
	(*vec_concatv2di_rex64_sse4_1): Likewise.  Override prefix_rex
	to 1 for the first and third alternative.
	(*vec_concatv2di_rex64_sse): Override prefix_rex to 1 for the second
	alternative.
	(*sse2_maskmovdqu, *sse2_maskmovdqu_rex64): Override length_vex
	attribute.
	(*sse_sfence, sse2_mfence, sse2_lfence): Override length_address
	attribute to 0.
	(*avx_phaddwv8hi3, *avx_phadddv4si3, *avx_phaddswv8hi3,
	*avx_phsubwv8hi3, *avx_phsubdv4si3, *avx_phsubswv8hi,
	*avx_pmaddubsw128, *avx_pmulhrswv8hi3, *avx_pshufbv16qi3,
	*avx_psign<mode>3): Set prefix_extra attribute to 1.
	(ssse3_phaddwv4hi3, ssse3_phadddv2si3, ssse3_phaddswv4hi3,
	ssse3_phsubwv4hi3, ssse3_phsubdv2si3, ssse3_phsubswv4hi3,
	ssse3_pmaddubsw, *ssse3_pmulhrswv4hi, ssse3_pshufbv8qi3,
	ssse3_psign<mode>3): Override prefix_rex attribute.
	(*avx_palignrti): Override prefix_extra and length_immediate
	to 1.
	(ssse3_palignrti): Override length_immediate to 1.
	(ssse3_palignrdi): Override length_immediate to 1, override
	prefix_rex attribute.
	(abs<mode>2): Override prefix_rep to 0, override prefix_rex
	attribute.
	(sse4a_extrqi): Override length_immediate to 2.
	(sse4a_insertqi): Likewise.  Override prefix_data16 to 0.
	(sse4a_insertq): Override prefix_data16 to 0.
	(avx_blendp<avxmodesuffixf2c><avxmodesuffix>,
	avx_blendvp<avxmodesuffixf2c><avxmodesuffix>,
	avx_dpp<avxmodesuffixf2c><avxmodesuffix>, *avx_mpsadbw,
	*avx_pblendvb, *avx_pblendw, avx_roundp<avxmodesuffixf2c>256,
	avx_rounds<avxmodesuffixf2c>256): Override prefix_extra
	and length_immediate to 1.
	(sse4_1_blendp<ssemodesuffixf2c>, sse4_1_dpp<ssemodesuffixf2c>,
	sse4_2_pcmpestr, sse4_2_pcmpestri, sse4_2_pcmpestrm,
	sse4_2_pcmpestr_cconly, sse4_2_pcmpistr, sse4_2_pcmpistri,
	sse4_2_pcmpistrm, sse4_2_pcmpistr_cconly): Override prefix_data16
	and length_immediate to 1.
	(sse4_1_blendvp<ssemodesuffixf2c>): Override prefix_data16 to 1.
	(sse4_1_mpsadbw, sse4_1_pblendw): Override length_immediate to 1.
	(*avx_packusdw, avx_vtestp<avxmodesuffixf2c><avxmodesuffix>,
	avx_ptest256): Override prefix_extra to 1.
	(sse4_1_roundp<ssemodesuffixf2c>, sse4_1_rounds<ssemodesuffixf2c>):
	Override prefix_data16 and length_immediate to 1.
	(sse5_pperm_zero_v16qi_v8hi, sse5_pperm_sign_v16qi_v8hi,
	sse5_pperm_zero_v8hi_v4si, sse5_pperm_sign_v8hi_v4si,
	sse5_pperm_zero_v4si_v2di, sse5_pperm_sign_v4si_v2di,
	sse5_vrotl<mode>3, sse5_ashl<mode>3, sse5_lshl<mode>3): Override
	prefix_data16 to 0 and prefix_extra to 2.
	(sse5_rotl<mode>3, sse5_rotr<mode>3): Override length_immediate to 1.
	(sse5_frcz<mode>2, sse5_vmfrcz<mode>2): Don't override prefix_extra
	attribute.
	(*sse5_vmmaskcmp<mode>3, sse5_com_tf<mode>3,
	sse5_maskcmp<mode>3, sse5_maskcmp<mode>3, sse5_maskcmp_uns<mode>3):
	Override prefix_data16 and prefix_rep to 0, length_immediate to 1
	and prefix_extra to 2.
	(sse5_maskcmp_uns2<mode>3, sse5_pcom_tf<mode>3): Override
	prefix_data16 to 0, length_immediate to 1 and prefix_extra to 2.
	(*avx_aesenc, *avx_aesenclast, *avx_aesdec, *avx_aesdeclast,
	avx_vpermilvar<mode>3,
	avx_vbroadcasts<avxmodesuffixf2c><avxmodesuffix>,
	avx_vbroadcastss256, avx_vbroadcastf128_p<avxmodesuffixf2c>256,
	avx_maskloadp<avxmodesuffixf2c><avxmodesuffix>,
	avx_maskstorep<avxmodesuffixf2c><avxmodesuffix>):
	Override prefix_extra to 1.
	(aeskeygenassist, pclmulqdq): Override length_immediate to 1.
	(*vpclmulqdq, avx_vpermil<mode>, avx_vperm2f128<mode>3,
	vec_set_lo_<mode>, vec_set_hi_<mode>, vec_set_lo_v16hi,
	vec_set_hi_v16hi, vec_set_lo_v32qi, vec_set_hi_v32qi): Override
	prefix_extra and length_immediate to 1.
	(*avx_vzeroall, avx_vzeroupper, avx_vzeroupper_rex64): Override
	modrm to 0.
	(*vec_concat<mode>_avx): Override prefix_extra and length_immediate
	to 1 for the first alternative.
	* config/i386/mmx.md (*mov<mode>_internal_rex64): Override
	prefix_rep, prefix_data16 and/or prefix_rex attributes in certain
	cases.
	(*mov<mode>_internal_avx, *movv2sf_internal_rex64,
	*movv2sf_internal_avx, *movv2sf_internal): Override
	prefix_rep attribute for certain alternatives.
	(*mov<mode>_internal): Override prefix_rep or prefix_data16
	attributes for certain alternatives.
	(*movv2sf_internal_rex64_avx): Override prefix_rep and length_vex
	attributes for certain alternatives.
	(*mmx_addv2sf3, *mmx_subv2sf3, *mmx_mulv2sf3,
	*mmx_<code>v2sf3_finite, *mmx_<code>v2sf3, mmx_rcpv2sf2,
	mmx_rcpit1v2sf3, mmx_rcpit2v2sf3, mmx_rsqrtv2sf2, mmx_rsqit1v2sf3,
	mmx_haddv2sf3, mmx_hsubv2sf3, mmx_addsubv2sf3,
	*mmx_eqv2sf3, mmx_gtv2sf3, mmx_gev2sf3, mmx_pf2id, mmx_pf2iw,
	mmx_pi2fw, mmx_floatv2si2, mmx_pswapdv2sf2, *mmx_pmulhrwv4hi3,
	mmx_pswapdv2si2): Set prefix_extra attribute to 1.
	(mmx_ashr<mode>3, mmx_lshr<mode>3, mmx_ashl<mode>3): Set
	length_immediate to 1 if operand 2 is const_int_operand.
	(*mmx_pinsrw, mmx_pextrw, mmx_pshufw_1, *vec_dupv4hi,
	*vec_extractv2si_1): Set length_immediate
	attribute to 1.
	(*mmx_uavgv8qi3): Override prefix_extra attribute to 1 if
	using old 3DNOW insn rather than SSE/3DNOW_A.
	(mmx_emms, mmx_femms): Clear modrm attribute.

2009-05-21  Jakub Jelinek  <jakub@redhat.com>

	* config/i386/i386.c (memory_address_length): Handle %r12
	the same as %rsp and %r13 the same as %rbp.  For %rsp and %rbp
	also check REGNO.
	(ix86_attr_length_address_default): For MODE_SI lea in 64-bit
	mode look through optional ZERO_EXTEND and SUBREG.
	* config/i386/i386.md (R12_REG): New define_constant.
	(prefix_data16): For sse unit set also for MODE_TI insns.
	(prefix_rex): For -m32 always return 0.  For TYPE_IMOVX
	insns set if operand 1 is ext_QIreg_operand.
	(modrm): For TYPE_IMOV clear only if not MODE_DI.  For
	TYPE_{ALU{,1},ICMP,TEST} insn clear if there is non-shortened
	immediate.
	(*movdi_extzv_1, zero_extendhidi2, zero_extendqidi2): Change
	mode from MODE_DI to MODE_SI.
	(movdi_1_rex64): Override modrm and length_immediate attributes
	only for movabs (TYPE_IMOV, alternative 2).
	(zero_extendsidi2_rex64): Clear prefix_0f attribute if TYPE_IMOVX.
	(*float<SSEMODEI24:mode><MODEF:mode>2_mixed_interunit,
	*float<SSEMODEI24:mode><MODEF:mode>2_mixed_nointerunit,
	*float<SSEMODEI24:mode><MODEF:mode>2_sse_interunit,
	*float<SSEMODEI24:mode><MODEF:mode>2_sse_nointerunit): Set
	prefix_rex attribute if DImode.
	(*adddi_1_rex64, *adddi_2_rex64, *adddi_3_rex64, *adddi_5_rex64,
	*addsi_1, *addsi_1_zext, *addsi_2, *addsi_2_zext, *addsi_3,
	*addsi_3_zext, *addsi_5, *addhi_1_lea, *addhi_1, *addhi_2, *addhi_3,
	*addhi_5, *addqi_1_lea, *addqi_1): Override length_immediate
	attribute to 1 if TYPE_ALU and operand 2 is const128_operand.
	(pro_epilogue_adjust_stack_1, pro_epilogue_adjust_stack_rex64):
	Likewise.  For TYPE_IMOV clear length_immediate attribute.
	(*ashldi3_1_rex64, *ashldi3_cmp_rex64, *ashldi3_cconly_rex64,
	*ashlsi3_1, *ashlsi3_1_zext, *ashlsi3_cmp, **ashlsi3_cconly,
	*ashlsi3_cmp_zext, *ashlhi3_1_lea, *ashlhi3_1, *ashlhi3_cmp,
	*ashlhi3_cconly, *ashlqi3_1_lea, *ashlqi3_1, *ashlqi3_cmp,
	*ashlqi3_cconly): Override length_immediate attribute to 0 if TYPE_ALU
	or one operand TYPE_ISHIFT.
	(*ashrdi3_1_one_bit_rex64, *ashrdi3_one_bit_cmp_rex64,
	*ashrdi3_one_bit_cconly_rex64, *ashrsi3_1_one_bit,
	*ashrsi3_1_one_bit_zext, *ashrsi3_one_bit_cmp,
	*ashrsi3_one_bit_cconly, *ashrsi3_one_bit_cmp_zext,
	*ashrhi3_1_one_bit, *ashrhi3_one_bit_cmp, *ashrhi3_one_bit_cconly,
	*ashrqi3_1_one_bit, *ashrqi3_1_one_bit_slp, *ashrqi3_one_bit_cmp,
	*ashrqi3_one_bit_cconly, *lshrdi3_1_one_bit_rex64,
	*lshrdi3_cmp_one_bit_rex64, *lshrdi3_cconly_one_bit_rex64,
	*lshrsi3_1_one_bit, *lshrsi3_1_one_bit_zext, *lshrsi3_one_bit_cmp,
	*lshrsi3_one_bit_cconly, *lshrsi3_cmp_one_bit_zext,
	*lshrhi3_1_one_bit, *lshrhi3_one_bit_cmp, *lshrhi3_one_bit_cconly,
	*lshrqi3_1_one_bit, *lshrqi3_1_one_bit_slp, *lshrqi2_one_bit_cmp,
	*lshrqi2_one_bit_cconly, *rotlsi3_1_one_bit_rex64, *rotlsi3_1_one_bit,
	*rotlsi3_1_one_bit_zext, *rotlhi3_1_one_bit, *rotlqi3_1_one_bit_slp,
	*rotlqi3_1_one_bit, *rotrdi3_1_one_bit_rex64, *rotrsi3_1_one_bit,
	*rotrsi3_1_one_bit_zext, *rotrhi3_one_bit, *rotrqi3_1_one_bit,
	*rotrqi3_1_one_bit_slp): Override length_immediate attribute to 0,
	set mode attribute, don't override length attribute.
	(*btsq, *btrq, *btcq, *btdi_rex64, *btsi): Set prefix_0f attribute
	to 1.
	(return_internal_long): Set length attribute to 2 instead of 1.
	(*strmovqi_rex_1, *strsetqi_rex_1, *rep_stosqi_rex64,
	*cmpstrnqi_nz_rex_1, *cmpstrnqi_rex_1, *strlenqi_rex_1): Clear
	prefix_rex attribute.
	* config/i386/predicates.md (ext_QIreg_operand,
	const128_operand): New predicates.
	(memory_displacement_only_operand): Always return 0 for
	TARGET_64BIT.

2009-05-21  Jakub Jelinek  <jakub@redhat.com>

	* config/i386/i386.md (adddi_4_rex64, addsi_4, addhi_4): For
	operand2 -128 override length_immediate attribute to 1.
	* config/i386/predicates.md (constm128_operand): New predicate.

2009-05-18  H.J. Lu  <hongjiu.lu@intel.com>

	PR target/39942
	* config/i386/i386.c (ix86_avoid_jump_misspredicts): Replace
	gen_align with gen_pad.
	(ix86_reorg): Check ASM_OUTPUT_MAX_SKIP_PAD instead of
	#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN.

	* config/i386/i386.h (ASM_OUTPUT_MAX_SKIP_PAD): New.
	* config/i386/x86-64.h (ASM_OUTPUT_MAX_SKIP_PAD): Likewise.

	* config/i386/i386.md (align): Renamed to ...
	(pad): This.  Replace ASM_OUTPUT_MAX_SKIP_ALIGN with
	ASM_OUTPUT_MAX_SKIP_PAD.

2009-05-16  Jakub Jelinek  <jakub@redhat.com>
 
 	PR target/39942
	* final.c (label_to_max_skip): New function.
	(label_to_alignment): Only use LABEL_TO_ALIGNMENT if
	CODE_LABEL_NUMBER <= max_labelno.
	* output.h (label_to_max_skip): New prototype.
	* config/i386/i386.c (ix86_avoid_jump_misspredicts): Renamed to...
	(ix86_avoid_jump_mispredicts): ... this.  Don't define if
	ASM_OUTPUT_MAX_SKIP_ALIGN isn't defined.  Update comment.
	Handle CODE_LABELs with >= 16 byte alignment or with
	max_skip == (1 << align) - 1.
	(ix86_reorg): Don't call ix86_avoid_jump_mispredicts if
	ASM_OUTPUT_MAX_SKIP_ALIGN isn't defined.

2009-05-15  H.J. Lu  <hongjiu.lu@intel.com>

	* config/i386/i386.c (ix86_reorg): Call optimize_function_for_speed_p
	only once.

--- gcc/final.c.jj	2009-06-09 10:21:18.000000000 +0200
+++ gcc/final.c	2009-06-09 10:46:09.000000000 +0200
@@ -553,7 +553,17 @@ static int min_labelno, max_labelno;
 int
 label_to_alignment (rtx label)
 {
-  return LABEL_TO_ALIGNMENT (label);
+  if (CODE_LABEL_NUMBER (label) <= max_labelno)
+    return LABEL_TO_ALIGNMENT (label);
+  return 0;
+}
+
+int
+label_to_max_skip (rtx label)
+{
+  if (CODE_LABEL_NUMBER (label) <= max_labelno)
+    return LABEL_TO_MAX_SKIP (label);
+  return 0;
 }
 
 #ifdef HAVE_ATTR_length
--- gcc/config/i386/i386.c.jj	2009-06-09 10:24:35.000000000 +0200
+++ gcc/config/i386/i386.c	2009-06-09 12:10:01.000000000 +0200
@@ -8884,6 +8884,10 @@ ix86_decompose_address (rtx addr, struct
   base_reg = base && GET_CODE (base) == SUBREG ? SUBREG_REG (base) : base;
   index_reg = index && GET_CODE (index) == SUBREG ? SUBREG_REG (index) : index;
 
+  /* Avoid useless 0 displacement.  */
+  if (disp == const0_rtx && (base || index))
+    disp = NULL_RTX;
+
   /* Allow arg pointer and stack pointer as index if there is not scaling.  */
   if (base_reg && index_reg && scale == 1
       && (index_reg == arg_pointer_rtx
@@ -8895,10 +8899,16 @@ ix86_decompose_address (rtx addr, struct
       tmp = base_reg, base_reg = index_reg, index_reg = tmp;
     }
 
-  /* Special case: %ebp cannot be encoded as a base without a displacement.  */
-  if ((base_reg == hard_frame_pointer_rtx
-       || base_reg == frame_pointer_rtx
-       || base_reg == arg_pointer_rtx) && !disp)
+  /* Special case: %ebp cannot be encoded as a base without a displacement.
+     Similarly %r13.  */
+  if (!disp
+      && base_reg
+      && (base_reg == hard_frame_pointer_rtx
+	  || base_reg == frame_pointer_rtx
+	  || base_reg == arg_pointer_rtx
+	  || (REG_P (base_reg)
+	      && (REGNO (base_reg) == HARD_FRAME_POINTER_REGNUM
+		  || REGNO (base_reg) == R13_REG))))
     disp = const0_rtx;
 
   /* Special case: on K6, [%esi] makes the instruction vector decoded.
@@ -8912,7 +8922,7 @@ ix86_decompose_address (rtx addr, struct
     disp = const0_rtx;
 
   /* Special case: encode reg+reg instead of reg*2.  */
-  if (!base && index && scale && scale == 2)
+  if (!base && index && scale == 2)
     base = index, base_reg = index_reg, scale = 1;
 
   /* Special case: scaling cannot be encoded without base or displacement.  */
@@ -19240,23 +19250,53 @@ memory_address_length (rtx addr)
 
   /* Rule of thumb:
        - esp as the base always wants an index,
-       - ebp as the base always wants a displacement.  */
+       - ebp as the base always wants a displacement,
+       - r12 as the base always wants an index,
+       - r13 as the base always wants a displacement.  */
 
   /* Register Indirect.  */
   if (base && !index && !disp)
     {
       /* esp (for its index) and ebp (for its displacement) need
-	 the two-byte modrm form.  */
-      if (addr == stack_pointer_rtx
-	  || addr == arg_pointer_rtx
-	  || addr == frame_pointer_rtx
-	  || addr == hard_frame_pointer_rtx)
+	 the two-byte modrm form.  Similarly for r12 and r13 in 64-bit
+	 code.  */
+      if (REG_P (addr)
+	  && (addr == arg_pointer_rtx
+	      || addr == frame_pointer_rtx
+	      || REGNO (addr) == SP_REG
+	      || REGNO (addr) == BP_REG
+	      || REGNO (addr) == R12_REG
+	      || REGNO (addr) == R13_REG))
 	len = 1;
     }
 
-  /* Direct Addressing.  */
+  /* Direct Addressing.  In 64-bit mode mod 00 r/m 5
+     is not disp32, but disp32(%rip), so for disp32
+     SIB byte is needed, unless print_operand_address
+     optimizes it into disp32(%rip) or (%rip) is implied
+     by UNSPEC.  */
   else if (disp && !base && !index)
-    len = 4;
+    {
+      len = 4;
+      if (TARGET_64BIT)
+	{
+	  rtx symbol = disp;
+
+	  if (GET_CODE (disp) == CONST)
+	    symbol = XEXP (disp, 0);
+	  if (GET_CODE (symbol) == PLUS
+	      && CONST_INT_P (XEXP (symbol, 1)))
+	    symbol = XEXP (symbol, 0);
+
+	  if (GET_CODE (symbol) != LABEL_REF
+	      && (GET_CODE (symbol) != SYMBOL_REF
+		  || SYMBOL_REF_TLS_MODEL (symbol) != 0)
+	      && (GET_CODE (symbol) != UNSPEC
+		  || (XINT (symbol, 1) != UNSPEC_GOTPCREL
+		      && XINT (symbol, 1) != UNSPEC_GOTNTPOFF)))
+	    len += 1;
+	}
+    }
 
   else
     {
@@ -19268,19 +19308,31 @@ memory_address_length (rtx addr)
 	  else
 	    len = 4;
 	}
-      /* ebp always wants a displacement.  */
-      else if (base == hard_frame_pointer_rtx)
-        len = 1;
+      /* ebp always wants a displacement.  Similarly r13.  */
+      else if (REG_P (base)
+	       && (REGNO (base) == BP_REG || REGNO (base) == R13_REG))
+	len = 1;
 
       /* An index requires the two-byte modrm form....  */
       if (index
-	  /* ...like esp, which always wants an index.  */
-	  || base == stack_pointer_rtx
+	  /* ...like esp (or r12), which always wants an index.  */
 	  || base == arg_pointer_rtx
-	  || base == frame_pointer_rtx)
+	  || base == frame_pointer_rtx
+	  || (REG_P (base)
+	      && (REGNO (base) == SP_REG || REGNO (base) == R12_REG)))
 	len += 1;
     }
 
+  switch (parts.seg)
+    {
+    case SEG_FS:
+    case SEG_GS:
+      len += 1;
+      break;
+    default:
+      break;
+    }
+
   return len;
 }
 
@@ -19295,30 +19347,50 @@ ix86_attr_length_immediate_default (rtx 
   for (i = recog_data.n_operands - 1; i >= 0; --i)
     if (CONSTANT_P (recog_data.operand[i]))
       {
+        enum attr_mode mode = get_attr_mode (insn);
+
 	gcc_assert (!len);
-	if (shortform && satisfies_constraint_K (recog_data.operand[i]))
-	  len = 1;
-	else
+	if (shortform && CONST_INT_P (recog_data.operand[i]))
 	  {
-	    switch (get_attr_mode (insn))
+	    HOST_WIDE_INT ival = INTVAL (recog_data.operand[i]);
+	    switch (mode)
 	      {
-		case MODE_QI:
-		  len+=1;
-		  break;
-		case MODE_HI:
-		  len+=2;
-		  break;
-		case MODE_SI:
-		  len+=4;
-		  break;
-		/* Immediates for DImode instructions are encoded as 32bit sign extended values.  */
-		case MODE_DI:
-		  len+=4;
-		  break;
-		default:
-		  fatal_insn ("unknown insn mode", insn);
+	      case MODE_QI:
+		len = 1;
+		continue;
+	      case MODE_HI:
+		ival = trunc_int_for_mode (ival, HImode);
+		break;
+	      case MODE_SI:
+		ival = trunc_int_for_mode (ival, SImode);
+		break;
+	      default:
+		break;
+	      }
+	    if (IN_RANGE (ival, -128, 127))
+	      {
+		len = 1;
+		continue;
 	      }
 	  }
+	switch (mode)
+	  {
+	  case MODE_QI:
+	    len = 1;
+	    break;
+	  case MODE_HI:
+	    len = 2;
+	    break;
+	  case MODE_SI:
+	    len = 4;
+	    break;
+	  /* Immediates for DImode instructions are encoded as 32bit sign extended values.  */
+	  case MODE_DI:
+	    len = 4;
+	    break;
+	  default:
+	    fatal_insn ("unknown insn mode", insn);
+	}
       }
   return len;
 }
@@ -19330,22 +19402,45 @@ ix86_attr_length_address_default (rtx in
 
   if (get_attr_type (insn) == TYPE_LEA)
     {
-      rtx set = PATTERN (insn);
+      rtx set = PATTERN (insn), addr;
 
       if (GET_CODE (set) == PARALLEL)
 	set = XVECEXP (set, 0, 0);
 
       gcc_assert (GET_CODE (set) == SET);
 
-      return memory_address_length (SET_SRC (set));
+      addr = SET_SRC (set);
+      if (TARGET_64BIT && get_attr_mode (insn) == MODE_SI)
+	{
+	  if (GET_CODE (addr) == ZERO_EXTEND)
+	    addr = XEXP (addr, 0);
+	  if (GET_CODE (addr) == SUBREG)
+	    addr = SUBREG_REG (addr);
+	}
+
+      return memory_address_length (addr);
     }
 
   extract_insn_cached (insn);
   for (i = recog_data.n_operands - 1; i >= 0; --i)
     if (MEM_P (recog_data.operand[i]))
       {
+        constrain_operands_cached (reload_completed);
+        if (which_alternative != -1)
+	  {
+	    const char *constraints = recog_data.constraints[i];
+	    int alt = which_alternative;
+
+	    while (*constraints == '=' || *constraints == '+')
+	      constraints++;
+	    while (alt-- > 0)
+	      while (*constraints++ != ',')
+		;
+	    /* Skip ignored operands.  */
+	    if (*constraints == 'X')
+	      continue;
+	  }
 	return memory_address_length (XEXP (recog_data.operand[i], 0));
-	break;
       }
   return 0;
 }
@@ -19374,7 +19469,8 @@ ix86_attr_length_vex_default (rtx insn, 
     if (REG_P (recog_data.operand[i]))
       {
 	/* REX.W bit uses 3 byte VEX prefix.  */
-	if (GET_MODE (recog_data.operand[i]) == DImode)
+	if (GET_MODE (recog_data.operand[i]) == DImode
+	    && GENERAL_REG_P (recog_data.operand[i]))
 	  return 3 + 1;
       }
     else
@@ -27112,6 +27208,7 @@ x86_function_profiler (FILE *file, int l
     }
 }
 
+#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN
 /* We don't have exact information about the insn sizes, but we may assume
    quite safely that we are informed about all 1 byte insns and memory
    address sizes.  This is enough to eliminate unnecessary padding in
@@ -27162,7 +27259,7 @@ min_insn_size (rtx insn)
    window.  */
 
 static void
-ix86_avoid_jump_misspredicts (void)
+ix86_avoid_jump_mispredicts (void)
 {
   rtx insn, start = get_insns ();
   int nbytes = 0, njumps = 0;
@@ -27176,15 +27273,52 @@ ix86_avoid_jump_misspredicts (void)
 
      The smallest offset in the page INSN can start is the case where START
      ends on the offset 0.  Offset of INSN is then NBYTES - sizeof (INSN).
-     We add p2align to 16byte window with maxskip 17 - NBYTES + sizeof (INSN).
+     We add p2align to 16byte window with maxskip 15 - NBYTES + sizeof (INSN).
      */
-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+  for (insn = start; insn; insn = NEXT_INSN (insn))
     {
+      int min_size;
+
+      if (GET_CODE (insn) == CODE_LABEL)
+	{
+	  int align = label_to_alignment (insn);
+	  int max_skip = label_to_max_skip (insn);
 
-      nbytes += min_insn_size (insn);
+	  if (max_skip > 15)
+	    max_skip = 15;
+	  /* If align > 3, only up to 16 - max_skip - 1 bytes can be
+	     already in the current 16 byte page, because otherwise
+	     ASM_OUTPUT_MAX_SKIP_ALIGN could skip max_skip or fewer
+	     bytes to reach 16 byte boundary.  */
+	  if (align <= 0
+	      || (align <= 3 && max_skip != (1 << align) - 1))
+	    max_skip = 0;
+	  if (dump_file)
+	    fprintf (dump_file, "Label %i with max_skip %i\n",
+		     INSN_UID (insn), max_skip);
+	  if (max_skip)
+	    {
+	      while (nbytes + max_skip >= 16)
+		{
+		  start = NEXT_INSN (start);
+		  if ((JUMP_P (start)
+		       && GET_CODE (PATTERN (start)) != ADDR_VEC
+		       && GET_CODE (PATTERN (start)) != ADDR_DIFF_VEC)
+		      || CALL_P (start))
+		    njumps--, isjump = 1;
+		  else
+		    isjump = 0;
+		  nbytes -= min_insn_size (start);
+		}
+	    }
+	  continue;
+	}
+
+      min_size = min_insn_size (insn);
+      nbytes += min_size;
       if (dump_file)
-        fprintf(dump_file, "Insn %i estimated to %i bytes\n",
-		INSN_UID (insn), min_insn_size (insn));
+	fprintf (dump_file, "Insn %i estimated to %i bytes\n",
+		 INSN_UID (insn), min_size);
       if ((JUMP_P (insn)
 	   && GET_CODE (PATTERN (insn)) != ADDR_VEC
 	   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)
@@ -27208,7 +27342,7 @@ ix86_avoid_jump_misspredicts (void)
       gcc_assert (njumps >= 0);
       if (dump_file)
         fprintf (dump_file, "Interval %i to %i has %i bytes\n",
-		INSN_UID (start), INSN_UID (insn), nbytes);
+		 INSN_UID (start), INSN_UID (insn), nbytes);
 
       if (njumps == 3 && isjump && nbytes < 16)
 	{
@@ -27217,10 +27351,11 @@ ix86_avoid_jump_misspredicts (void)
 	  if (dump_file)
 	    fprintf (dump_file, "Padding insn %i by %i bytes!\n",
 		     INSN_UID (insn), padsize);
-          emit_insn_before (gen_align (GEN_INT (padsize)), insn);
+          emit_insn_before (gen_pad (GEN_INT (padsize)), insn);
 	}
     }
 }
+#endif
 
 /* AMD Athlon works faster
    when RET is not destination of conditional jump or directly preceded
@@ -27280,12 +27415,15 @@ ix86_pad_returns (void)
 static void
 ix86_reorg (void)
 {
-  if (TARGET_PAD_RETURNS && optimize
-      && optimize_function_for_speed_p (cfun))
-    ix86_pad_returns ();
-  if (TARGET_FOUR_JUMP_LIMIT && optimize
-      && optimize_function_for_speed_p (cfun))
-    ix86_avoid_jump_misspredicts ();
+  if (optimize && optimize_function_for_speed_p (cfun))
+    {
+      if (TARGET_PAD_RETURNS)
+	ix86_pad_returns ();
+#ifdef ASM_OUTPUT_MAX_SKIP_PAD
+      if (TARGET_FOUR_JUMP_LIMIT)
+	ix86_avoid_jump_mispredicts ();
+#endif
+    }
 }
 
 /* Return nonzero when QImode register that must be represented via REX prefix
--- gcc/config/i386/predicates.md.jj	2009-03-13 15:50:39.000000000 +0100
+++ gcc/config/i386/predicates.md	2009-06-09 11:46:52.000000000 +0200
@@ -76,6 +76,20 @@ (define_predicate "flags_reg_operand"
   (and (match_code "reg")
        (match_test "REGNO (op) == FLAGS_REG")))
 
+;; Return true if op is a QImode register operand other than
+;; %[abcd][hl].
+(define_predicate "ext_QIreg_operand"
+  (and (match_code "reg")
+       (match_test "TARGET_64BIT
+		    && GET_MODE (op) == QImode
+		    && REGNO (op) > BX_REG")))
+
+;; Similarly, but don't check mode of the operand.
+(define_predicate "ext_QIreg_nomode_operand"
+  (and (match_code "reg")
+       (match_test "TARGET_64BIT
+		    && REGNO (op) > BX_REG")))
+
 ;; Return true if op is not xmm0 register.
 (define_predicate "reg_not_xmm0_operand"
    (and (match_operand 0 "register_operand")
@@ -574,6 +588,11 @@ (define_predicate "const8_operand"
   (and (match_code "const_int")
        (match_test "INTVAL (op) == 8")))
 
+;; Match exactly 128.
+(define_predicate "const128_operand"
+  (and (match_code "const_int")
+       (match_test "INTVAL (op) == 128")))
+
 ;; Match 2, 4, or 8.  Used for leal multiplicands.
 (define_predicate "const248_operand"
   (match_code "const_int")
@@ -878,6 +897,9 @@ (define_predicate "memory_displacement_o
   struct ix86_address parts;
   int ok;
 
+  if (TARGET_64BIT)
+    return 0;
+
   ok = ix86_decompose_address (XEXP (op, 0), &parts);
   gcc_assert (ok);
 
--- gcc/config/i386/mmx.md.jj	2009-03-04 12:12:58.000000000 +0100
+++ gcc/config/i386/mmx.md	2009-06-09 11:46:52.000000000 +0200
@@ -1,5 +1,5 @@
 ;; GCC machine description for MMX and 3dNOW! instructions
-;; Copyright (C) 2005, 2007, 2008
+;; Copyright (C) 2005, 2007, 2008, 2009
 ;; Free Software Foundation, Inc.
 ;;
 ;; This file is part of GCC.
@@ -85,6 +85,12 @@ (define_insn "*mov<mode>_internal_rex64"
     %vmovq\t{%1, %0|%0, %1}"
   [(set_attr "type" "imov,imov,mmx,mmxmov,mmxmov,ssecvt,ssecvt,sselog1,ssemov,ssemov,ssemov,ssemov")
    (set_attr "unit" "*,*,*,*,*,mmx,mmx,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,*,*,1,1,*,1,*,*,*")
+   (set_attr "prefix_data16" "*,*,*,*,*,*,*,*,*,1,1,1")
+   (set (attr "prefix_rex")
+     (if_then_else (eq_attr "alternative" "8,9")
+       (symbol_ref "x86_extended_reg_mentioned_p (insn)")
+       (const_string "*")))
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "7,8,9,10,11")
        (const_string "maybe_vex")
@@ -111,6 +117,7 @@ (define_insn "*mov<mode>_internal_avx"
     #"
   [(set_attr "type" "mmx,mmxmov,mmxmov,ssecvt,ssecvt,sselog1,ssemov,ssemov,*,*")
    (set_attr "unit" "*,*,*,mmx,mmx,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,1,1,*,*,*,*,*")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "5,6,7")
        (const_string "vex")
@@ -141,6 +148,8 @@ (define_insn "*mov<mode>_internal"
     #"
   [(set_attr "type" "mmx,mmxmov,mmxmov,ssecvt,ssecvt,sselog1,ssemov,ssemov,sselog1,ssemov,ssemov,ssemov,*,*")
    (set_attr "unit" "*,*,*,mmx,mmx,*,*,*,*,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,1,1,*,1,*,*,*,*,*,*,*")
+   (set_attr "prefix_data16" "*,*,*,*,*,*,*,1,*,*,*,*,*,*")
    (set_attr "mode" "DI,DI,DI,DI,DI,TI,DI,DI,V4SF,V4SF,V2SF,V2SF,DI,DI")])
 
 (define_expand "movv2sf"
@@ -175,6 +184,8 @@ (define_insn "*movv2sf_internal_rex64_av
     vmovq\t{%1, %0|%0, %1}"
   [(set_attr "type" "imov,imov,mmx,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,sselog1,ssemov,ssemov,ssemov,ssemov")
    (set_attr "unit" "*,*,*,*,*,mmx,mmx,*,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,*,*,1,1,*,*,*,*,*,*")
+   (set_attr "length_vex" "*,*,*,*,*,*,*,*,*,*,*,4,4")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "7,8,9,10,11,12")
        (const_string "vex")
@@ -204,6 +215,7 @@ (define_insn "*movv2sf_internal_rex64"
     movd\t{%1, %0|%0, %1}"
   [(set_attr "type" "imov,imov,mmx,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,sselog1,ssemov,ssemov,ssemov,ssemov")
    (set_attr "unit" "*,*,*,*,*,mmx,mmx,*,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,*,*,1,1,*,*,*,*,*,*")
    (set_attr "mode" "DI,DI,DI,DI,DI,DI,DI,V4SF,V4SF,V2SF,V2SF,DI,DI")])
 
 (define_insn "*movv2sf_internal_avx"
@@ -227,6 +239,7 @@ (define_insn "*movv2sf_internal_avx"
     #"
   [(set_attr "type" "mmx,mmxmov,mmxmov,ssecvt,ssecvt,sselog1,ssemov,ssemov,ssemov,*,*")
    (set_attr "unit" "*,*,*,mmx,mmx,*,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,1,1,*,*,*,*,*,*")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "5,6,7,8")
        (const_string "vex")
@@ -254,6 +267,7 @@ (define_insn "*movv2sf_internal"
     #"
   [(set_attr "type" "mmx,mmxmov,mmxmov,ssecvt,ssecvt,sselog1,ssemov,ssemov,ssemov,*,*")
    (set_attr "unit" "*,*,*,mmx,mmx,*,*,*,*,*,*")
+   (set_attr "prefix_rep" "*,*,*,1,1,*,*,*,*,*,*")
    (set_attr "mode" "DI,DI,DI,DI,DI,V4SF,V4SF,V2SF,V2SF,DI,DI")])
 
 ;; %%% This multiword shite has got to go.
@@ -313,6 +327,7 @@ (define_insn "*mmx_addv2sf3"
   "TARGET_3DNOW && ix86_binary_operator_ok (PLUS, V2SFmode, operands)"
   "pfadd\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_expand "mmx_subv2sf3"
@@ -338,6 +353,7 @@ (define_insn "*mmx_subv2sf3"
    pfsub\t{%2, %0|%0, %2}
    pfsubr\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_expand "mmx_mulv2sf3"
@@ -354,6 +370,7 @@ (define_insn "*mmx_mulv2sf3"
   "TARGET_3DNOW && ix86_binary_operator_ok (MULT, V2SFmode, operands)"
   "pfmul\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxmul")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 ;; ??? For !flag_finite_math_only, the representation with SMIN/SMAX
@@ -381,6 +398,7 @@ (define_insn "*mmx_<code>v2sf3_finite"
    && ix86_binary_operator_ok (<CODE>, V2SFmode, operands)"
   "pf<maxminfprefix>\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "*mmx_<code>v2sf3"
@@ -391,6 +409,7 @@ (define_insn "*mmx_<code>v2sf3"
   "TARGET_3DNOW"
   "pf<maxminfprefix>\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_rcpv2sf2"
@@ -400,6 +419,7 @@ (define_insn "mmx_rcpv2sf2"
   "TARGET_3DNOW"
   "pfrcp\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmx")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_rcpit1v2sf3"
@@ -410,6 +430,7 @@ (define_insn "mmx_rcpit1v2sf3"
   "TARGET_3DNOW"
   "pfrcpit1\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmx")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_rcpit2v2sf3"
@@ -420,6 +441,7 @@ (define_insn "mmx_rcpit2v2sf3"
   "TARGET_3DNOW"
   "pfrcpit2\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmx")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_rsqrtv2sf2"
@@ -429,6 +451,7 @@ (define_insn "mmx_rsqrtv2sf2"
   "TARGET_3DNOW"
   "pfrsqrt\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmx")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_rsqit1v2sf3"
@@ -439,6 +462,7 @@ (define_insn "mmx_rsqit1v2sf3"
   "TARGET_3DNOW"
   "pfrsqit1\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmx")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_haddv2sf3"
@@ -457,6 +481,7 @@ (define_insn "mmx_haddv2sf3"
   "TARGET_3DNOW"
   "pfacc\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_hsubv2sf3"
@@ -475,6 +500,7 @@ (define_insn "mmx_hsubv2sf3"
   "TARGET_3DNOW_A"
   "pfnacc\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_addsubv2sf3"
@@ -488,6 +514,7 @@ (define_insn "mmx_addsubv2sf3"
   "TARGET_3DNOW_A"
   "pfpnacc\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -510,6 +537,7 @@ (define_insn "*mmx_eqv2sf3"
   "TARGET_3DNOW && ix86_binary_operator_ok (EQ, V2SFmode, operands)"
   "pfcmpeq\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxcmp")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_gtv2sf3"
@@ -519,6 +547,7 @@ (define_insn "mmx_gtv2sf3"
   "TARGET_3DNOW"
   "pfcmpgt\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxcmp")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_gev2sf3"
@@ -528,6 +557,7 @@ (define_insn "mmx_gev2sf3"
   "TARGET_3DNOW"
   "pfcmpge\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxcmp")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -542,6 +572,7 @@ (define_insn "mmx_pf2id"
   "TARGET_3DNOW"
   "pf2id\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_pf2iw"
@@ -553,6 +584,7 @@ (define_insn "mmx_pf2iw"
   "TARGET_3DNOW_A"
   "pf2iw\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_pi2fw"
@@ -564,6 +596,7 @@ (define_insn "mmx_pi2fw"
   "TARGET_3DNOW_A"
   "pi2fw\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "mmx_floatv2si2"
@@ -572,6 +605,7 @@ (define_insn "mmx_floatv2si2"
   "TARGET_3DNOW"
   "pi2fd\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -587,6 +621,7 @@ (define_insn "mmx_pswapdv2sf2"
   "TARGET_3DNOW_A"
   "pswapd\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "V2SF")])
 
 (define_insn "*vec_dupv2sf"
@@ -887,6 +922,7 @@ (define_insn "*mmx_pmulhrwv4hi3"
   "TARGET_3DNOW && ix86_binary_operator_ok (MULT, V4HImode, operands)"
   "pmulhrw\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxmul")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
 (define_expand "sse2_umulv1siv1di3"
@@ -965,6 +1001,10 @@ (define_insn "mmx_ashr<mode>3"
   "TARGET_MMX"
   "psra<mmxvecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxshft")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "DI")])
 
 (define_insn "mmx_lshr<mode>3"
@@ -975,6 +1015,10 @@ (define_insn "mmx_lshr<mode>3"
   "TARGET_MMX"
   "psrl<mmxvecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxshft")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "DI")])
 
 (define_insn "mmx_ashl<mode>3"
@@ -985,6 +1029,10 @@ (define_insn "mmx_ashl<mode>3"
   "TARGET_MMX"
   "psll<mmxvecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "mmxshft")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "DI")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -1205,6 +1253,7 @@ (define_insn "*mmx_pinsrw"
   return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "mmxcvt")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "DI")])
 
 (define_insn "mmx_pextrw"
@@ -1216,6 +1265,7 @@ (define_insn "mmx_pextrw"
   "TARGET_SSE || TARGET_3DNOW_A"
   "pextrw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "DI")])
 
 (define_expand "mmx_pshufw"
@@ -1253,6 +1303,7 @@ (define_insn "mmx_pshufw_1"
   return "pshufw\t{%2, %1, %0|%0, %1, %2}";
 }
   [(set_attr "type" "mmxcvt")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "DI")])
 
 (define_insn "mmx_pswapdv2si2"
@@ -1263,6 +1314,7 @@ (define_insn "mmx_pswapdv2si2"
   "TARGET_3DNOW_A"
   "pswapd\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
 (define_insn "*vec_dupv4hi"
@@ -1273,6 +1325,7 @@ (define_insn "*vec_dupv4hi"
   "TARGET_SSE || TARGET_3DNOW_A"
   "pshufw\t{$0, %0, %0|%0, %0, 0}"
   [(set_attr "type" "mmxcvt")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "DI")])
 
 (define_insn "*vec_dupv2si"
@@ -1345,6 +1398,7 @@ (define_insn "*vec_extractv2si_1"
    #
    #"
   [(set_attr "type" "mmxcvt,sselog1,sselog1,sselog1,mmxmov,ssemov,imov")
+   (set_attr "length_immediate" "*,*,1,*,*,*,*")
    (set_attr "mode" "DI,TI,TI,V4SF,SI,SI,SI")])
 
 (define_split
@@ -1492,6 +1546,11 @@ (define_insn "*mmx_uavgv8qi3"
     return "pavgusb\t{%2, %0|%0, %2}";
 }
   [(set_attr "type" "mmxshft")
+   (set (attr "prefix_extra")
+     (if_then_else
+       (eq (symbol_ref "(TARGET_SSE || TARGET_3DNOW_A)") (const_int 0))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "mode" "DI")])
 
 (define_expand "mmx_uavgv4hi3"
@@ -1602,6 +1661,7 @@ (define_insn "mmx_emms"
   "TARGET_MMX"
   "emms"
   [(set_attr "type" "mmx")
+   (set_attr "modrm" "0")
    (set_attr "memory" "unknown")])
 
 (define_insn "mmx_femms"
@@ -1625,4 +1685,5 @@ (define_insn "mmx_femms"
   "TARGET_3DNOW"
   "femms"
   [(set_attr "type" "mmx")
+   (set_attr "modrm" "0")
    (set_attr "memory" "none")])
--- gcc/config/i386/sse.md.jj	2009-06-09 10:21:38.000000000 +0200
+++ gcc/config/i386/sse.md	2009-06-09 11:46:53.000000000 +0200
@@ -439,6 +439,7 @@ (define_insn "sse2_movntsi"
   "TARGET_SSE2"
   "movnti\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_data16" "0")
    (set_attr "mode" "V2DF")])
 
 (define_insn "avx_lddqu<avxmodesuffix>"
@@ -461,6 +462,7 @@ (define_insn "sse3_lddqu"
   "lddqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "movu" "1")
+   (set_attr "prefix_data16" "0")
    (set_attr "prefix_rep" "1")
    (set_attr "mode" "TI")])
 
@@ -1409,6 +1411,7 @@ (define_insn "avx_cmpp<avxmodesuffixf2c>
   "TARGET_AVX"
   "vcmpp<avxmodesuffixf2c>\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssecmp")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -1425,6 +1428,7 @@ (define_insn "avx_cmps<ssemodesuffixf2c>
   "TARGET_AVX"
   "vcmps<ssemodesuffixf2c>\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssecmp")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<ssescalarmode>")])
 
@@ -1439,6 +1443,7 @@ (define_insn "*avx_maskcmp<mode>3"
   "vcmp%D3p<avxmodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "ssecmp")
    (set_attr "prefix" "vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<avxvecmode>")])
 
 (define_insn "<sse>_maskcmp<mode>3"
@@ -1450,6 +1455,7 @@ (define_insn "<sse>_maskcmp<mode>3"
    && !TARGET_SSE5"
   "cmp%D3<ssemodesuffixf4>\t{%2, %0|%0, %2}"
   [(set_attr "type" "ssecmp")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "<sse>_vmmaskcmp<mode>3"
@@ -1463,6 +1469,7 @@ (define_insn "<sse>_vmmaskcmp<mode>3"
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode) && !TARGET_SSE5"
   "cmp%D3s<ssemodesuffixf2c>\t{%2, %0|%0, %2}"
   [(set_attr "type" "ssecmp")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<ssescalarmode>")])
 
 (define_insn "<sse>_comi"
@@ -1478,6 +1485,11 @@ (define_insn "<sse>_comi"
   "%vcomis<ssemodefsuffix>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecomi")
    (set_attr "prefix" "maybe_vex")
+   (set_attr "prefix_rep" "0")
+   (set (attr "prefix_data16")
+	(if_then_else (eq_attr "mode" "DF")
+		      (const_string "1")
+		      (const_string "0")))
    (set_attr "mode" "<MODE>")])
 
 (define_insn "<sse>_ucomi"
@@ -1493,6 +1505,11 @@ (define_insn "<sse>_ucomi"
   "%vucomis<ssemodefsuffix>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecomi")
    (set_attr "prefix" "maybe_vex")
+   (set_attr "prefix_rep" "0")
+   (set (attr "prefix_data16")
+	(if_then_else (eq_attr "mode" "DF")
+		      (const_string "1")
+		      (const_string "0")))
    (set_attr "mode" "<MODE>")])
 
 (define_expand "vcond<mode>"
@@ -2224,6 +2241,7 @@ (define_insn "sse_cvttps2pi"
   "cvttps2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
    (set_attr "unit" "mmx")
+   (set_attr "prefix_rep" "0")
    (set_attr "mode" "SF")])
 
 (define_insn "*avx_cvtsi2ss"
@@ -2263,6 +2281,7 @@ (define_insn "*avx_cvtsi2ssq"
   "TARGET_AVX && TARGET_64BIT"
   "vcvtsi2ssq\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseicvt")
+   (set_attr "length_vex" "4")
    (set_attr "prefix" "vex")
    (set_attr "mode" "SF")])
 
@@ -2276,6 +2295,7 @@ (define_insn "sse_cvtsi2ssq"
   "TARGET_SSE && TARGET_64BIT"
   "cvtsi2ssq\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseicvt")
+   (set_attr "prefix_rex" "1")
    (set_attr "athlon_decode" "vector,double")
    (set_attr "amdfam10_decode" "vector,double")
    (set_attr "mode" "SF")])
@@ -2422,6 +2442,7 @@ (define_insn "sse2_cvttps2dq"
   "cvttps2dq\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
    (set_attr "prefix_rep" "1")
+   (set_attr "prefix_data16" "0")
    (set_attr "mode" "TI")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -2437,6 +2458,7 @@ (define_insn "sse2_cvtpi2pd"
   "cvtpi2pd\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
    (set_attr "unit" "mmx,*")
+   (set_attr "prefix_data16" "1,*")
    (set_attr "mode" "V2DF")])
 
 (define_insn "sse2_cvtpd2pi"
@@ -2497,6 +2519,7 @@ (define_insn "*avx_cvtsi2sdq"
   "TARGET_AVX && TARGET_64BIT"
   "vcvtsi2sdq\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseicvt")
+   (set_attr "length_vex" "4")
    (set_attr "prefix" "vex")
    (set_attr "mode" "DF")])
 
@@ -2510,6 +2533,7 @@ (define_insn "sse2_cvtsi2sdq"
   "TARGET_SSE2 && TARGET_64BIT"
   "cvtsi2sdq\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseicvt")
+   (set_attr "prefix_rex" "1")
    (set_attr "mode" "DF")
    (set_attr "athlon_decode" "double,direct")
    (set_attr "amdfam10_decode" "vector,double")])
@@ -2651,6 +2675,7 @@ (define_insn "*sse2_cvtpd2dq"
 		       : \"cvtpd2dq\t{%1, %0|%0, %1}\";"
   [(set_attr "type" "ssecvt")
    (set_attr "prefix_rep" "1")
+   (set_attr "prefix_data16" "0")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")
    (set_attr "amdfam10_decode" "double")])
@@ -2681,7 +2706,6 @@ (define_insn "*sse2_cvttpd2dq"
   "* return TARGET_AVX ? \"vcvttpd2dq{x}\t{%1, %0|%0, %1}\"
 		       : \"cvttpd2dq\t{%1, %0|%0, %1}\";"
   [(set_attr "type" "ssecvt")
-   (set_attr "prefix_rep" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")
    (set_attr "amdfam10_decode" "double")])
@@ -2800,6 +2824,7 @@ (define_insn "sse2_cvtps2pd"
   [(set_attr "type" "ssecvt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V2DF")
+   (set_attr "prefix_data16" "0")
    (set_attr "amdfam10_decode" "direct")])
 
 (define_expand "vec_unpacks_hi_v4sf"
@@ -3270,6 +3295,7 @@ (define_insn "avx_shufps256_1"
   return "vshufps\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -3311,6 +3337,7 @@ (define_insn "*avx_shufps_<mode>"
   return "vshufps\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4SF")])
 
@@ -3336,6 +3363,7 @@ (define_insn "sse_shufps_<mode>"
   return "shufps\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "V4SF")])
 
 (define_insn "sse_storehps"
@@ -3443,6 +3471,7 @@ (define_insn "*avx_loadlps"
    vmovlps\t{%2, %1, %0|%0, %1, %2}
    vmovlps\t{%2, %0|%0, %2}"
   [(set_attr "type" "sselog,ssemov,ssemov")
+   (set_attr "length_immediate" "1,*,*")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4SF,V2SF,V2SF")])
 
@@ -3459,6 +3488,7 @@ (define_insn "sse_loadlps"
    movlps\t{%2, %0|%0, %2}
    movlps\t{%2, %0|%0, %2}"
   [(set_attr "type" "sselog,ssemov,ssemov")
+   (set_attr "length_immediate" "1,*,*")
    (set_attr "mode" "V4SF,V2SF,V2SF")])
 
 (define_insn "*avx_movss"
@@ -3491,6 +3521,7 @@ (define_insn "*vec_dupv4sf_avx"
   "TARGET_AVX"
   "vshufps\t{$0, %1, %1, %0|%0, %1, %1, 0}"
   [(set_attr "type" "sselog1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4SF")])
 
@@ -3501,6 +3532,7 @@ (define_insn "*vec_dupv4sf"
   "TARGET_SSE"
   "shufps\t{$0, %0, %0|%0, %0, 0}"
   [(set_attr "type" "sselog1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "V4SF")])
 
 (define_insn "*vec_concatv2sf_avx"
@@ -3516,6 +3548,8 @@ (define_insn "*vec_concatv2sf_avx"
    punpckldq\t{%2, %0|%0, %2}
    movd\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog,sselog,ssemov,mmxcvt,mmxmov")
+   (set_attr "length_immediate" "*,1,*,*,*")
+   (set_attr "prefix_extra" "*,1,*,*,*")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "3,4")
        (const_string "orig")
@@ -3537,7 +3571,9 @@ (define_insn "*vec_concatv2sf_sse4_1"
    punpckldq\t{%2, %0|%0, %2}
    movd\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog,sselog,ssemov,mmxcvt,mmxmov")
+   (set_attr "prefix_data16" "*,1,*,*,*")
    (set_attr "prefix_extra" "*,1,*,*,*")
+   (set_attr "length_immediate" "*,1,*,*,*")
    (set_attr "mode" "V4SF,V4SF,SF,DI,DI")])
 
 ;; ??? In theory we can match memory for the MMX alternative, but allowing
@@ -3638,6 +3674,8 @@ (define_insn "*vec_setv4sf_avx"
   return "vinsertps\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4SF")])
 
@@ -3654,7 +3692,9 @@ (define_insn "*vec_setv4sf_sse4_1"
   return "insertps\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "V4SF")])
 
 (define_insn "*avx_insertps"
@@ -3667,6 +3707,8 @@ (define_insn "*avx_insertps"
   "vinsertps\t{%3, %2, %1, %0|%0, %1, %2, %3}";
   [(set_attr "type" "sselog")
    (set_attr "prefix" "vex")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "V4SF")])
 
 (define_insn "sse4_1_insertps"
@@ -3678,7 +3720,9 @@ (define_insn "sse4_1_insertps"
   "TARGET_SSE4_1"
   "insertps\t{%3, %2, %0|%0, %2, %3}";
   [(set_attr "type" "sselog")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "V4SF")])
 
 (define_split
@@ -3753,6 +3797,8 @@ (define_insn "vec_extract_lo_<mode>"
   "TARGET_AVX"
   "vextractf128\t{$0x0, %1, %0|%0, %1, 0x0}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3765,6 +3811,8 @@ (define_insn "vec_extract_hi_<mode>"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3778,6 +3826,8 @@ (define_insn "vec_extract_lo_<mode>"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3791,6 +3841,8 @@ (define_insn "vec_extract_hi_<mode>"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3806,6 +3858,8 @@ (define_insn "vec_extract_lo_v16hi"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3821,6 +3875,8 @@ (define_insn "vec_extract_hi_v16hi"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3840,6 +3896,8 @@ (define_insn "vec_extract_lo_v32qi"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3859,6 +3917,8 @@ (define_insn "vec_extract_hi_v32qi"
   "TARGET_AVX"
   "vextractf128\t{$0x1, %1, %0|%0, %1, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,store")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
@@ -3871,7 +3931,9 @@ (define_insn "*sse4_1_extractps"
   "TARGET_SSE4_1"
   "%vextractps\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V4SF")])
 
@@ -3964,6 +4026,7 @@ (define_insn "sse2_unpckhpd"
    movlpd\t{%H1, %0|%0, %H1}
    movhpd\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog,ssemov,ssemov")
+   (set_attr "prefix_data16" "*,1,1")
    (set_attr "mode" "V2DF,V1DF,V1DF")])
 
 (define_insn "avx_movddup256"
@@ -4084,6 +4147,7 @@ (define_insn "sse2_unpcklpd"
    movhpd\t{%2, %0|%0, %2}
    movlpd\t{%2, %H0|%H0, %2}"
   [(set_attr "type" "sselog,ssemov,ssemov")
+   (set_attr "prefix_data16" "*,1,1")
    (set_attr "mode" "V2DF,V1DF,V1DF")])
 
 (define_expand "avx_shufpd256"
@@ -4124,6 +4188,7 @@ (define_insn "avx_shufpd256_1"
   return "vshufpd\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4DF")])
 
@@ -4260,6 +4325,7 @@ (define_insn "*avx_shufpd_<mode>"
   return "vshufpd\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V2DF")])
 
@@ -4281,6 +4347,7 @@ (define_insn "sse2_shufpd_<mode>"
   return "shufpd\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "V2DF")])
 
 ;; Avoid combining registers from different units in a single alternative,
@@ -4314,6 +4381,7 @@ (define_insn "sse2_storehpd"
    #
    #"
   [(set_attr "type" "ssemov,sselog1,ssemov,fmov,imov")
+   (set_attr "prefix_data16" "1,*,*,*,*")
    (set_attr "mode" "V1DF,V2DF,DF,DF,DF")])
 
 (define_split
@@ -4342,6 +4410,7 @@ (define_insn "sse2_storelpd"
    #
    #"
   [(set_attr "type" "ssemov,ssemov,ssemov,fmov,imov")
+   (set_attr "prefix_data16" "1,*,*,*,*")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V1DF,DF,DF,DF,DF")])
 
@@ -4408,6 +4477,8 @@ (define_insn "sse2_loadhpd"
    #
    #"
   [(set_attr "type" "ssemov,sselog,sselog,ssemov,fmov,imov")
+   (set_attr "prefix_data16" "1,*,*,*,*,*")
+   (set_attr "length_immediate" "*,*,1,*,*,*")
    (set_attr "mode" "V1DF,V2DF,V2DF,DF,DF,DF")])
 
 (define_split
@@ -4471,6 +4542,8 @@ (define_insn "sse2_loadlpd"
    #
    #"
   [(set_attr "type" "ssemov,ssemov,ssemov,sselog,ssemov,ssemov,fmov,imov")
+   (set_attr "prefix_data16" "*,1,*,*,1,*,*,*")
+   (set_attr "length_immediate" "*,*,*,1,*,*,*,*")
    (set_attr "mode" "DF,V1DF,V1DF,V2DF,V1DF,DF,DF,DF")])
 
 (define_split
@@ -4546,6 +4619,8 @@ (define_insn "sse2_movsd"
    movhps\t{%H1, %0|%0, %H1}
    movhps\t{%1, %H0|%H0, %1}"
   [(set_attr "type" "ssemov,ssemov,ssemov,sselog,ssemov,ssemov")
+   (set_attr "prefix_data16" "*,1,1,*,*,*")
+   (set_attr "length_immediate" "*,*,*,1,*,*")
    (set_attr "mode" "DF,V1DF,V1DF,V2DF,V1DF,V1DF")])
 
 (define_insn "*vec_dupv2df_sse3"
@@ -4605,6 +4680,7 @@ (define_insn "*vec_concatv2df"
    movlhps\t{%2, %0|%0, %2}
    movhps\t{%2, %0|%0, %2}"
   [(set_attr "type" "sselog,ssemov,ssemov,ssemov,ssemov")
+   (set_attr "prefix_data16" "*,1,*,*,*")
    (set_attr "mode" "V2DF,V1DF,DF,V4SF,V2SF")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -4953,6 +5029,7 @@ (define_insn "*avx_mulv2siv2di3"
   "TARGET_AVX && ix86_binary_operator_ok (MULT, V4SImode, operands)"
   "vpmuldq\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseimul")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -5099,6 +5176,7 @@ (define_insn "*avx_mulv4si3"
   "TARGET_AVX && ix86_binary_operator_ok (MULT, V4SImode, operands)"
   "vpmulld\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseimul")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -5494,6 +5572,10 @@ (define_insn "*avx_ashr<mode>3"
   "vpsra<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
    (set_attr "prefix" "vex")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "TI")])
 
 (define_insn "ashr<mode>3"
@@ -5505,6 +5587,10 @@ (define_insn "ashr<mode>3"
   "psra<ssevecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseishft")
    (set_attr "prefix_data16" "1")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "TI")])
 
 (define_insn "*avx_lshr<mode>3"
@@ -5516,6 +5602,10 @@ (define_insn "*avx_lshr<mode>3"
   "vpsrl<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
    (set_attr "prefix" "vex")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "TI")])
 
 (define_insn "lshr<mode>3"
@@ -5527,6 +5617,10 @@ (define_insn "lshr<mode>3"
   "psrl<ssevecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseishft")
    (set_attr "prefix_data16" "1")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "TI")])
 
 (define_insn "*avx_ashl<mode>3"
@@ -5538,6 +5632,10 @@ (define_insn "*avx_ashl<mode>3"
   "vpsll<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
    (set_attr "prefix" "vex")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "TI")])
 
 (define_insn "ashl<mode>3"
@@ -5549,6 +5647,10 @@ (define_insn "ashl<mode>3"
   "psll<ssevecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseishft")
    (set_attr "prefix_data16" "1")
+   (set (attr "length_immediate")
+     (if_then_else (match_operand 2 "const_int_operand" "")
+       (const_string "1")
+       (const_string "0")))
    (set_attr "mode" "TI")])
 
 (define_expand "vec_shl_<mode>"
@@ -5579,6 +5681,12 @@ (define_insn "*avx_<code><mode>3"
   "TARGET_AVX && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
   "vp<maxminiprefix><ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set (attr "prefix_extra")
+     (if_then_else
+       (ne (symbol_ref "<MODE>mode != ((<CODE> == SMAX || <CODE> == SMIN) ? V8HImode : V16QImode)")
+	   (const_int 0))
+       (const_string "1")
+       (const_string "0")))
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -5783,6 +5891,10 @@ (define_insn "*avx_eq<mode>3"
   "TARGET_AVX && ix86_binary_operator_ok (EQ, <MODE>mode, operands)"
   "vpcmpeq<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "ssecmp")
+   (set (attr "prefix_extra")
+     (if_then_else (match_operand:V2DI 0 "" "")
+       (const_string "1")
+       (const_string "*")))
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -5825,6 +5937,10 @@ (define_insn "*avx_gt<mode>3"
   "TARGET_AVX"
   "vpcmpgt<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "ssecmp")
+   (set (attr "prefix_extra")
+     (if_then_else (match_operand:V2DI 0 "" "")
+       (const_string "1")
+       (const_string "*")))
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -5847,6 +5963,7 @@ (define_insn "sse4_2_gtv2di3"
   "TARGET_SSE4_2"
   "pcmpgtq\t{%2, %0|%0, %2}"
   [(set_attr "type" "ssecmp")
+   (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
 
 (define_expand "vcond<mode>"
@@ -6605,6 +6722,11 @@ (define_insn "*avx_pinsr<avxmodesuffixs>
   return "vpinsr<avxmodesuffixs>\t{%3, %k2, %1, %0|%0, %1, %k2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set (attr "prefix_extra")
+     (if_then_else (match_operand:V8HI 0 "register_operand" "")
+       (const_string "0")
+       (const_string "1")))
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -6622,6 +6744,7 @@ (define_insn "*sse4_1_pinsrb"
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*sse2_pinsrw"
@@ -6638,6 +6761,7 @@ (define_insn "*sse2_pinsrw"
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 ;; It must come before sse2_loadld since it is preferred.
@@ -6655,6 +6779,7 @@ (define_insn "*sse4_1_pinsrd"
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*avx_pinsrq"
@@ -6670,6 +6795,8 @@ (define_insn "*avx_pinsrq"
   return "vpinsrq\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -6686,7 +6813,9 @@ (define_insn "*sse4_1_pinsrq"
   return "pinsrq\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "prefix_rex" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*sse4_1_pextrb"
@@ -6699,6 +6828,7 @@ (define_insn "*sse4_1_pextrb"
   "%vpextrb\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -6711,6 +6841,7 @@ (define_insn "*sse4_1_pextrb_memory"
   "%vpextrb\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -6724,6 +6855,7 @@ (define_insn "*sse2_pextrw"
   "%vpextrw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -6736,6 +6868,7 @@ (define_insn "*sse4_1_pextrw_memory"
   "%vpextrw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -6748,6 +6881,7 @@ (define_insn "*sse4_1_pextrd"
   "%vpextrd\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -6760,7 +6894,9 @@ (define_insn "*sse4_1_pextrq"
   "TARGET_SSE4_1 && TARGET_64BIT"
   "%vpextrq\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_rex" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -6800,7 +6936,8 @@ (define_insn "sse2_pshufd_1"
 }
   [(set_attr "type" "sselog1")
    (set_attr "prefix_data16" "1")
-   (set_attr "prefix" "vex")
+   (set_attr "prefix" "maybe_vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_expand "sse2_pshuflw"
@@ -6842,8 +6979,10 @@ (define_insn "sse2_pshuflw_1"
   return "%vpshuflw\t{%2, %1, %0|%0, %1, %2}";
 }
   [(set_attr "type" "sselog")
+   (set_attr "prefix_data16" "0")
    (set_attr "prefix_rep" "1")
    (set_attr "prefix" "maybe_vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_expand "sse2_pshufhw"
@@ -6886,7 +7025,9 @@ (define_insn "sse2_pshufhw_1"
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_rep" "1")
+   (set_attr "prefix_data16" "0")
    (set_attr "prefix" "maybe_vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_expand "sse2_loadd"
@@ -7022,6 +7163,7 @@ (define_insn "*vec_extractv2di_1_rex64_a
    vmovq\t{%H1, %0|%0, %H1}
    vmov{q}\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov,imov")
+   (set_attr "length_immediate" "*,1,*,*")
    (set_attr "memory" "*,none,*,*")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V2SF,TI,TI,DI")])
@@ -7038,6 +7180,7 @@ (define_insn "*vec_extractv2di_1_rex64"
    movq\t{%H1, %0|%0, %H1}
    mov{q}\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov,imov")
+   (set_attr "length_immediate" "*,1,*,*")
    (set_attr "atom_unit" "*,sishuf,*,*")
    (set_attr "memory" "*,none,*,*")
    (set_attr "mode" "V2SF,TI,TI,DI")])
@@ -7055,6 +7198,7 @@ (define_insn "*vec_extractv2di_1_avx"
    vpsrldq\t{$8, %1, %0|%0, %1, 8}
    vmovq\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov")
+   (set_attr "length_immediate" "*,1,*")
    (set_attr "memory" "*,none,*")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V2SF,TI,TI")])
@@ -7071,6 +7215,7 @@ (define_insn "*vec_extractv2di_1_sse2"
    psrldq\t{$8, %0|%0, 8}
    movq\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov")
+   (set_attr "length_immediate" "*,1,*")
    (set_attr "atom_unit" "*,sishuf,*")
    (set_attr "memory" "*,none,*")
    (set_attr "mode" "V2SF,TI,TI")])
@@ -7100,6 +7245,7 @@ (define_insn "*vec_dupv4si"
    shufps\t{$0, %0, %0|%0, %0, 0}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix" "maybe_vex,orig")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI,V4SF")])
 
 (define_insn "*vec_dupv2di_avx"
@@ -7136,6 +7282,8 @@ (define_insn "*vec_concatv2si_avx"
    punpckldq\t{%2, %0|%0, %2}
    movd\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog,sselog,ssemov,mmxcvt,mmxmov")
+   (set_attr "prefix_extra" "1,*,*,*,*")
+   (set_attr "length_immediate" "1,*,*,*,*")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "3,4")
        (const_string "orig")
@@ -7156,6 +7304,7 @@ (define_insn "*vec_concatv2si_sse4_1"
    movd\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog,sselog,ssemov,mmxcvt,mmxmov")
    (set_attr "prefix_extra" "1,*,*,*,*")
+   (set_attr "length_immediate" "1,*,*,*,*")
    (set_attr "mode" "TI,TI,TI,DI,DI")])
 
 ;; ??? In theory we can match memory for the MMX alternative, but allowing
@@ -7262,6 +7411,8 @@ (define_insn "*vec_concatv2di_rex64_avx"
    vpunpcklqdq\t{%2, %1, %0|%0, %1, %2}
    vmovhps\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog,ssemov,ssemov,ssemov,sselog,ssemov")
+   (set_attr "prefix_extra" "1,*,*,*,*,*")
+   (set_attr "length_immediate" "1,*,*,*,*,*")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "3")
        (const_string "orig")
@@ -7283,7 +7434,9 @@ (define_insn "*vec_concatv2di_rex64_sse4
    movlhps\t{%2, %0|%0, %2}
    movhps\t{%2, %0|%0, %2}"
   [(set_attr "type" "sselog,ssemov,ssemov,ssemov,sselog,ssemov,ssemov")
+   (set_attr "prefix_rex" "1,*,1,*,*,*,*")
    (set_attr "prefix_extra" "1,*,*,*,*,*,*")
+   (set_attr "length_immediate" "1,*,*,*,*,*,*")
    (set_attr "mode" "TI,TI,TI,TI,TI,V4SF,V2SF")])
 
 (define_insn "*vec_concatv2di_rex64_sse"
@@ -7300,6 +7453,7 @@ (define_insn "*vec_concatv2di_rex64_sse"
    movlhps\t{%2, %0|%0, %2}
    movhps\t{%2, %0|%0, %2}"
   [(set_attr "type" "ssemov,ssemov,ssemov,sselog,ssemov,ssemov")
+   (set_attr "prefix_rex" "*,1,*,*,*,*")
    (set_attr "mode" "TI,TI,TI,TI,V4SF,V2SF")])
 
 (define_expand "vec_unpacku_hi_v16qi"
@@ -7686,6 +7840,8 @@ (define_insn "*sse2_maskmovdqu"
   "%vmaskmovdqu\t{%2, %1|%1, %2}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
+   ;; The implicit %rdi operand confuses default length_vex computation.
+   (set_attr "length_vex" "3")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -7700,6 +7856,9 @@ (define_insn "*sse2_maskmovdqu_rex64"
   "%vmaskmovdqu\t{%2, %1|%1, %2}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
+   ;; The implicit %rdi operand confuses default length_vex computation.
+   (set (attr "length_vex")
+     (symbol_ref ("REGNO (operands[2]) >= FIRST_REX_SSE_REG ? 3 + 1 : 2 + 1")))
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -7738,6 +7897,7 @@ (define_insn "*sse_sfence"
   "TARGET_SSE || TARGET_3DNOW_A"
   "sfence"
   [(set_attr "type" "sse")
+   (set_attr "length_address" "0")
    (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
@@ -7765,6 +7925,7 @@ (define_insn "*sse2_mfence"
   "TARGET_64BIT || TARGET_SSE2"
   "mfence"
   [(set_attr "type" "sse")
+   (set_attr "length_address" "0")
    (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
@@ -7783,6 +7944,7 @@ (define_insn "*sse2_lfence"
   "TARGET_SSE2"
   "lfence"
   [(set_attr "type" "sse")
+   (set_attr "length_address" "0")
    (set_attr "atom_sse_attr" "lfence")
    (set_attr "memory" "unknown")])
 
@@ -7864,6 +8026,7 @@ (define_insn "*avx_phaddwv8hi3"
   "TARGET_AVX"
   "vphaddw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -7938,6 +8101,7 @@ (define_insn "ssse3_phaddwv4hi3"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_phadddv4si3"
@@ -7964,6 +8128,7 @@ (define_insn "*avx_phadddv4si3"
   "TARGET_AVX"
   "vphaddd\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8014,6 +8179,7 @@ (define_insn "ssse3_phadddv2si3"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_phaddswv8hi3"
@@ -8056,6 +8222,7 @@ (define_insn "*avx_phaddswv8hi3"
   "TARGET_AVX"
   "vphaddsw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8130,6 +8297,7 @@ (define_insn "ssse3_phaddswv4hi3"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_phsubwv8hi3"
@@ -8172,6 +8340,7 @@ (define_insn "*avx_phsubwv8hi3"
   "TARGET_AVX"
   "vphsubw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8246,6 +8415,7 @@ (define_insn "ssse3_phsubwv4hi3"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_phsubdv4si3"
@@ -8272,6 +8442,7 @@ (define_insn "*avx_phsubdv4si3"
   "TARGET_AVX"
   "vphsubd\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8322,6 +8493,7 @@ (define_insn "ssse3_phsubdv2si3"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_phsubswv8hi3"
@@ -8364,6 +8536,7 @@ (define_insn "*avx_phsubswv8hi3"
   "TARGET_AVX"
   "vphsubsw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8438,6 +8611,7 @@ (define_insn "ssse3_phsubswv4hi3"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_pmaddubsw128"
@@ -8490,6 +8664,7 @@ (define_insn "*avx_pmaddubsw128"
   "TARGET_AVX"
   "vpmaddubsw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8584,6 +8759,7 @@ (define_insn "ssse3_pmaddubsw"
   [(set_attr "type" "sseiadd")
    (set_attr "atom_unit" "simul")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_expand "ssse3_pmulhrswv8hi3"
@@ -8626,6 +8802,7 @@ (define_insn "*avx_pmulhrswv8hi3"
   "TARGET_AVX && ix86_binary_operator_ok (MULT, V8HImode, operands)"
   "vpmulhrsw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseimul")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8690,6 +8867,7 @@ (define_insn "*ssse3_pmulhrswv4hi3"
   "pmulhrsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseimul")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_pshufbv16qi3"
@@ -8700,6 +8878,7 @@ (define_insn "*avx_pshufbv16qi3"
   "TARGET_AVX"
   "vpshufb\t{%2, %1, %0|%0, %1, %2}";
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8724,6 +8903,7 @@ (define_insn "ssse3_pshufbv8qi3"
   "pshufb\t{%2, %0|%0, %2}";
   [(set_attr "type" "sselog1")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_psign<mode>3"
@@ -8735,6 +8915,7 @@ (define_insn "*avx_psign<mode>3"
   "TARGET_AVX"
   "vpsign<ssevecsize>\t{%2, %1, %0|%0, %1, %2}";
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8761,6 +8942,7 @@ (define_insn "ssse3_psign<mode>3"
   "psign<mmxvecsize>\t{%2, %0|%0, %2}";
   [(set_attr "type" "sselog1")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "*avx_palignrti"
@@ -8775,6 +8957,8 @@ (define_insn "*avx_palignrti"
   return "vpalignr\t{%3, %2, %1, %0|%0, %1, %2, %3}";
 }
   [(set_attr "type" "sseishft")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -8793,6 +8977,7 @@ (define_insn "ssse3_palignrti"
    (set_attr "atom_unit" "sishuf")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "ssse3_palignrdi"
@@ -8809,6 +8994,8 @@ (define_insn "ssse3_palignrdi"
   [(set_attr "type" "sseishft")
    (set_attr "atom_unit" "sishuf")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 (define_insn "abs<mode>2"
@@ -8828,7 +9015,9 @@ (define_insn "abs<mode>2"
   "TARGET_SSSE3"
   "pabs<mmxvecsize>\t{%1, %0|%0, %1}";
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_rep" "0")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_rex") (symbol_ref "x86_extended_reg_mentioned_p (insn)"))
    (set_attr "mode" "DI")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -8869,6 +9058,7 @@ (define_insn "sse4a_extrqi"
   "extrq\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "sse")
    (set_attr "prefix_data16" "1")
+   (set_attr "length_immediate" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse4a_extrq"
@@ -8892,7 +9082,9 @@ (define_insn "sse4a_insertqi"
   "TARGET_SSE4A"
   "insertq\t{%4, %3, %2, %0|%0, %2, %3, %4}"
   [(set_attr "type" "sseins")
+   (set_attr "prefix_data16" "0")
    (set_attr "prefix_rep" "1")
+   (set_attr "length_immediate" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse4a_insertq"
@@ -8903,6 +9095,7 @@ (define_insn "sse4a_insertq"
   "TARGET_SSE4A"
   "insertq\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseins")
+   (set_attr "prefix_data16" "0")
    (set_attr "prefix_rep" "1")
    (set_attr "mode" "TI")])
 
@@ -8921,6 +9114,8 @@ (define_insn "avx_blendp<avxmodesuffixf2
   "TARGET_AVX"
   "vblendp<avxmodesuffixf2c>\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
@@ -8934,6 +9129,8 @@ (define_insn "avx_blendvp<avxmodesuffixf
   "TARGET_AVX"
   "vblendvp<avxmodesuffixf2c>\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
@@ -8946,7 +9143,9 @@ (define_insn "sse4_1_blendp<ssemodesuffi
   "TARGET_SSE4_1"
   "blendp<ssemodesuffixf2c>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "sse4_1_blendvp<ssemodesuffixf2c>"
@@ -8959,6 +9158,7 @@ (define_insn "sse4_1_blendvp<ssemodesuff
   "TARGET_SSE4_1"
   "blendvp<ssemodesuffixf2c>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "<MODE>")])
 
@@ -8973,6 +9173,8 @@ (define_insn "avx_dpp<avxmodesuffixf2c><
   "vdpp<avxmodesuffixf2c>\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssemul")
    (set_attr "prefix" "vex")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<avxvecmode>")])
 
 (define_insn "sse4_1_dpp<ssemodesuffixf2c>"
@@ -8985,7 +9187,9 @@ (define_insn "sse4_1_dpp<ssemodesuffixf2
   "TARGET_SSE4_1"
   "dpp<ssemodesuffixf2c>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssemul")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "sse4_1_movntdqa"
@@ -9009,6 +9213,8 @@ (define_insn "*avx_mpsadbw"
   "vmpsadbw\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix" "vex")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse4_1_mpsadbw"
@@ -9021,6 +9227,7 @@ (define_insn "sse4_1_mpsadbw"
   "mpsadbw\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*avx_packusdw"
@@ -9033,6 +9240,7 @@ (define_insn "*avx_packusdw"
   "TARGET_AVX"
   "vpackusdw\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -9058,6 +9266,8 @@ (define_insn "*avx_pblendvb"
   "TARGET_AVX"
   "vpblendvb\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -9083,6 +9293,8 @@ (define_insn "*avx_pblendw"
   "vpblendw\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse4_1_pblendw"
@@ -9095,6 +9307,7 @@ (define_insn "sse4_1_pblendw"
   "pblendw\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse4_1_phminposuw"
@@ -9506,6 +9719,7 @@ (define_insn "avx_vtestp<avxmodesuffixf2
   "TARGET_AVX"
   "vtestp<avxmodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecomi")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -9519,6 +9733,7 @@ (define_insn "avx_ptest256"
   "TARGET_AVX"
   "vptest\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecomi")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "OI")])
 
@@ -9543,6 +9758,8 @@ (define_insn "avx_roundp<avxmodesuffixf2
   "TARGET_AVX"
   "vroundp<avxmodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "ssecvt")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -9555,7 +9772,9 @@ (define_insn "sse4_1_roundp<ssemodesuffi
   "TARGET_ROUND"
   "%vroundp<ssemodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "ssecvt")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODE>")])
 
@@ -9571,6 +9790,8 @@ (define_insn "*avx_rounds<ssemodesuffixf
   "TARGET_AVX"
   "vrounds<ssemodesuffixf2c>\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "ssecvt")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -9586,7 +9807,9 @@ (define_insn "sse4_1_rounds<ssemodesuffi
   "TARGET_ROUND"
   "rounds<ssemodesuffixf2c>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssecvt")
+   (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -9648,6 +9871,7 @@ (define_insn_and_split "sse4_2_pcmpestr"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,load")
    (set_attr "mode" "TI")])
 
@@ -9674,6 +9898,7 @@ (define_insn "sse4_2_pcmpestri"
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "prefix" "maybe_vex")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,load")
    (set_attr "mode" "TI")])
 
@@ -9699,6 +9924,7 @@ (define_insn "sse4_2_pcmpestrm"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "none,load")
    (set_attr "mode" "TI")])
@@ -9723,6 +9949,7 @@ (define_insn "sse4_2_pcmpestr_cconly"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,load,none,load")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
@@ -9771,6 +9998,7 @@ (define_insn_and_split "sse4_2_pcmpistr"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,load")
    (set_attr "mode" "TI")])
 
@@ -9792,6 +10020,7 @@ (define_insn "sse4_2_pcmpistri"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "none,load")
    (set_attr "mode" "TI")])
@@ -9814,6 +10043,7 @@ (define_insn "sse4_2_pcmpistrm"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "none,load")
    (set_attr "mode" "TI")])
@@ -9836,6 +10066,7 @@ (define_insn "sse4_2_pcmpistr_cconly"
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "memory" "none,load,none,load")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
@@ -10834,6 +11065,8 @@ (define_insn "sse5_pperm_zero_v16qi_v8hi
        || register_operand (operands[2], V16QImode))"
   "pperm\t{%3, %1, %0, %0|%0, %0, %1, %3}"
   [(set_attr "type" "sseadd")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_pperm_sign_v16qi_v8hi"
@@ -10848,6 +11081,8 @@ (define_insn "sse5_pperm_sign_v16qi_v8hi
        || register_operand (operands[2], V16QImode))"
   "pperm\t{%3, %1, %0, %0|%0, %0, %1, %3}"
   [(set_attr "type" "sseadd")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_pperm_zero_v8hi_v4si"
@@ -10862,6 +11097,8 @@ (define_insn "sse5_pperm_zero_v8hi_v4si"
        || register_operand (operands[2], V16QImode))"
   "pperm\t{%3, %1, %0, %0|%0, %0, %1, %3}"
   [(set_attr "type" "sseadd")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_pperm_sign_v8hi_v4si"
@@ -10876,6 +11113,8 @@ (define_insn "sse5_pperm_sign_v8hi_v4si"
        || register_operand (operands[2], V16QImode))"
   "pperm\t{%3, %1, %0, %0|%0, %0, %1, %3}"
   [(set_attr "type" "sseadd")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_pperm_zero_v4si_v2di"
@@ -10890,6 +11129,8 @@ (define_insn "sse5_pperm_zero_v4si_v2di"
        || register_operand (operands[2], V16QImode))"
   "pperm\t{%3, %1, %0, %0|%0, %0, %1, %3}"
   [(set_attr "type" "sseadd")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_pperm_sign_v4si_v2di"
@@ -10904,6 +11145,8 @@ (define_insn "sse5_pperm_sign_v4si_v2di"
        || register_operand (operands[2], V16QImode))"
   "pperm\t{%3, %1, %0, %0|%0, %0, %1, %3}"
   [(set_attr "type" "sseadd")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 ;; SSE5 pack instructions that combine two vectors into a smaller vector
@@ -11032,6 +11275,7 @@ (define_insn "sse5_rotl<mode>3"
   "TARGET_SSE5"
   "prot<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_rotr<mode>3"
@@ -11045,6 +11289,7 @@ (define_insn "sse5_rotr<mode>3"
   return \"prot<ssevecsize>\t{%3, %1, %0|%0, %1, %3}\";
 }
   [(set_attr "type" "sseishft")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_expand "vrotr<mode>3"
@@ -11084,6 +11329,8 @@ (define_insn "sse5_vrotl<mode>3"
   "TARGET_SSE5 && ix86_sse5_valid_op_p (operands, insn, 3, true, 1, false)"
   "prot<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 ;; SSE5 packed shift instructions.
@@ -11137,6 +11384,8 @@ (define_insn "sse5_ashl<mode>3"
   "TARGET_SSE5 && ix86_sse5_valid_op_p (operands, insn, 3, true, 1, false)"
   "psha<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_lshl<mode>3"
@@ -11154,6 +11403,8 @@ (define_insn "sse5_lshl<mode>3"
   "TARGET_SSE5 && ix86_sse5_valid_op_p (operands, insn, 3, true, 1, false)"
   "pshl<ssevecsize>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sseishft")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
    (set_attr "mode" "TI")])
 
 ;; SSE2 doesn't have some shift varients, so define versions for SSE5
@@ -11267,7 +11518,6 @@ (define_insn "sse5_frcz<mode>2"
   "TARGET_SSE5"
   "frcz<ssemodesuffixf4>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt1")
-   (set_attr "prefix_extra" "1")
    (set_attr "mode" "<MODE>")])
 
 ;; scalar insns
@@ -11282,7 +11532,6 @@ (define_insn "sse5_vmfrcz<mode>2"
   "TARGET_SSE5"
   "frcz<ssemodesuffixf2s>\t{%2, %0|%0, %2}"
   [(set_attr "type" "ssecvt1")
-   (set_attr "prefix_extra" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "sse5_cvtph2ps"
@@ -11331,6 +11580,10 @@ (define_insn "*sse5_vmmaskcmp<mode>3"
   "TARGET_SSE5"
   "com%Y1<ssemodesuffixf2s>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "sse4arg")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_rep" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<ssescalarmode>")])
 
 ;; We don't have a comparison operator that always returns true/false, so
@@ -11371,6 +11624,10 @@ (define_insn "sse5_com_tf<mode>3"
   return ret;
 }
   [(set_attr "type" "ssecmp")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_rep" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "sse5_maskcmp<mode>3"
@@ -11381,6 +11638,10 @@ (define_insn "sse5_maskcmp<mode>3"
   "TARGET_SSE5"
   "com%Y1<ssemodesuffixf4>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssecmp")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_rep" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "sse5_maskcmp<mode>3"
@@ -11391,6 +11652,10 @@ (define_insn "sse5_maskcmp<mode>3"
   "TARGET_SSE5"
   "pcom%Y1<ssevecsize>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "sse4arg")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_rep" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse5_maskcmp_uns<mode>3"
@@ -11401,6 +11666,10 @@ (define_insn "sse5_maskcmp_uns<mode>3"
   "TARGET_SSE5"
   "pcom%Y1u<ssevecsize>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssecmp")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_rep" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 ;; Version of pcom*u* that is called from the intrinsics that allows pcomequ*
@@ -11416,6 +11685,9 @@ (define_insn "sse5_maskcmp_uns2<mode>3"
   "TARGET_SSE5"
   "pcom%Y1u<ssevecsize>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssecmp")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 ;; Pcomtrue and pcomfalse support.  These are useless instructions, but are
@@ -11434,6 +11706,9 @@ (define_insn "sse5_pcom_tf<mode>3"
 	  : "pcomfalse<ssevecsize>\t{%2, %1, %0|%0, %1, %2}");
 }
   [(set_attr "type" "ssecmp")
+   (set_attr "prefix_data16" "0")
+   (set_attr "prefix_extra" "2")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*avx_aesenc"
@@ -11444,6 +11719,7 @@ (define_insn "*avx_aesenc"
   "TARGET_AES && TARGET_AVX"
   "vaesenc\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -11466,6 +11742,7 @@ (define_insn "*avx_aesenclast"
   "TARGET_AES && TARGET_AVX"
   "vaesenclast\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -11488,6 +11765,7 @@ (define_insn "*avx_aesdec"
   "TARGET_AES && TARGET_AVX"
   "vaesdec\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -11510,6 +11788,7 @@ (define_insn "*avx_aesdeclast"
   "TARGET_AES && TARGET_AVX"
   "vaesdeclast\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -11544,6 +11823,7 @@ (define_insn "aeskeygenassist"
   "%vaeskeygenassist\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
@@ -11556,6 +11836,8 @@ (define_insn "*vpclmulqdq"
   "TARGET_PCLMUL && TARGET_AVX"
   "vpclmulqdq\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "TI")])
 
@@ -11569,6 +11851,7 @@ (define_insn "pclmulqdq"
   "pclmulqdq\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_expand "avx_vzeroall"
@@ -11599,6 +11882,7 @@ (define_insn "*avx_vzeroall"
   "TARGET_AVX"
   "vzeroall"
   [(set_attr "type" "sse")
+   (set_attr "modrm" "0")
    (set_attr "memory" "none")
    (set_attr "prefix" "vex")
    (set_attr "mode" "OI")])
@@ -11617,6 +11901,7 @@ (define_insn "avx_vzeroupper"
   "TARGET_AVX && !TARGET_64BIT"
   "vzeroupper"
   [(set_attr "type" "sse")
+   (set_attr "modrm" "0")
    (set_attr "memory" "none")
    (set_attr "prefix" "vex")
    (set_attr "mode" "OI")])
@@ -11642,6 +11927,7 @@ (define_insn "avx_vzeroupper_rex64"
   "TARGET_AVX && TARGET_64BIT"
   "vzeroupper"
   [(set_attr "type" "sse")
+   (set_attr "modrm" "0")
    (set_attr "memory" "none")
    (set_attr "prefix" "vex")
    (set_attr "mode" "OI")])
@@ -11655,6 +11941,8 @@ (define_insn "avx_vpermil<mode>"
   "TARGET_AVX"
   "vpermilp<avxmodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -11667,6 +11955,7 @@ (define_insn "avx_vpermilvar<mode>3"
   "TARGET_AVX"
   "vpermilp<avxmodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -11680,6 +11969,8 @@ (define_insn "avx_vperm2f128<mode>3"
   "TARGET_AVX"
   "vperm2f128\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11695,6 +11986,7 @@ (define_insn "avx_vbroadcasts<avxmodesuf
   "TARGET_AVX"
   "vbroadcasts<avxmodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxscalarmode>")])
 
@@ -11718,6 +12010,7 @@ (define_insn "avx_vbroadcastss256"
   "TARGET_AVX"
   "vbroadcastss\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "SF")])
 
@@ -11729,6 +12022,7 @@ (define_insn "avx_vbroadcastf128_p<avxmo
   "TARGET_AVX"
   "vbroadcastf128\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4SF")])
 
@@ -11765,6 +12059,8 @@ (define_insn "vec_set_lo_<mode>"
   "TARGET_AVX"
   "vinsertf128\t{$0x0, %2, %1, %0|%0, %1, %2, 0x0}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11778,6 +12074,8 @@ (define_insn "vec_set_hi_<mode>"
   "TARGET_AVX"
   "vinsertf128\t{$0x1, %2, %1, %0|%0, %1, %2, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11792,6 +12090,8 @@ (define_insn "vec_set_lo_<mode>"
   "TARGET_AVX"
   "vinsertf128\t{$0x0, %2, %1, %0|%0, %1, %2, 0x0}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11806,6 +12106,8 @@ (define_insn "vec_set_hi_<mode>"
   "TARGET_AVX"
   "vinsertf128\t{$0x1, %2, %1, %0|%0, %1, %2, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11822,6 +12124,8 @@ (define_insn "vec_set_lo_v16hi"
   "TARGET_AVX"
   "vinsertf128\t{$0x0, %2, %1, %0|%0, %1, %2, 0x0}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11838,6 +12142,8 @@ (define_insn "vec_set_hi_v16hi"
   "TARGET_AVX"
   "vinsertf128\t{$0x1, %2, %1, %0|%0, %1, %2, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11858,6 +12164,8 @@ (define_insn "vec_set_lo_v32qi"
   "TARGET_AVX"
   "vinsertf128\t{$0x0, %2, %1, %0|%0, %1, %2, 0x0}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11878,6 +12186,8 @@ (define_insn "vec_set_hi_v32qi"
   "TARGET_AVX"
   "vinsertf128\t{$0x1, %2, %1, %0|%0, %1, %2, 0x1}"
   [(set_attr "type" "sselog")
+   (set_attr "prefix_extra" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V8SF")])
 
@@ -11891,6 +12201,7 @@ (define_insn "avx_maskloadp<avxmodesuffi
   "TARGET_AVX"
   "vmaskmovp<avxmodesuffixf2c>\t{%1, %2, %0|%0, %2, %1}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -11904,6 +12215,7 @@ (define_insn "avx_maskstorep<avxmodesuff
   "TARGET_AVX"
   "vmaskmovp<avxmodesuffixf2c>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "sselog1")
+   (set_attr "prefix_extra" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -12014,5 +12326,7 @@ (define_insn "*vec_concat<mode>_avx"
     }
 }
   [(set_attr "type" "sselog,ssemov")
+   (set_attr "prefix_extra" "1,*")
+   (set_attr "length_immediate" "1,*")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
--- gcc/config/i386/i386.md.jj	2009-06-09 11:20:00.000000000 +0200
+++ gcc/config/i386/i386.md	2009-06-09 11:59:17.000000000 +0200
@@ -295,6 +295,7 @@ (define_constants
    (R9_REG			38)
    (R10_REG			39)
    (R11_REG			40)
+   (R12_REG			41)
    (R13_REG			42)
    (XMM8_REG			45)
    (XMM9_REG			46)
@@ -398,16 +399,23 @@ (define_attr "length_address" ""
 
 ;; Set when length prefix is used.
 (define_attr "prefix_data16" ""
-  (if_then_else (ior (eq_attr "mode" "HI")
-		     (and (eq_attr "unit" "sse") (eq_attr "mode" "V2DF")))
-    (const_int 1)
-    (const_int 0)))
+  (cond [(eq_attr "type" "ssemuladd,sse4arg,sseiadd1,ssecvt1")
+	   (const_int 0)
+	 (eq_attr "mode" "HI")
+	   (const_int 1)
+	 (and (eq_attr "unit" "sse") (eq_attr "mode" "V2DF,TI"))
+	   (const_int 1)
+	]
+	(const_int 0)))
 
 ;; Set when string REP prefix is used.
 (define_attr "prefix_rep" ""
-  (if_then_else (and (eq_attr "unit" "sse") (eq_attr "mode" "SF,DF"))
-    (const_int 1)
-    (const_int 0)))
+  (cond [(eq_attr "type" "ssemuladd,sse4arg,sseiadd1,ssecvt1")
+	   (const_int 0)
+	 (and (eq_attr "unit" "sse") (eq_attr "mode" "SF,DF"))
+	   (const_int 1)
+	]
+	(const_int 0)))
 
 ;; Set when 0f opcode prefix is used.
 (define_attr "prefix_0f" ""
@@ -419,8 +427,11 @@ (define_attr "prefix_0f" ""
 
 ;; Set when REX opcode prefix is used.
 (define_attr "prefix_rex" ""
-  (cond [(and (eq_attr "mode" "DI")
-  	      (eq_attr "type" "!push,pop,call,callv,leave,ibr"))
+  (cond [(ne (symbol_ref "!TARGET_64BIT") (const_int 0))
+	   (const_int 0)
+	 (and (eq_attr "mode" "DI")
+	      (and (eq_attr "type" "!push,pop,call,callv,leave,ibr")
+		   (eq_attr "unit" "!mmx")))
 	   (const_int 1)
 	 (and (eq_attr "mode" "QI")
 	      (ne (symbol_ref "x86_extended_QIreg_mentioned_p (insn)")
@@ -429,11 +440,23 @@ (define_attr "prefix_rex" ""
 	 (ne (symbol_ref "x86_extended_reg_mentioned_p (insn)")
 	     (const_int 0))
 	   (const_int 1)
+	 (and (eq_attr "type" "imovx")
+	      (match_operand:QI 1 "ext_QIreg_operand" ""))
+	   (const_int 1)
 	]
 	(const_int 0)))
 
-;; There are also additional prefixes in SSSE3.
-(define_attr "prefix_extra" "" (const_int 0))
+;; There are also additional prefixes in 3DNOW, SSSE3 or SSE5.
+;; ssemuladd,sse4arg default to 0f24/0f25 and DREX byte,
+;; sseiadd1,ssecvt1 to 0f7a with no DREX byte.
+;; 3DNOW has 0f0f prefix, SSSE3 and SSE4_{1,2} 0f38/0f3a.
+(define_attr "prefix_extra" ""
+  (cond [(eq_attr "type" "ssemuladd,sse4arg")
+	   (const_int 2)
+	 (eq_attr "type" "sseiadd1,ssecvt1")
+	   (const_int 1)
+	]
+	(const_int 0)))
 
 ;; Prefix used: original, VEX or maybe VEX.
 (define_attr "prefix" "orig,vex,maybe_vex"
@@ -441,15 +464,16 @@ (define_attr "prefix" "orig,vex,maybe_ve
     (const_string "vex")
     (const_string "orig")))
 
-;; There is a 8bit immediate for VEX.
-(define_attr "prefix_vex_imm8" "" (const_int 0))
-
 ;; VEX W bit is used.
 (define_attr "prefix_vex_w" "" (const_int 0))
 
 ;; The length of VEX prefix
+;; Only instructions with 0f prefix can have 2 byte VEX prefix,
+;; 0f38/0f3a prefixes can't.  In i386.md 0f3[8a] is
+;; still prefix_0f 1, with prefix_extra 1.
 (define_attr "length_vex" ""
-  (if_then_else (eq_attr "prefix_0f" "1")
+  (if_then_else (and (eq_attr "prefix_0f" "1")
+		     (eq_attr "prefix_extra" "0"))
     (if_then_else (eq_attr "prefix_vex_w" "1")
       (symbol_ref "ix86_attr_length_vex_default (insn, 1, 1)")
       (symbol_ref "ix86_attr_length_vex_default (insn, 1, 0)"))
@@ -464,8 +488,9 @@ (define_attr "modrm" ""
 	 (eq_attr "unit" "i387")
 	   (const_int 0)
          (and (eq_attr "type" "incdec")
-	      (ior (match_operand:SI 1 "register_operand" "")
-		   (match_operand:HI 1 "register_operand" "")))
+	      (and (eq (symbol_ref "TARGET_64BIT") (const_int 0))
+		   (ior (match_operand:SI 1 "register_operand" "")
+			(match_operand:HI 1 "register_operand" ""))))
 	   (const_int 0)
 	 (and (eq_attr "type" "push")
 	      (not (match_operand 1 "memory_operand" "")))
@@ -474,12 +499,13 @@ (define_attr "modrm" ""
 	      (not (match_operand 0 "memory_operand" "")))
 	   (const_int 0)
 	 (and (eq_attr "type" "imov")
-	      (ior (and (match_operand 0 "register_operand" "")
-			(match_operand 1 "immediate_operand" ""))
-		   (ior (and (match_operand 0 "ax_reg_operand" "")
-			     (match_operand 1 "memory_displacement_only_operand" ""))
-			(and (match_operand 0 "memory_displacement_only_operand" "")
-			     (match_operand 1 "ax_reg_operand" "")))))
+	      (and (not (eq_attr "mode" "DI"))
+		   (ior (and (match_operand 0 "register_operand" "")
+			     (match_operand 1 "immediate_operand" ""))
+		        (ior (and (match_operand 0 "ax_reg_operand" "")
+				  (match_operand 1 "memory_displacement_only_operand" ""))
+			     (and (match_operand 0 "memory_displacement_only_operand" "")
+				  (match_operand 1 "ax_reg_operand" ""))))))
 	   (const_int 0)
 	 (and (eq_attr "type" "call")
 	      (match_operand 0 "constant_call_address_operand" ""))
@@ -487,6 +513,9 @@ (define_attr "modrm" ""
 	 (and (eq_attr "type" "callv")
 	      (match_operand 1 "constant_call_address_operand" ""))
 	     (const_int 0)
+	 (and (eq_attr "type" "alu,alu1,icmp,test")
+	      (match_operand 0 "ax_reg_operand" ""))
+	     (symbol_ref "(get_attr_length_immediate (insn) <= (get_attr_mode (insn) != MODE_QI))")
 	 ]
 	 (const_int 1)))
 
@@ -507,7 +536,7 @@ (define_attr "length" ""
 	      (and (eq_attr "prefix" "maybe_vex")
 		    (ne (symbol_ref "TARGET_AVX") (const_int 0))))
 	   (plus (attr "length_vex")
-		 (plus (attr "prefix_vex_imm8")
+		 (plus (attr "length_immediate")
 		       (plus (attr "modrm")
 			     (attr "length_address"))))]
 	 (plus (plus (attr "modrm")
@@ -1022,6 +1051,7 @@ (define_insn "cmpqi_ext_3_insn"
   "!TARGET_64BIT && ix86_match_ccmode (insn, CCmode)"
   "cmp{b}\t{%1, %h0|%h0, %1}"
   [(set_attr "type" "icmp")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "cmpqi_ext_3_insn_rex64"
@@ -1036,6 +1066,7 @@ (define_insn "cmpqi_ext_3_insn_rex64"
   "TARGET_64BIT && ix86_match_ccmode (insn, CCmode)"
   "cmp{b}\t{%1, %h0|%h0, %1}"
   [(set_attr "type" "icmp")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*cmpqi_ext_4"
@@ -1308,7 +1339,7 @@ (define_insn "x86_fnstsw_1"
 	(unspec:HI [(reg:CCFP FPSR_REG)] UNSPEC_FNSTSW))]
   "TARGET_80387"
   "fnstsw\t%0"
-  [(set_attr "length" "2")
+  [(set (attr "length") (symbol_ref "ix86_attr_length_address_default (insn) + 2"))
    (set_attr "mode" "SI")
    (set_attr "unit" "i387")])
 
@@ -1348,6 +1379,17 @@ (define_insn "*cmpfp_i_mixed"
      (if_then_else (match_operand:SF 1 "" "")
         (const_string "SF")
         (const_string "DF")))
+   (set (attr "prefix_rep")
+	(if_then_else (eq_attr "type" "ssecomi")
+		      (const_string "0")
+		      (const_string "*")))
+   (set (attr "prefix_data16")
+	(cond [(eq_attr "type" "fcmp")
+		 (const_string "*")
+	       (eq_attr "mode" "DF")
+		 (const_string "1")
+	      ]
+	      (const_string "0")))
    (set_attr "athlon_decode" "vector")
    (set_attr "amdfam10_decode" "direct")])
 
@@ -1365,6 +1407,11 @@ (define_insn "*cmpfp_i_sse"
      (if_then_else (match_operand:SF 1 "" "")
         (const_string "SF")
         (const_string "DF")))
+   (set_attr "prefix_rep" "0")
+   (set (attr "prefix_data16")
+	(if_then_else (eq_attr "mode" "DF")
+		      (const_string "1")
+		      (const_string "0")))
    (set_attr "athlon_decode" "vector")
    (set_attr "amdfam10_decode" "direct")])
 
@@ -1402,6 +1449,17 @@ (define_insn "*cmpfp_iu_mixed"
      (if_then_else (match_operand:SF 1 "" "")
         (const_string "SF")
         (const_string "DF")))
+   (set (attr "prefix_rep")
+	(if_then_else (eq_attr "type" "ssecomi")
+		      (const_string "0")
+		      (const_string "*")))
+   (set (attr "prefix_data16")
+	(cond [(eq_attr "type" "fcmp")
+		 (const_string "*")
+	       (eq_attr "mode" "DF")
+		 (const_string "1")
+	      ]
+	      (const_string "0")))
    (set_attr "athlon_decode" "vector")
    (set_attr "amdfam10_decode" "direct")])
 
@@ -1419,6 +1477,11 @@ (define_insn "*cmpfp_iu_sse"
      (if_then_else (match_operand:SF 1 "" "")
         (const_string "SF")
         (const_string "DF")))
+   (set_attr "prefix_rep" "0")
+   (set (attr "prefix_data16")
+	(if_then_else (eq_attr "mode" "DF")
+		      (const_string "1")
+		      (const_string "0")))
    (set_attr "athlon_decode" "vector")
    (set_attr "amdfam10_decode" "direct")])
 
@@ -1594,6 +1657,10 @@ (define_insn "*movsi_1"
      (if_then_else (eq_attr "alternative" "0,1,2,3,4,5")
        (const_string "orig")
        (const_string "maybe_vex")))
+   (set (attr "prefix_data16")
+     (if_then_else (and (eq_attr "type" "ssemov") (eq_attr "mode" "SI"))
+       (const_string "1")
+       (const_string "*")))
    (set (attr "mode")
      (cond [(eq_attr "alternative" "2,3")
 	      (const_string "DI")
@@ -2085,7 +2152,7 @@ (define_insn "*movdi_extzv_1"
   "TARGET_64BIT"
   "movz{bl|x}\t{%h1, %k0|%k0, %h1}"
   [(set_attr "type" "imovx")
-   (set_attr "mode" "DI")])
+   (set_attr "mode" "SI")])
 
 (define_insn "*movsi_extzv_1"
   [(set (match_operand:SI 0 "register_operand" "=R")
@@ -2433,8 +2500,18 @@ (define_insn "*movdi_1_rex64"
 	      (const_string "lea")
 	   ]
 	   (const_string "imov")))
-   (set_attr "modrm" "*,0,0,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*")
-   (set_attr "length_immediate" "*,4,8,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*")
+   (set (attr "modrm")
+     (if_then_else
+       (and (eq_attr "alternative" "2") (eq_attr "type" "imov"))
+	 (const_string "0")
+	 (const_string "*")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (and (eq_attr "alternative" "2") (eq_attr "type" "imov"))
+	 (const_string "8")
+	 (const_string "*")))
+   (set_attr "prefix_rex" "*,*,*,*,*,*,*,1,*,1,*,*,*,*,*,*,*,*,*")
+   (set_attr "prefix_data16" "*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,1,*,*,*")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "11,12,13,14,15,16")
        (const_string "maybe_vex")
@@ -3019,6 +3096,10 @@ (define_insn "*movdf_nointeger"
      (if_then_else (eq_attr "alternative" "0,1,2,3,4")
        (const_string "orig")
        (const_string "maybe_vex")))
+   (set (attr "prefix_data16")
+     (if_then_else (eq_attr "mode" "V1DF")
+       (const_string "1")
+       (const_string "*")))
    (set (attr "mode")
         (cond [(eq_attr "alternative" "0,1,2")
 		 (const_string "DF")
@@ -3153,6 +3234,10 @@ (define_insn "*movdf_integer_rex64"
      (if_then_else (eq_attr "alternative" "0,1,2,3,4")
        (const_string "orig")
        (const_string "maybe_vex")))
+   (set (attr "prefix_data16")
+     (if_then_else (eq_attr "mode" "V1DF")
+       (const_string "1")
+       (const_string "*")))
    (set (attr "mode")
         (cond [(eq_attr "alternative" "0,1,2")
 		 (const_string "DF")
@@ -3273,6 +3358,10 @@ (define_insn "*movdf_integer"
     }
 }
   [(set_attr "type" "fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov")
+   (set (attr "prefix_data16")
+     (if_then_else (eq_attr "mode" "V1DF")
+       (const_string "1")
+       (const_string "*")))
    (set (attr "mode")
         (cond [(eq_attr "alternative" "0,1,2")
 		 (const_string "DF")
@@ -3903,6 +3992,7 @@ (define_insn "zero_extendsidi2_rex64"
    %vmovd\t{%1, %0|%0, %1}"
   [(set_attr "type" "imovx,imov,mmxmov,mmxmov,ssemov,ssemov")
    (set_attr "prefix" "orig,*,orig,orig,maybe_vex,maybe_vex")
+   (set_attr "prefix_0f" "0,*,*,*,*,*")
    (set_attr "mode" "SI,DI,DI,DI,TI,TI")])
 
 (define_split
@@ -3937,7 +4027,7 @@ (define_insn "zero_extendhidi2"
   "TARGET_64BIT"
   "movz{wl|x}\t{%1, %k0|%k0, %1}"
   [(set_attr "type" "imovx")
-   (set_attr "mode" "DI")])
+   (set_attr "mode" "SI")])
 
 (define_insn "zero_extendqidi2"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -3945,7 +4035,7 @@ (define_insn "zero_extendqidi2"
   "TARGET_64BIT"
   "movz{bl|x}\t{%1, %k0|%k0, %1}"
   [(set_attr "type" "imovx")
-   (set_attr "mode" "DI")])
+   (set_attr "mode" "SI")])
 
 ;; Sign extension instructions
 
@@ -3977,7 +4067,7 @@ (define_insn "extendsidi2_rex64"
   "TARGET_64BIT"
   "@
    {cltq|cdqe}
-   movs{lq|x}\t{%1,%0|%0, %1}"
+   movs{lq|x}\t{%1, %0|%0, %1}"
   [(set_attr "type" "imovx")
    (set_attr "mode" "DI")
    (set_attr "prefix_0f" "0")
@@ -3987,7 +4077,7 @@ (define_insn "extendhidi2"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI (match_operand:HI 1 "nonimmediate_operand" "rm")))]
   "TARGET_64BIT"
-  "movs{wq|x}\t{%1,%0|%0, %1}"
+  "movs{wq|x}\t{%1, %0|%0, %1}"
   [(set_attr "type" "imovx")
    (set_attr "mode" "DI")])
 
@@ -3995,7 +4085,7 @@ (define_insn "extendqidi2"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI (match_operand:QI 1 "nonimmediate_operand" "qm")))]
   "TARGET_64BIT"
-  "movs{bq|x}\t{%1,%0|%0, %1}"
+  "movs{bq|x}\t{%1, %0|%0, %1}"
    [(set_attr "type" "imovx")
     (set_attr "mode" "DI")])
 
@@ -4083,7 +4173,7 @@ (define_insn "extendhisi2"
     case 0:
       return "{cwtl|cwde}";
     default:
-      return "movs{wl|x}\t{%1,%0|%0, %1}";
+      return "movs{wl|x}\t{%1, %0|%0, %1}";
     }
 }
   [(set_attr "type" "imovx")
@@ -4110,7 +4200,7 @@ (define_insn "*extendhisi2_zext"
     case 0:
       return "{cwtl|cwde}";
     default:
-      return "movs{wl|x}\t{%1,%k0|%k0, %1}";
+      return "movs{wl|x}\t{%1, %k0|%k0, %1}";
     }
 }
   [(set_attr "type" "imovx")
@@ -4136,7 +4226,7 @@ (define_insn "extendqihi2"
     case 0:
       return "{cbtw|cbw}";
     default:
-      return "movs{bw|x}\t{%1,%0|%0, %1}";
+      return "movs{bw|x}\t{%1, %0|%0, %1}";
     }
 }
   [(set_attr "type" "imovx")
@@ -4156,7 +4246,7 @@ (define_insn "extendqisi2"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "qm")))]
   ""
-  "movs{bl|x}\t{%1,%0|%0, %1}"
+  "movs{bl|x}\t{%1, %0|%0, %1}"
    [(set_attr "type" "imovx")
     (set_attr "mode" "SI")])
 
@@ -4165,7 +4255,7 @@ (define_insn "*extendqisi2_zext"
 	(zero_extend:DI
 	  (sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "qm"))))]
   "TARGET_64BIT"
-  "movs{bl|x}\t{%1,%k0|%k0, %1}"
+  "movs{bl|x}\t{%1, %k0|%k0, %1}"
    [(set_attr "type" "imovx")
     (set_attr "mode" "SI")])
 
@@ -4773,6 +4863,7 @@ (define_insn "fix_trunc<mode>di_sse"
   "%vcvtts<ssemodefsuffix>2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "maybe_vex")
+   (set_attr "prefix_rex" "1")
    (set_attr "mode" "<MODE>")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "amdfam10_decode" "double,double")])
@@ -5047,7 +5138,7 @@ (define_insn "x86_fnstcw_1"
 	(unspec:HI [(reg:HI FPCR_REG)] UNSPEC_FSTCW))]
   "TARGET_80387"
   "fnstcw\t%0"
-  [(set_attr "length" "2")
+  [(set (attr "length") (symbol_ref "ix86_attr_length_address_default (insn) + 2"))
    (set_attr "mode" "HI")
    (set_attr "unit" "i387")])
 
@@ -5056,7 +5147,7 @@ (define_insn "x86_fldcw_1"
 	(unspec:HI [(match_operand:HI 0 "memory_operand" "m")] UNSPEC_FLDCW))]
   "TARGET_80387"
   "fldcw\t%0"
-  [(set_attr "length" "2")
+  [(set (attr "length") (symbol_ref "ix86_attr_length_address_default (insn) + 2"))
    (set_attr "mode" "HI")
    (set_attr "unit" "i387")
    (set_attr "athlon_decode" "vector")
@@ -5271,6 +5362,12 @@ (define_insn "*float<SSEMODEI24:mode><MO
   [(set_attr "type" "fmov,sseicvt,sseicvt")
    (set_attr "prefix" "orig,maybe_vex,maybe_vex")
    (set_attr "mode" "<MODEF:MODE>")
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "prefix" "maybe_vex")
+	    (ne (symbol_ref "<SSEMODEI24:MODE>mode == DImode") (const_int 0)))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "unit" "i387,*,*")
    (set_attr "athlon_decode" "*,double,direct")
    (set_attr "amdfam10_decode" "*,vector,double")
@@ -5289,6 +5386,12 @@ (define_insn "*float<SSEMODEI24:mode><MO
   [(set_attr "type" "fmov,sseicvt")
    (set_attr "prefix" "orig,maybe_vex")
    (set_attr "mode" "<MODEF:MODE>")
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "prefix" "maybe_vex")
+	    (ne (symbol_ref "<SSEMODEI24:MODE>mode == DImode") (const_int 0)))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "athlon_decode" "*,direct")
    (set_attr "amdfam10_decode" "*,double")
    (set_attr "fp_int_src" "true")])
@@ -5465,6 +5568,12 @@ (define_insn "*float<SSEMODEI24:mode><MO
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODEF:MODE>")
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "prefix" "maybe_vex")
+	    (ne (symbol_ref "<SSEMODEI24:MODE>mode == DImode") (const_int 0)))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "athlon_decode" "double,direct")
    (set_attr "amdfam10_decode" "vector,double")
    (set_attr "fp_int_src" "true")])
@@ -5494,6 +5603,12 @@ (define_insn "*float<SSEMODEI24:mode><MO
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODEF:MODE>")
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "prefix" "maybe_vex")
+	    (ne (symbol_ref "<SSEMODEI24:MODE>mode == DImode") (const_int 0)))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "athlon_decode" "direct")
    (set_attr "amdfam10_decode" "double")
    (set_attr "fp_int_src" "true")])
@@ -6200,6 +6315,11 @@ (define_insn "*adddi_1_rex64"
 	      (const_string "incdec")
 	   ]
 	   (const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "DI")])
 
 ;; Convert lea to the lea pattern to avoid flags dependency.
@@ -6264,6 +6384,11 @@ (define_insn "*adddi_2_rex64"
      (if_then_else (match_operand:DI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "DI")])
 
 (define_insn "*adddi_3_rex64"
@@ -6313,6 +6438,11 @@ (define_insn "*adddi_3_rex64"
      (if_then_else (match_operand:DI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "DI")])
 
 ; For comparisons against 1, -1 and 128, we may generate better code
@@ -6360,6 +6490,11 @@ (define_insn "*adddi_4_rex64"
      (if_then_else (match_operand:DI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "DI")])
 
 (define_insn "*adddi_5_rex64"
@@ -6409,6 +6544,11 @@ (define_insn "*adddi_5_rex64"
      (if_then_else (match_operand:DI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "DI")])
 
 
@@ -6469,6 +6609,11 @@ (define_insn "*addsi_1"
 	      (const_string "incdec")
 	   ]
 	   (const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 ;; Convert lea to the lea pattern to avoid flags dependency.
@@ -6549,6 +6694,11 @@ (define_insn "addsi_1_zext"
 	      (const_string "incdec")
 	   ]
 	   (const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 ;; Convert lea to the lea pattern to avoid flags dependency.
@@ -6612,6 +6762,11 @@ (define_insn "*addsi_2"
      (if_then_else (match_operand:SI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
@@ -6658,6 +6813,11 @@ (define_insn "*addsi_2_zext"
      (if_then_else (match_operand:SI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_insn "*addsi_3"
@@ -6702,6 +6862,11 @@ (define_insn "*addsi_3"
      (if_then_else (match_operand:SI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
@@ -6746,6 +6911,11 @@ (define_insn "*addsi_3_zext"
      (if_then_else (match_operand:SI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 ; For comparisons against 1, -1 and 128, we may generate better code
@@ -6791,6 +6961,11 @@ (define_insn "*addsi_4"
      (if_then_else (match_operand:SI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_insn "*addsi_5"
@@ -6837,6 +7012,11 @@ (define_insn "*addsi_5"
      (if_then_else (match_operand:SI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_expand "addhi3"
@@ -6891,6 +7071,11 @@ (define_insn "*addhi_1_lea"
 	(if_then_else (match_operand:HI 2 "incdec_operand" "")
 	   (const_string "incdec")
 	   (const_string "alu"))))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "HI,HI,SI")])
 
 (define_insn "*addhi_1"
@@ -6930,6 +7115,11 @@ (define_insn "*addhi_1"
      (if_then_else (match_operand:HI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "HI")])
 
 (define_insn "*addhi_2"
@@ -6972,6 +7162,11 @@ (define_insn "*addhi_2"
      (if_then_else (match_operand:HI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "HI")])
 
 (define_insn "*addhi_3"
@@ -7011,6 +7206,11 @@ (define_insn "*addhi_3"
      (if_then_else (match_operand:HI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "HI")])
 
 ; See comments above addsi_4 for details.
@@ -7049,7 +7249,12 @@ (define_insn "*addhi_4"
      (if_then_else (match_operand:HI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
-   (set_attr "mode" "SI")])
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
+   (set_attr "mode" "HI")])
 
 
 (define_insn "*addhi_5"
@@ -7091,6 +7296,11 @@ (define_insn "*addhi_5"
      (if_then_else (match_operand:HI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "HI")])
 
 (define_expand "addqi3"
@@ -7149,6 +7359,11 @@ (define_insn "*addqi_1_lea"
 	(if_then_else (match_operand:QI 2 "incdec_operand" "")
 	   (const_string "incdec")
 	   (const_string "alu"))))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "QI,QI,SI,SI")])
 
 (define_insn "*addqi_1"
@@ -7195,6 +7410,11 @@ (define_insn "*addqi_1"
      (if_then_else (match_operand:QI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set (attr "length_immediate")
+      (if_then_else
+	(and (eq_attr "type" "alu") (match_operand 2 "const128_operand" ""))
+	(const_string "1")
+	(const_string "*")))
    (set_attr "mode" "QI,QI,SI")])
 
 (define_insn "*addqi_1_slp"
@@ -7430,6 +7650,7 @@ (define_insn "addqi_ext_1"
      (if_then_else (match_operand:QI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*addqi_ext_1_rex64"
@@ -7466,6 +7687,7 @@ (define_insn "*addqi_ext_1_rex64"
      (if_then_else (match_operand:QI 2 "incdec_operand" "")
 	(const_string "incdec")
 	(const_string "alu")))
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*addqi_ext_2"
@@ -8925,6 +9147,7 @@ (define_insn "*testqi_ext_0"
   [(set_attr "type" "test")
    (set_attr "mode" "QI")
    (set_attr "length_immediate" "1")
+   (set_attr "modrm" "1")
    (set_attr "pent_pair" "np")])
 
 (define_insn "*testqi_ext_1"
@@ -9151,9 +9374,9 @@ (define_insn "*anddi_1_rex64"
 
 	operands[1] = gen_lowpart (mode, operands[1]);
 	if (mode == QImode)
-	  return "movz{bq|x}\t{%1,%0|%0, %1}";
+	  return "movz{bl|x}\t{%1, %k0|%k0, %1}";
 	else
-	  return "movz{wq|x}\t{%1,%0|%0, %1}";
+	  return "movz{wl|x}\t{%1, %k0|%k0, %1}";
       }
 
     default:
@@ -9166,7 +9389,14 @@ (define_insn "*anddi_1_rex64"
 }
   [(set_attr "type" "alu,alu,alu,imovx")
    (set_attr "length_immediate" "*,*,*,0")
-   (set_attr "mode" "SI,DI,DI,DI")])
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "type" "imovx")
+	    (and (ne (symbol_ref "INTVAL (operands[2]) == 0xff") (const_int 0))
+		 (match_operand 1 "ext_QIreg_nomode_operand" "")))
+       (const_string "1")
+       (const_string "*")))
+   (set_attr "mode" "SI,DI,DI,SI")])
 
 (define_insn "*anddi_2"
   [(set (reg FLAGS_REG)
@@ -9215,9 +9445,9 @@ (define_insn "*andsi_1"
 
 	operands[1] = gen_lowpart (mode, operands[1]);
 	if (mode == QImode)
-	  return "movz{bl|x}\t{%1,%0|%0, %1}";
+	  return "movz{bl|x}\t{%1, %0|%0, %1}";
 	else
-	  return "movz{wl|x}\t{%1,%0|%0, %1}";
+	  return "movz{wl|x}\t{%1, %0|%0, %1}";
       }
 
     default:
@@ -9226,6 +9456,13 @@ (define_insn "*andsi_1"
     }
 }
   [(set_attr "type" "alu,alu,imovx")
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "type" "imovx")
+	    (and (ne (symbol_ref "INTVAL (operands[2]) == 0xff") (const_int 0))
+		 (match_operand 1 "ext_QIreg_nomode_operand" "")))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "length_immediate" "*,*,0")
    (set_attr "mode" "SI")])
 
@@ -9334,6 +9571,12 @@ (define_insn "*andhi_1"
 }
   [(set_attr "type" "alu,alu,imovx")
    (set_attr "length_immediate" "*,*,0")
+   (set (attr "prefix_rex")
+     (if_then_else
+       (and (eq_attr "type" "imovx")
+	    (match_operand 1 "ext_QIreg_nomode_operand" ""))
+       (const_string "1")
+       (const_string "*")))
    (set_attr "mode" "HI,HI,SI")])
 
 (define_insn "*andhi_2"
@@ -9453,6 +9696,7 @@ (define_insn "andqi_ext_0"
   "and{b}\t{%2, %h0|%h0, %2}"
   [(set_attr "type" "alu")
    (set_attr "length_immediate" "1")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 ;; Generated by peephole translating test to and.  This shows up
@@ -9481,6 +9725,7 @@ (define_insn "*andqi_ext_0_cc"
   "and{b}\t{%2, %h0|%h0, %2}"
   [(set_attr "type" "alu")
    (set_attr "length_immediate" "1")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*andqi_ext_1"
@@ -9855,6 +10100,7 @@ (define_insn "*iorqi_ext_0"
   "or{b}\t{%2, %h0|%h0, %2}"
   [(set_attr "type" "alu")
    (set_attr "length_immediate" "1")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*iorqi_ext_1"
@@ -10185,6 +10431,7 @@ (define_insn "*xorqi_ext_0"
   "xor{b}\t{%2, %h0|%h0, %2}"
   [(set_attr "type" "alu")
    (set_attr "length_immediate" "1")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*xorqi_ext_1"
@@ -10303,6 +10550,7 @@ (define_insn "*xorqi_cc_ext_1"
   "!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)"
   "xor{b}\t{%2, %h0|%h0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_insn "*xorqi_cc_ext_1_rex64"
@@ -10324,6 +10572,7 @@ (define_insn "*xorqi_cc_ext_1_rex64"
   "TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)"
   "xor{b}\t{%2, %h0|%h0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "modrm" "1")
    (set_attr "mode" "QI")])
 
 (define_expand "xorqi_cc_ext_1"
@@ -11126,6 +11375,7 @@ (define_insn "*avx_ashlti3"
 }
   [(set_attr "type" "sseishft")
    (set_attr "prefix" "vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse2_ashlti3"
@@ -11139,6 +11389,7 @@ (define_insn "sse2_ashlti3"
 }
   [(set_attr "type" "sseishft")
    (set_attr "prefix_data16" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*ashlti3_1"
@@ -11278,6 +11529,15 @@ (define_insn "*ashldi3_1_rex64"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "DI")])
 
 ;; Convert lea to the lea pattern to avoid flags dependency.
@@ -11337,6 +11597,15 @@ (define_insn "*ashldi3_cmp_rex64"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "DI")])
 
 (define_insn "*ashldi3_cconly_rex64"
@@ -11379,6 +11648,15 @@ (define_insn "*ashldi3_cconly_rex64"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "DI")])
 
 (define_insn "*ashldi3_1"
@@ -11518,6 +11796,15 @@ (define_insn "*ashlsi3_1"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "SI")])
 
 ;; Convert lea to the lea pattern to avoid flags dependency.
@@ -11602,6 +11889,15 @@ (define_insn "*ashlsi3_1_zext"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "SI")])
 
 ;; Convert lea to the lea pattern to avoid flags dependency.
@@ -11663,6 +11959,15 @@ (define_insn "*ashlsi3_cmp"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_insn "*ashlsi3_cconly"
@@ -11704,6 +12009,15 @@ (define_insn "*ashlsi3_cconly"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_insn "*ashlsi3_cmp_zext"
@@ -11746,6 +12060,15 @@ (define_insn "*ashlsi3_cmp_zext"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_expand "ashlhi3"
@@ -11791,6 +12114,15 @@ (define_insn "*ashlhi3_1_lea"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "HI,SI")])
 
 (define_insn "*ashlhi3_1"
@@ -11825,6 +12157,15 @@ (define_insn "*ashlhi3_1"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "HI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
@@ -11870,6 +12211,15 @@ (define_insn "*ashlhi3_cmp"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "HI")])
 
 (define_insn "*ashlhi3_cconly"
@@ -11911,6 +12261,15 @@ (define_insn "*ashlhi3_cconly"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "HI")])
 
 (define_expand "ashlqi3"
@@ -11976,6 +12335,15 @@ (define_insn "*ashlqi3_1_lea"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "QI,SI,SI")])
 
 (define_insn "*ashlqi3_1"
@@ -12028,6 +12396,15 @@ (define_insn "*ashlqi3_1"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "QI,SI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
@@ -12073,6 +12450,15 @@ (define_insn "*ashlqi3_cmp"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "QI")])
 
 (define_insn "*ashlqi3_cconly"
@@ -12114,6 +12500,15 @@ (define_insn "*ashlqi3_cconly"
 	      (const_string "alu")
 	   ]
 	   (const_string "ishift")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "ishift")
+		 (and (match_operand 2 "const1_operand" "")
+		      (ne (symbol_ref "TARGET_SHIFT1 || optimize_function_for_size_p (cfun)")
+			  (const_int 0)))))
+       (const_string "0")
+       (const_string "*")))
    (set_attr "mode" "QI")])
 
 ;; See comment above `ashldi3' about how this works.
@@ -12232,10 +12627,8 @@ (define_insn "*ashrdi3_1_one_bit_rex64"
    && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)"
   "sar{q}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:DI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 (define_insn "*ashrdi3_1_rex64"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=rm,rm")
@@ -12266,10 +12659,8 @@ (define_insn "*ashrdi3_one_bit_cmp_rex64
    && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)"
   "sar{q}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:DI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 (define_insn "*ashrdi3_one_bit_cconly_rex64"
   [(set (reg FLAGS_REG)
@@ -12284,7 +12675,8 @@ (define_insn "*ashrdi3_one_bit_cconly_re
    && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)"
   "sar{q}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -12452,10 +12844,8 @@ (define_insn "*ashrsi3_1_one_bit"
    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)"
   "sar{l}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*ashrsi3_1_one_bit_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -12467,7 +12857,8 @@ (define_insn "*ashrsi3_1_one_bit_zext"
    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)"
   "sar{l}\t%k0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*ashrsi3_1"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rm,rm")
@@ -12509,10 +12900,8 @@ (define_insn "*ashrsi3_one_bit_cmp"
    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)"
   "sar{l}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*ashrsi3_one_bit_cconly"
   [(set (reg FLAGS_REG)
@@ -12526,7 +12915,8 @@ (define_insn "*ashrsi3_one_bit_cconly"
    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)"
   "sar{l}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*ashrsi3_one_bit_cmp_zext"
   [(set (reg FLAGS_REG)
@@ -12542,7 +12932,8 @@ (define_insn "*ashrsi3_one_bit_cmp_zext"
    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)"
   "sar{l}\t%k0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -12608,10 +12999,8 @@ (define_insn "*ashrhi3_1_one_bit"
    && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)"
   "sar{w}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 (define_insn "*ashrhi3_1"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=rm,rm")
@@ -12641,10 +13030,8 @@ (define_insn "*ashrhi3_one_bit_cmp"
    && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)"
   "sar{w}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 (define_insn "*ashrhi3_one_bit_cconly"
   [(set (reg FLAGS_REG)
@@ -12658,7 +13045,8 @@ (define_insn "*ashrhi3_one_bit_cconly"
    && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)"
   "sar{w}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -12708,10 +13096,8 @@ (define_insn "*ashrqi3_1_one_bit"
    && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)"
   "sar{b}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*ashrqi3_1_one_bit_slp"
   [(set (strict_low_part (match_operand:QI 0 "nonimmediate_operand" "+qm"))
@@ -12723,10 +13109,8 @@ (define_insn "*ashrqi3_1_one_bit_slp"
    && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)"
   "sar{b}\t%0"
   [(set_attr "type" "ishift1")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*ashrqi3_1"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=qm,qm")
@@ -12769,10 +13153,8 @@ (define_insn "*ashrqi3_one_bit_cmp"
    && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)"
   "sar{b}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*ashrqi3_one_bit_cconly"
   [(set (reg FLAGS_REG)
@@ -12786,7 +13168,8 @@ (define_insn "*ashrqi3_one_bit_cconly"
    && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)"
   "sar{b}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -12846,6 +13229,7 @@ (define_insn "*avx_lshrti3"
 }
   [(set_attr "type" "sseishft")
    (set_attr "prefix" "vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "sse2_lshrti3"
@@ -12859,6 +13243,7 @@ (define_insn "sse2_lshrti3"
 }
   [(set_attr "type" "sseishft")
    (set_attr "prefix_data16" "1")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "TI")])
 
 (define_insn "*lshrti3_1"
@@ -12908,10 +13293,8 @@ (define_insn "*lshrdi3_1_one_bit_rex64"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{q}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:DI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 (define_insn "*lshrdi3_1_rex64"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=rm,rm")
@@ -12942,10 +13325,8 @@ (define_insn "*lshrdi3_cmp_one_bit_rex64
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{q}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:DI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 (define_insn "*lshrdi3_cconly_one_bit_rex64"
   [(set (reg FLAGS_REG)
@@ -12960,7 +13341,8 @@ (define_insn "*lshrdi3_cconly_one_bit_re
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{q}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -13045,10 +13427,8 @@ (define_insn "*lshrsi3_1_one_bit"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{l}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*lshrsi3_1_one_bit_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -13060,7 +13440,8 @@ (define_insn "*lshrsi3_1_one_bit_zext"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{l}\t%k0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*lshrsi3_1"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rm,rm")
@@ -13103,10 +13484,8 @@ (define_insn "*lshrsi3_one_bit_cmp"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{l}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*lshrsi3_one_bit_cconly"
   [(set (reg FLAGS_REG)
@@ -13120,7 +13499,8 @@ (define_insn "*lshrsi3_one_bit_cconly"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{l}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*lshrsi3_cmp_one_bit_zext"
   [(set (reg FLAGS_REG)
@@ -13136,7 +13516,8 @@ (define_insn "*lshrsi3_cmp_one_bit_zext"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{l}\t%k0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -13202,10 +13583,8 @@ (define_insn "*lshrhi3_1_one_bit"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{w}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 (define_insn "*lshrhi3_1"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=rm,rm")
@@ -13235,10 +13614,8 @@ (define_insn "*lshrhi3_one_bit_cmp"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{w}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 (define_insn "*lshrhi3_one_bit_cconly"
   [(set (reg FLAGS_REG)
@@ -13252,7 +13629,8 @@ (define_insn "*lshrhi3_one_bit_cconly"
    && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)"
   "shr{w}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -13302,10 +13680,8 @@ (define_insn "*lshrqi3_1_one_bit"
    && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)"
   "shr{b}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*lshrqi3_1_one_bit_slp"
   [(set (strict_low_part (match_operand:QI 0 "nonimmediate_operand" "+qm"))
@@ -13316,10 +13692,8 @@ (define_insn "*lshrqi3_1_one_bit_slp"
    && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))"
   "shr{b}\t%0"
   [(set_attr "type" "ishift1")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*lshrqi3_1"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=qm,qm")
@@ -13362,10 +13736,8 @@ (define_insn "*lshrqi2_one_bit_cmp"
    && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)"
   "shr{b}\t%0"
   [(set_attr "type" "ishift")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*lshrqi2_one_bit_cconly"
   [(set (reg FLAGS_REG)
@@ -13379,7 +13751,8 @@ (define_insn "*lshrqi2_one_bit_cconly"
    && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)"
   "shr{b}\t%0"
   [(set_attr "type" "ishift")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 ;; This pattern can't accept a variable shift count, since shifts by
 ;; zero don't affect the flags.  We assume that shifts by constant
@@ -13468,10 +13841,8 @@ (define_insn "*rotlsi3_1_one_bit_rex64"
    && ix86_binary_operator_ok (ROTATE, DImode, operands)"
   "rol{q}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand:DI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 (define_insn "*rotldi3_1_rex64"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=rm,rm")
@@ -13501,10 +13872,8 @@ (define_insn "*rotlsi3_1_one_bit"
    && ix86_binary_operator_ok (ROTATE, SImode, operands)"
   "rol{l}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*rotlsi3_1_one_bit_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -13517,7 +13886,8 @@ (define_insn "*rotlsi3_1_one_bit_zext"
    && ix86_binary_operator_ok (ROTATE, SImode, operands)"
   "rol{l}\t%k0"
   [(set_attr "type" "rotate")
-   (set_attr "length" "2")])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*rotlsi3_1"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rm,rm")
@@ -13560,10 +13930,8 @@ (define_insn "*rotlhi3_1_one_bit"
    && ix86_binary_operator_ok (ROTATE, HImode, operands)"
   "rol{w}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 (define_insn "*rotlhi3_1"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=rm,rm")
@@ -13603,10 +13971,8 @@ (define_insn "*rotlqi3_1_one_bit_slp"
    && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))"
   "rol{b}\t%0"
   [(set_attr "type" "rotate1")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*rotlqi3_1_one_bit"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=qm")
@@ -13617,10 +13983,8 @@ (define_insn "*rotlqi3_1_one_bit"
    && ix86_binary_operator_ok (ROTATE, QImode, operands)"
   "rol{b}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*rotlqi3_1_slp"
   [(set (strict_low_part (match_operand:QI 0 "nonimmediate_operand" "+qm,qm"))
@@ -13700,10 +14064,8 @@ (define_insn "*rotrdi3_1_one_bit_rex64"
    && ix86_binary_operator_ok (ROTATERT, DImode, operands)"
   "ror{q}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand:DI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "DI")])
 
 (define_insn "*rotrdi3_1_rex64"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=rm,rm")
@@ -13733,10 +14095,8 @@ (define_insn "*rotrsi3_1_one_bit"
    && ix86_binary_operator_ok (ROTATERT, SImode, operands)"
   "ror{l}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*rotrsi3_1_one_bit_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -13749,10 +14109,8 @@ (define_insn "*rotrsi3_1_one_bit_zext"
    && ix86_binary_operator_ok (ROTATERT, SImode, operands)"
   "ror{l}\t%k0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand:SI 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "SI")])
 
 (define_insn "*rotrsi3_1"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rm,rm")
@@ -13795,10 +14153,8 @@ (define_insn "*rotrhi3_one_bit"
    && ix86_binary_operator_ok (ROTATERT, HImode, operands)"
   "ror{w}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "HI")])
 
 (define_insn "*rotrhi3_1"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=rm,rm")
@@ -13838,10 +14194,8 @@ (define_insn "*rotrqi3_1_one_bit"
    && ix86_binary_operator_ok (ROTATERT, QImode, operands)"
   "ror{b}\t%0"
   [(set_attr "type" "rotate")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*rotrqi3_1_one_bit_slp"
   [(set (strict_low_part (match_operand:QI 0 "nonimmediate_operand" "+qm"))
@@ -13852,10 +14206,8 @@ (define_insn "*rotrqi3_1_one_bit_slp"
    && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))"
   "ror{b}\t%0"
   [(set_attr "type" "rotate1")
-   (set (attr "length")
-     (if_then_else (match_operand 0 "register_operand" "")
-	(const_string "2")
-	(const_string "*")))])
+   (set_attr "length_immediate" "0")
+   (set_attr "mode" "QI")])
 
 (define_insn "*rotrqi3_1"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=qm,qm")
@@ -13963,7 +14315,9 @@ (define_insn "*btsq"
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && (TARGET_USE_BT || reload_completed)"
   "bts{q}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "DI")])
 
 (define_insn "*btrq"
   [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "+r")
@@ -13973,7 +14327,9 @@ (define_insn "*btrq"
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && (TARGET_USE_BT || reload_completed)"
   "btr{q}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "DI")])
 
 (define_insn "*btcq"
   [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "+r")
@@ -13983,7 +14339,9 @@ (define_insn "*btcq"
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && (TARGET_USE_BT || reload_completed)"
   "btc{q}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "DI")])
 
 ;; Allow Nocona to avoid these instructions if a register is available.
 
@@ -14094,7 +14452,9 @@ (define_insn "*btdi_rex64"
 	  (const_int 0)))]
   "TARGET_64BIT && (TARGET_USE_BT || optimize_function_for_size_p (cfun))"
   "bt{q}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "DI")])
 
 (define_insn "*btsi"
   [(set (reg:CCC FLAGS_REG)
@@ -14106,7 +14466,9 @@ (define_insn "*btsi"
 	  (const_int 0)))]
   "TARGET_USE_BT || optimize_function_for_size_p (cfun)"
   "bt{l}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "SI")])
 
 ;; Store-flag instructions.
 
@@ -14231,6 +14593,7 @@ (define_insn "*avx_setcc<mode>"
   "vcmp%D1s<ssemodefsuffix>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "ssecmp")
    (set_attr "prefix" "vex")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*sse_setcc<mode>"
@@ -14241,6 +14604,7 @@ (define_insn "*sse_setcc<mode>"
   "SSE_FLOAT_MODE_P (<MODE>mode) && !TARGET_SSE5"
   "cmp%D1s<ssemodefsuffix>\t{%3, %0|%0, %3}"
   [(set_attr "type" "ssecmp")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*sse5_setcc<mode>"
@@ -14251,6 +14615,7 @@ (define_insn "*sse5_setcc<mode>"
   "TARGET_SSE5"
   "com%Y1s<ssemodefsuffix>\t{%3, %2, %0|%0, %2, %3}"
   [(set_attr "type" "sse4arg")
+   (set_attr "length_immediate" "1")
    (set_attr "mode" "<MODE>")])
 
 
@@ -15285,7 +15650,7 @@ (define_insn "return_internal_long"
    (unspec [(const_int 0)] UNSPEC_REP)]
   "reload_completed"
   "rep\;ret"
-  [(set_attr "length" "1")
+  [(set_attr "length" "2")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
    (set_attr "prefix_rep" "1")
@@ -15367,7 +15732,8 @@ (define_insn "set_got_rex64"
   "TARGET_64BIT"
   "lea{q}\t{_GLOBAL_OFFSET_TABLE_(%%rip), %0|%0, _GLOBAL_OFFSET_TABLE_[rip]}"
   [(set_attr "type" "lea")
-   (set_attr "length" "6")])
+   (set_attr "length_address" "4")
+   (set_attr "mode" "DI")])
 
 (define_insn "set_rip_rex64"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -15375,7 +15741,8 @@ (define_insn "set_rip_rex64"
   "TARGET_64BIT"
   "lea{q}\t{%l1(%%rip), %0|%0, %l1[rip]}"
   [(set_attr "type" "lea")
-   (set_attr "length" "6")])
+   (set_attr "length_address" "4")
+   (set_attr "mode" "DI")])
 
 (define_insn "set_got_offset_rex64"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -15385,7 +15752,9 @@ (define_insn "set_got_offset_rex64"
   "TARGET_64BIT"
   "movabs{q}\t{$_GLOBAL_OFFSET_TABLE_-%l1, %0|%0, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_-%l1}"
   [(set_attr "type" "imov")
-   (set_attr "length" "11")])
+   (set_attr "length_immediate" "0")
+   (set_attr "length_address" "8")
+   (set_attr "mode" "DI")])
 
 (define_expand "epilogue"
   [(const_int 0)]
@@ -15508,7 +15877,9 @@ (define_insn "*ffssi_1"
 	(ctz:SI (match_dup 1)))]
   ""
   "bsf{l}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "SI")])
 
 (define_expand "ffsdi2"
   [(set (match_dup 2) (const_int -1))
@@ -15534,7 +15905,9 @@ (define_insn "*ffsdi_1"
 	(ctz:DI (match_dup 1)))]
   "TARGET_64BIT"
   "bsf{q}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "DI")])
 
 (define_insn "ctzsi2"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -15542,7 +15915,9 @@ (define_insn "ctzsi2"
    (clobber (reg:CC FLAGS_REG))]
   ""
   "bsf{l}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "SI")])
 
 (define_insn "ctzdi2"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -15550,7 +15925,9 @@ (define_insn "ctzdi2"
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT"
   "bsf{q}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")])
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "mode" "DI")])
 
 (define_expand "clzsi2"
   [(parallel
@@ -15587,7 +15964,8 @@ (define_insn "*bsr"
    (clobber (reg:CC FLAGS_REG))]
   ""
   "bsr{l}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
    (set_attr "mode" "SI")])
 
 (define_insn "popcount<mode>2"
@@ -15771,7 +16149,8 @@ (define_insn "*bsr_rex64"
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT"
   "bsr{q}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
    (set_attr "mode" "DI")])
 
 (define_expand "clzhi2"
@@ -15809,7 +16188,8 @@ (define_insn "*bsrhi"
    (clobber (reg:CC FLAGS_REG))]
   ""
   "bsr{w}\t{%1, %0|%0, %1}"
-  [(set_attr "prefix_0f" "1")
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
    (set_attr "mode" "HI")])
 
 (define_expand "paritydi2"
@@ -18901,6 +19281,7 @@ (define_insn "fxam<mode>2_i387"
   "TARGET_USE_FANCY_MATH_387"
   "fxam\n\tfnstsw\t%0"
   [(set_attr "type" "multi")
+   (set_attr "length" "4")
    (set_attr "unit" "i387")
    (set_attr "mode" "<MODE>")])
 
@@ -19190,6 +19571,7 @@ (define_insn "*strmovqi_rex_1"
   "movsb"
   [(set_attr "type" "str")
    (set_attr "memory" "both")
+   (set_attr "prefix_rex" "0")
    (set_attr "mode" "QI")])
 
 (define_expand "rep_mov"
@@ -19446,6 +19828,7 @@ (define_insn "*strsetqi_rex_1"
   "stosb"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
+   (set_attr "prefix_rex" "0")
    (set_attr "mode" "QI")])
 
 (define_expand "rep_stos"
@@ -19539,6 +19922,7 @@ (define_insn "*rep_stosqi_rex64"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
    (set_attr "memory" "store")
+   (set_attr "prefix_rex" "0")
    (set_attr "mode" "QI")])
 
 (define_expand "cmpstrnsi"
@@ -19665,6 +20049,7 @@ (define_insn "*cmpstrnqi_nz_rex_1"
   "repz cmpsb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
+   (set_attr "prefix_rex" "0")
    (set_attr "prefix_rep" "1")])
 
 ;; The same, but the count is not known to not be zero.
@@ -19718,6 +20103,7 @@ (define_insn "*cmpstrnqi_rex_1"
   "repz cmpsb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
+   (set_attr "prefix_rex" "0")
    (set_attr "prefix_rep" "1")])
 
 (define_expand "strlensi"
@@ -19779,6 +20165,7 @@ (define_insn "*strlenqi_rex_1"
   "repnz scasb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
+   (set_attr "prefix_rex" "0")
    (set_attr "prefix_rep" "1")])
 
 ;; Peephole optimizations to clean up after cmpstrn*.  This should be
@@ -20299,6 +20686,14 @@ (define_insn "pro_epilogue_adjust_stack_
 		 (const_string "imov")
 	      ]
 	      (const_string "lea")))
+   (set (attr "length_immediate")
+	(cond [(eq_attr "type" "imov")
+		 (const_string "0")
+	       (and (eq_attr "type" "alu")
+		    (match_operand 2 "const128_operand" ""))
+		 (const_string "1")
+	      ]
+	      (const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_insn "pro_epilogue_adjust_stack_rex64"
@@ -20343,6 +20738,14 @@ (define_insn "pro_epilogue_adjust_stack_
 		 (const_string "imov")
 	      ]
 	      (const_string "lea")))
+   (set (attr "length_immediate")
+	(cond [(eq_attr "type" "imov")
+		 (const_string "0")
+	       (and (eq_attr "type" "alu")
+		    (match_operand 2 "const128_operand" ""))
+		 (const_string "1")
+	      ]
+	      (const_string "*")))
    (set_attr "mode" "DI")])
 
 (define_insn "pro_epilogue_adjust_stack_rex64_2"
@@ -21830,6 +22233,7 @@ (define_insn "*prefetch_sse"
 }
   [(set_attr "type" "sse")
    (set_attr "atom_sse_attr" "prefetch")
+   (set (attr "length_address") (symbol_ref "memory_address_length (operands[0])"))
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_sse_rex"
@@ -21849,6 +22253,7 @@ (define_insn "*prefetch_sse_rex"
 }
   [(set_attr "type" "sse")
    (set_attr "atom_sse_attr" "prefetch")
+   (set (attr "length_address") (symbol_ref "memory_address_length (operands[0])"))
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_3dnow"
@@ -21863,6 +22268,7 @@ (define_insn "*prefetch_3dnow"
     return "prefetchw\t%a0";
 }
   [(set_attr "type" "mmx")
+   (set (attr "length_address") (symbol_ref "memory_address_length (operands[0])"))
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_3dnow_rex"
@@ -21877,6 +22283,7 @@ (define_insn "*prefetch_3dnow_rex"
     return "prefetchw\t%a0";
 }
   [(set_attr "type" "mmx")
+   (set (attr "length_address") (symbol_ref "memory_address_length (operands[0])"))
    (set_attr "memory" "none")])
 
 (define_expand "stack_protect_set"
@@ -22035,6 +22442,14 @@ (define_insn "sse4_2_crc32<mode>"
   [(set_attr "type" "sselog1")
    (set_attr "prefix_rep" "1")
    (set_attr "prefix_extra" "1")
+   (set (attr "prefix_data16")
+     (if_then_else (match_operand:HI 2 "" "")
+       (const_string "1")
+       (const_string "*")))
+   (set (attr "prefix_rex")
+     (if_then_else (match_operand:QI 2 "ext_QIreg_operand" "")
+       (const_string "1")
+       (const_string "*")))
    (set_attr "mode" "SI")])
 
 (define_insn "sse4_2_crc32di"
--- gcc/output.h.jj	2009-01-14 12:06:29.000000000 +0100
+++ gcc/output.h	2009-06-09 10:46:09.000000000 +0200
@@ -1,7 +1,7 @@
 /* Declarations for insn-output.c.  These functions are defined in recog.c,
    final.c, and varasm.c.
    Copyright (C) 1987, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,
-   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -94,6 +94,10 @@ extern int insn_current_reference_addres
    Defined in final.c.  */
 extern int label_to_alignment (rtx);
 
+/* Find the alignment maximum skip associated with a CODE_LABEL.
+   Defined in final.c.  */
+extern int label_to_max_skip (rtx);
+
 /* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */
 extern void output_asm_label (rtx);
 
