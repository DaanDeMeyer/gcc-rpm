2007-10-15  Jakub Jelinek  <jakub@redhat.com>

	PR c++/33744
	* parser.c (cp_parser_parenthesized_expression_list): Set
	greater_than_is_operator_p to true in between the parens.

	* g++.dg/template/arg6.C: New test.

--- gcc/cp/parser.c.jj	2007-10-12 00:28:24.000000000 +0200
+++ gcc/cp/parser.c	2007-10-15 14:52:02.000000000 +0200
@@ -4976,6 +4976,7 @@ cp_parser_parenthesized_expression_list 
   tree expression_list = NULL_TREE;
   bool fold_expr_p = is_attribute_list;
   tree identifier = NULL_TREE;
+  bool saved_greater_than_is_operator_p;
 
   /* Assume all the expressions will be constant.  */
   if (non_constant_p)
@@ -4984,6 +4985,12 @@ cp_parser_parenthesized_expression_list 
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, "`('"))
     return error_mark_node;
 
+  /* Within a parenthesized expression, a `>' token is always
+     the greater-than operator.  */
+  saved_greater_than_is_operator_p
+    = parser->greater_than_is_operator_p;
+  parser->greater_than_is_operator_p = true;
+
   /* Consume expressions until there are no more.  */
   if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))
     while (true)
@@ -5069,9 +5076,16 @@ cp_parser_parenthesized_expression_list 
       if (ending < 0)
 	goto get_comma;
       if (!ending)
-	return error_mark_node;
+	{
+	  parser->greater_than_is_operator_p
+	    = saved_greater_than_is_operator_p;
+	  return error_mark_node;
+	}
     }
 
+  parser->greater_than_is_operator_p
+    = saved_greater_than_is_operator_p;
+
   /* We built up the list in reverse order so we must reverse it now.  */
   expression_list = nreverse (expression_list);
   if (identifier)
--- gcc/testsuite/g++.dg/template/arg6.C.jj	2007-10-15 14:59:13.000000000 +0200
+++ gcc/testsuite/g++.dg/template/arg6.C	2007-10-15 14:57:31.000000000 +0200
@@ -0,0 +1,15 @@
+// PR c++/33744
+// { dg-do run }
+
+template <bool B> struct A { bool b; A() : b(B) {}; };
+A<bool(1)> a;
+A<bool(1<2)> b;
+A<(bool)(2>1)> c;
+A<bool((2>1))> d;
+A<bool(2>1)> e;
+
+int
+main ()
+{
+  return (a.b && b.b && c.b && d.b && e.b) ? 0 : 1;
+}
